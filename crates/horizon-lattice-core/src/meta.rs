//! Meta-object system for Horizon Lattice.
//!
//! This module provides Qt-inspired runtime type information (RTTI) and introspection:
//!
//! - **MetaObject**: Static metadata for each Object type (like QMetaObject)
//! - **MetaProperty**: Property metadata with type-erased getters/setters
//! - **SignalMeta**: Signal metadata for introspection
//! - **MethodMeta**: Callable method metadata for dynamic invocation
//!
//! The meta-object system enables:
//! - Runtime type identification and safe downcasting
//! - Dynamic property access by name
//! - Signal/slot introspection
//! - Dynamic method invocation
//! - Object factory pattern (create by type name)
//!
//! # Architecture
//!
//! Each type that derives `Object` gets a static `MetaObject` generated at compile time.
//! This metadata includes:
//! - Type information (TypeId, name, parent type)
//! - Property descriptors with type-erased accessors
//! - Signal descriptors
//! - Method descriptors for dynamic invocation
//!
//! # Example
//!
//! ```ignore
//! use horizon_lattice_core::meta::MetaObject;
//! use horizon_lattice_core::Object;
//!
//! // Get meta-object from an instance
//! let obj: &dyn Object = &my_widget;
//! if let Some(meta) = obj.meta_object() {
//!     println!("Type: {}", meta.type_name);
//!
//!     // List all properties
//!     for prop in meta.properties() {
//!         println!("  Property: {} ({})", prop.name, prop.type_name);
//!     }
//! }
//! ```

use std::any::{Any, TypeId};
use std::fmt;

use crate::Object;

/// Error types for meta-object operations.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum MetaError {
    /// Property was not found.
    PropertyNotFound { name: String },
    /// Property type mismatch during get/set.
    PropertyTypeMismatch {
        expected: &'static str,
        got: &'static str,
    },
    /// Property is read-only.
    PropertyReadOnly { name: String },
    /// Method was not found.
    MethodNotFound { name: String },
    /// Wrong number of arguments for method invocation.
    ArgumentCount { expected: usize, got: usize },
    /// Argument type mismatch.
    ArgumentTypeMismatch {
        index: usize,
        expected: &'static str,
    },
    /// Signal was not found.
    SignalNotFound { name: String },
    /// Type not registered in the type registry.
    TypeNotRegistered { name: String },
    /// Failed to downcast object to concrete type.
    DowncastFailed,
}

impl fmt::Display for MetaError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::PropertyNotFound { name } => write!(f, "Property '{}' not found", name),
            Self::PropertyTypeMismatch { expected, got } => {
                write!(f, "Property type mismatch: expected {}, got {}", expected, got)
            }
            Self::PropertyReadOnly { name } => write!(f, "Property '{}' is read-only", name),
            Self::MethodNotFound { name } => write!(f, "Method '{}' not found", name),
            Self::ArgumentCount { expected, got } => {
                write!(f, "Wrong argument count: expected {}, got {}", expected, got)
            }
            Self::ArgumentTypeMismatch { index, expected } => {
                write!(f, "Argument {} type mismatch: expected {}", index, expected)
            }
            Self::SignalNotFound { name } => write!(f, "Signal '{}' not found", name),
            Self::TypeNotRegistered { name } => write!(f, "Type '{}' not registered", name),
            Self::DowncastFailed => write!(f, "Failed to downcast object"),
        }
    }
}

impl std::error::Error for MetaError {}

/// Result type for meta-object operations.
pub type MetaResult<T> = Result<T, MetaError>;

/// Static metadata for an Object type.
///
/// `MetaObject` is the Rust equivalent of Qt's `QMetaObject`. It provides
/// compile-time generated metadata about a type, including:
/// - Type identification (TypeId, name)
/// - Inheritance chain (parent MetaObject)
/// - Property descriptors with type-erased accessors
/// - Signal descriptors
/// - Method descriptors for dynamic invocation
/// - Optional factory function for dynamic instantiation
///
/// # Lifetime
///
/// `MetaObject` instances are static and live for the entire program duration.
/// They are typically generated by the `#[derive(Object)]` macro.
pub struct MetaObject {
    /// The `TypeId` for this type.
    pub type_id: TypeId,

    /// Human-readable type name (e.g., "MyWidget").
    pub type_name: &'static str,

    /// Parent class meta-object for inheritance chain.
    ///
    /// This enables `inherits()` checks and property/method lookup
    /// through the inheritance hierarchy.
    pub parent: Option<&'static MetaObject>,

    /// Registered properties with type-erased accessors.
    pub properties: &'static [MetaProperty],

    /// Registered signals.
    pub signals: &'static [SignalMeta],

    /// Registered callable methods.
    pub methods: &'static [MethodMeta],

    /// Factory function for dynamic object creation.
    ///
    /// If `Some`, this type can be instantiated by name via `TypeRegistry::create()`.
    /// The function should return a boxed default-constructed instance.
    pub create: Option<fn() -> Box<dyn Object>>,
}

impl MetaObject {
    /// Create a new MetaObject (typically called by generated code).
    pub const fn new(
        type_id: TypeId,
        type_name: &'static str,
        parent: Option<&'static MetaObject>,
        properties: &'static [MetaProperty],
        signals: &'static [SignalMeta],
        methods: &'static [MethodMeta],
        create: Option<fn() -> Box<dyn Object>>,
    ) -> Self {
        Self {
            type_id,
            type_name,
            parent,
            properties,
            signals,
            methods,
            create,
        }
    }

    /// Check if this type inherits from another type.
    ///
    /// Returns `true` if `self` is the same type as `other` or if any
    /// ancestor in the inheritance chain matches `other`.
    pub fn inherits(&self, other: &MetaObject) -> bool {
        if self.type_id == other.type_id {
            return true;
        }
        match self.parent {
            Some(parent) => parent.inherits(other),
            None => false,
        }
    }

    /// Check if this type inherits from a type with the given TypeId.
    pub fn inherits_type_id(&self, type_id: TypeId) -> bool {
        if self.type_id == type_id {
            return true;
        }
        match self.parent {
            Some(parent) => parent.inherits_type_id(type_id),
            None => false,
        }
    }

    /// Find a property by name, searching this type and ancestors.
    pub fn property(&self, name: &str) -> Option<&MetaProperty> {
        self.properties
            .iter()
            .find(|p| p.name == name)
            .or_else(|| self.parent.and_then(|p| p.property(name)))
    }

    /// Find a signal by name, searching this type and ancestors.
    pub fn signal(&self, name: &str) -> Option<&SignalMeta> {
        self.signals
            .iter()
            .find(|s| s.name == name)
            .or_else(|| self.parent.and_then(|p| p.signal(name)))
    }

    /// Find a method by name, searching this type and ancestors.
    pub fn method(&self, name: &str) -> Option<&MethodMeta> {
        self.methods
            .iter()
            .find(|m| m.name == name)
            .or_else(|| self.parent.and_then(|p| p.method(name)))
    }

    /// Get all property names (including inherited).
    pub fn property_names(&self) -> Vec<&'static str> {
        let mut names: Vec<&'static str> = self.properties.iter().map(|p| p.name).collect();
        if let Some(parent) = self.parent {
            names.extend(parent.property_names());
        }
        names
    }

    /// Get all signal names (including inherited).
    pub fn signal_names(&self) -> Vec<&'static str> {
        let mut names: Vec<&'static str> = self.signals.iter().map(|s| s.name).collect();
        if let Some(parent) = self.parent {
            names.extend(parent.signal_names());
        }
        names
    }

    /// Get all method names (including inherited).
    pub fn method_names(&self) -> Vec<&'static str> {
        let mut names: Vec<&'static str> = self.methods.iter().map(|m| m.name).collect();
        if let Some(parent) = self.parent {
            names.extend(parent.method_names());
        }
        names
    }

    /// Get a property value from an object by name.
    pub fn get_property(&self, obj: &dyn Object, name: &str) -> MetaResult<Box<dyn Any>> {
        let prop = self
            .property(name)
            .ok_or_else(|| MetaError::PropertyNotFound { name: name.to_string() })?;
        Ok((prop.getter)(obj))
    }

    /// Set a property value on an object by name.
    pub fn set_property(
        &self,
        obj: &mut dyn Object,
        name: &str,
        value: Box<dyn Any>,
    ) -> MetaResult<()> {
        let prop = self
            .property(name)
            .ok_or_else(|| MetaError::PropertyNotFound { name: name.to_string() })?;
        let setter = prop
            .setter
            .ok_or_else(|| MetaError::PropertyReadOnly { name: name.to_string() })?;
        (setter)(obj, value)
    }

    /// Invoke a method by name with dynamic arguments.
    pub fn invoke(
        &self,
        obj: &mut dyn Object,
        method_name: &str,
        args: &[Box<dyn Any>],
    ) -> MetaResult<Box<dyn Any>> {
        let method = self
            .method(method_name)
            .ok_or_else(|| MetaError::MethodNotFound { name: method_name.to_string() })?;

        if args.len() != method.param_types.len() {
            return Err(MetaError::ArgumentCount {
                expected: method.param_types.len(),
                got: args.len(),
            });
        }

        Ok((method.invoke)(obj, args))
    }
}

impl fmt::Debug for MetaObject {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MetaObject")
            .field("type_name", &self.type_name)
            .field("parent", &self.parent.map(|p| p.type_name))
            .field("properties", &self.properties.len())
            .field("signals", &self.signals.len())
            .field("methods", &self.methods.len())
            .field("has_factory", &self.create.is_some())
            .finish()
    }
}

// MetaObject is inherently thread-safe (all data is static/const)
unsafe impl Send for MetaObject {}
unsafe impl Sync for MetaObject {}

/// Metadata for a property with type-erased accessors.
///
/// `MetaProperty` extends the basic `PropertyMeta` with function pointers
/// for runtime property access. This enables Qt-like dynamic property
/// manipulation by name.
///
/// # Type Erasure
///
/// The getter and setter use `Box<dyn Any>` for type-erased value passing.
/// The actual type is validated at runtime using the `type_id` field.
///
/// # Generated Code
///
/// These are typically generated by `#[derive(Object)]` based on
/// `#[property]` attributes.
pub struct MetaProperty {
    /// Property name (e.g., "text", "enabled").
    pub name: &'static str,

    /// Type name for debugging/serialization (e.g., "String", "bool").
    pub type_name: &'static str,

    /// TypeId for runtime type checking.
    pub type_id: TypeId,

    /// Whether this property is read-only.
    pub read_only: bool,

    /// Name of the signal emitted when this property changes.
    pub notify_signal: Option<&'static str>,

    /// Type-erased getter function.
    ///
    /// Takes a reference to the object and returns the property value
    /// boxed as `dyn Any`.
    pub getter: fn(&dyn Object) -> Box<dyn Any>,

    /// Type-erased setter function.
    ///
    /// Takes a mutable reference to the object and a boxed value.
    /// Returns an error if the type doesn't match or the property is read-only.
    pub setter: Option<fn(&mut dyn Object, Box<dyn Any>) -> MetaResult<()>>,
}

impl MetaProperty {
    /// Create a new MetaProperty (typically called by generated code).
    #[allow(clippy::too_many_arguments)]
    pub const fn new(
        name: &'static str,
        type_name: &'static str,
        type_id: TypeId,
        read_only: bool,
        notify_signal: Option<&'static str>,
        getter: fn(&dyn Object) -> Box<dyn Any>,
        setter: Option<fn(&mut dyn Object, Box<dyn Any>) -> MetaResult<()>>,
    ) -> Self {
        Self {
            name,
            type_name,
            type_id,
            read_only,
            notify_signal,
            getter,
            setter,
        }
    }

    /// Get the property value from an object.
    pub fn get(&self, obj: &dyn Object) -> Box<dyn Any> {
        (self.getter)(obj)
    }

    /// Set the property value on an object.
    pub fn set(&self, obj: &mut dyn Object, value: Box<dyn Any>) -> MetaResult<()> {
        let setter = self
            .setter
            .ok_or_else(|| MetaError::PropertyReadOnly { name: self.name.to_string() })?;
        (setter)(obj, value)
    }

    /// Check if a value is the correct type for this property.
    pub fn check_type(&self, value: &dyn Any) -> bool {
        value.type_id() == self.type_id
    }
}

impl fmt::Debug for MetaProperty {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MetaProperty")
            .field("name", &self.name)
            .field("type_name", &self.type_name)
            .field("read_only", &self.read_only)
            .field("notify_signal", &self.notify_signal)
            .finish()
    }
}

// MetaProperty is thread-safe (static data + Send+Sync function pointers)
unsafe impl Send for MetaProperty {}
unsafe impl Sync for MetaProperty {}

/// Metadata for a signal.
///
/// Provides introspection information about signals, including their
/// parameter types. This enables runtime signal discovery and documentation.
#[derive(Debug, Clone)]
pub struct SignalMeta {
    /// Signal name (e.g., "clicked", "textChanged").
    pub name: &'static str,

    /// Parameter type names (for documentation/debugging).
    ///
    /// For example, a signal `textChanged(String, i32)` would have
    /// `param_types: &["String", "i32"]`.
    pub param_types: &'static [&'static str],

    /// Index in the object's signal table.
    ///
    /// This is used internally for signal dispatch and is assigned
    /// by the `#[derive(Object)]` macro.
    pub index: usize,
}

impl SignalMeta {
    /// Create a new SignalMeta (typically called by generated code).
    pub const fn new(name: &'static str, param_types: &'static [&'static str], index: usize) -> Self {
        Self {
            name,
            param_types,
            index,
        }
    }

    /// Get the number of parameters this signal takes.
    pub const fn param_count(&self) -> usize {
        self.param_types.len()
    }
}

/// Metadata for a callable method.
///
/// Enables dynamic method invocation by name, similar to Qt's
/// `QMetaObject::invokeMethod()`. Methods are registered with
/// the `#[method]` attribute.
pub struct MethodMeta {
    /// Method name (e.g., "increment", "setText").
    pub name: &'static str,

    /// Parameter type names.
    pub param_types: &'static [&'static str],

    /// Return type name.
    pub return_type: &'static str,

    /// Type-erased method invoker.
    ///
    /// Takes a mutable object reference and boxed arguments,
    /// returns a boxed result.
    pub invoke: fn(&mut dyn Object, &[Box<dyn Any>]) -> Box<dyn Any>,
}

impl MethodMeta {
    /// Create a new MethodMeta (typically called by generated code).
    pub const fn new(
        name: &'static str,
        param_types: &'static [&'static str],
        return_type: &'static str,
        invoke: fn(&mut dyn Object, &[Box<dyn Any>]) -> Box<dyn Any>,
    ) -> Self {
        Self {
            name,
            param_types,
            return_type,
            invoke,
        }
    }

    /// Get the number of parameters this method takes.
    pub const fn param_count(&self) -> usize {
        self.param_types.len()
    }

    /// Invoke this method on an object.
    pub fn call(&self, obj: &mut dyn Object, args: &[Box<dyn Any>]) -> MetaResult<Box<dyn Any>> {
        if args.len() != self.param_types.len() {
            return Err(MetaError::ArgumentCount {
                expected: self.param_types.len(),
                got: args.len(),
            });
        }
        Ok((self.invoke)(obj, args))
    }
}

impl fmt::Debug for MethodMeta {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("MethodMeta")
            .field("name", &self.name)
            .field("param_types", &self.param_types)
            .field("return_type", &self.return_type)
            .finish()
    }
}

// MethodMeta is thread-safe
unsafe impl Send for MethodMeta {}
unsafe impl Sync for MethodMeta {}

// ============================================================================
// Type Registry
// ============================================================================

use std::collections::HashMap;
use parking_lot::RwLock;

/// Global registry of all Object types.
///
/// The `TypeRegistry` provides a central location for looking up `MetaObject`s
/// by type name or `TypeId`. This enables:
/// - Dynamic object creation by type name
/// - Type introspection without having an instance
/// - Factory pattern for plugin/extension systems
///
/// # Thread Safety
///
/// The registry is protected by a `RwLock`, allowing concurrent reads with
/// exclusive writes. Registration typically happens at startup, after which
/// reads dominate.
///
/// # Auto-Registration
///
/// Types derived with `#[derive(Object)]` can be automatically registered
/// using the `register_type!` macro or by calling `TypeRegistry::register()`
/// during initialization.
///
/// # Example
///
/// ```ignore
/// use horizon_lattice_core::{TypeRegistry, Object};
///
/// // Register a type
/// TypeRegistry::register(&MyWidget::META);
///
/// // Look up by name
/// if let Some(meta) = TypeRegistry::get_by_name("MyWidget") {
///     println!("Found type: {}", meta.type_name);
/// }
///
/// // Create an instance dynamically
/// if let Some(obj) = TypeRegistry::create("MyWidget") {
///     // obj is Box<dyn Object>
/// }
/// ```
pub struct TypeRegistry {
    by_name: HashMap<&'static str, &'static MetaObject>,
    by_type_id: HashMap<TypeId, &'static MetaObject>,
}

impl TypeRegistry {
    /// Create a new empty type registry.
    fn new() -> Self {
        Self {
            by_name: HashMap::new(),
            by_type_id: HashMap::new(),
        }
    }

    /// Register a type's MetaObject in the global registry.
    ///
    /// This should be called once per type, typically during application
    /// initialization or via auto-registration.
    ///
    /// # Example
    ///
    /// ```ignore
    /// TypeRegistry::register(&MyWidget::META);
    /// ```
    pub fn register(meta: &'static MetaObject) {
        let mut guard = GLOBAL_TYPE_REGISTRY.write();
        let registry = guard.get_or_insert_with(TypeRegistry::new);

        tracing::trace!(
            target: "horizon_lattice_core::meta",
            type_name = meta.type_name,
            "registering type in TypeRegistry"
        );

        registry.by_name.insert(meta.type_name, meta);
        registry.by_type_id.insert(meta.type_id, meta);
    }

    /// Unregister a type from the global registry.
    ///
    /// Returns `true` if the type was found and removed.
    pub fn unregister(meta: &'static MetaObject) -> bool {
        let mut guard = GLOBAL_TYPE_REGISTRY.write();
        if let Some(registry) = guard.as_mut() {
            let removed_name = registry.by_name.remove(meta.type_name).is_some();
            let removed_id = registry.by_type_id.remove(&meta.type_id).is_some();
            removed_name || removed_id
        } else {
            false
        }
    }

    /// Look up a type's MetaObject by its type name.
    ///
    /// # Example
    ///
    /// ```ignore
    /// if let Some(meta) = TypeRegistry::get_by_name("Button") {
    ///     println!("Button has {} properties", meta.properties.len());
    /// }
    /// ```
    pub fn get_by_name(name: &str) -> Option<&'static MetaObject> {
        let guard = GLOBAL_TYPE_REGISTRY.read();
        guard.as_ref().and_then(|r| r.by_name.get(name).copied())
    }

    /// Look up a type's MetaObject by its TypeId.
    ///
    /// This is useful when you have a `TypeId` from `std::any::TypeId::of::<T>()`
    /// but need the full MetaObject.
    pub fn get_by_type_id(type_id: TypeId) -> Option<&'static MetaObject> {
        let guard = GLOBAL_TYPE_REGISTRY.read();
        guard.as_ref().and_then(|r| r.by_type_id.get(&type_id).copied())
    }

    /// Look up a type's MetaObject by the concrete type.
    ///
    /// This is a convenience wrapper around `get_by_type_id`.
    pub fn get<T: 'static>() -> Option<&'static MetaObject> {
        Self::get_by_type_id(TypeId::of::<T>())
    }

    /// Create an object instance by type name.
    ///
    /// Returns `None` if:
    /// - The type is not registered
    /// - The type has no factory function (e.g., marked with `#[object(no_factory)]`)
    ///
    /// # Example
    ///
    /// ```ignore
    /// if let Some(obj) = TypeRegistry::create("Button") {
    ///     // obj is a Box<dyn Object> pointing to a new Button instance
    /// }
    /// ```
    pub fn create(type_name: &str) -> Option<Box<dyn crate::Object>> {
        let meta = Self::get_by_name(type_name)?;
        let factory = meta.create?;
        Some(factory())
    }

    /// Create an object instance by TypeId.
    ///
    /// Returns `None` if:
    /// - The type is not registered
    /// - The type has no factory function
    pub fn create_by_type_id(type_id: TypeId) -> Option<Box<dyn crate::Object>> {
        let meta = Self::get_by_type_id(type_id)?;
        let factory = meta.create?;
        Some(factory())
    }

    /// Get all registered type names.
    ///
    /// Useful for debugging, documentation, or building dynamic UI.
    pub fn registered_types() -> Vec<&'static str> {
        let guard = GLOBAL_TYPE_REGISTRY.read();
        guard
            .as_ref()
            .map(|r| r.by_name.keys().copied().collect())
            .unwrap_or_default()
    }

    /// Get the number of registered types.
    pub fn type_count() -> usize {
        let guard = GLOBAL_TYPE_REGISTRY.read();
        guard.as_ref().map(|r| r.by_name.len()).unwrap_or(0)
    }

    /// Check if a type is registered by name.
    pub fn contains(type_name: &str) -> bool {
        Self::get_by_name(type_name).is_some()
    }

    /// Check if a type is registered by TypeId.
    pub fn contains_type_id(type_id: TypeId) -> bool {
        Self::get_by_type_id(type_id).is_some()
    }

    /// Clear all registered types.
    ///
    /// This is primarily useful for testing.
    pub fn clear() {
        let mut guard = GLOBAL_TYPE_REGISTRY.write();
        if let Some(registry) = guard.as_mut() {
            registry.by_name.clear();
            registry.by_type_id.clear();
        }
    }

    /// Execute a function with read access to the registry.
    ///
    /// This is useful for complex operations that need consistent access
    /// to the registry state.
    pub fn with_registry<F, R>(f: F) -> Option<R>
    where
        F: FnOnce(&TypeRegistry) -> R,
    {
        let guard = GLOBAL_TYPE_REGISTRY.read();
        guard.as_ref().map(f)
    }
}

/// Global type registry instance.
static GLOBAL_TYPE_REGISTRY: RwLock<Option<TypeRegistry>> = RwLock::new(None);

/// Initialize the global type registry.
///
/// This is called automatically when the first type is registered.
/// Calling it explicitly is a no-op but can be used to ensure
/// the registry exists before any lookups.
pub fn init_type_registry() {
    let mut guard = GLOBAL_TYPE_REGISTRY.write();
    if guard.is_none() {
        *guard = Some(TypeRegistry::new());
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::object::{init_global_registry, ObjectBase, ObjectId};

    // Test object for meta-object system
    struct TestWidget {
        base: ObjectBase,
        text: String,
        count: i32,
    }

    impl TestWidget {
        fn new() -> Self {
            Self {
                base: ObjectBase::new::<Self>(),
                text: String::new(),
                count: 0,
            }
        }

        fn text(&self) -> &str {
            &self.text
        }

        fn set_text(&mut self, text: String) {
            self.text = text;
        }

        fn count(&self) -> i32 {
            self.count
        }

        fn set_count(&mut self, count: i32) {
            self.count = count;
        }

        fn increment(&mut self) {
            self.count += 1;
        }
    }

    impl Object for TestWidget {
        fn object_id(&self) -> ObjectId {
            self.base.id()
        }

        fn meta_object(&self) -> Option<&'static MetaObject> {
            Some(&TEST_WIDGET_META)
        }
    }

    // Type-erased getter for text property
    fn test_widget_get_text(obj: &dyn Object) -> Box<dyn Any> {
        let widget = crate::object_cast::<TestWidget>(obj).unwrap();
        Box::new(widget.text().to_string())
    }

    // Type-erased setter for text property
    fn test_widget_set_text(obj: &mut dyn Object, value: Box<dyn Any>) -> MetaResult<()> {
        let widget = crate::object_cast_mut::<TestWidget>(obj).unwrap();
        let text = value.downcast::<String>().map_err(|_| MetaError::PropertyTypeMismatch {
            expected: "String",
            got: "unknown",
        })?;
        widget.set_text(*text);
        Ok(())
    }

    // Type-erased getter for count property
    fn test_widget_get_count(obj: &dyn Object) -> Box<dyn Any> {
        let widget = crate::object_cast::<TestWidget>(obj).unwrap();
        Box::new(widget.count())
    }

    // Type-erased setter for count property
    fn test_widget_set_count(obj: &mut dyn Object, value: Box<dyn Any>) -> MetaResult<()> {
        let widget = crate::object_cast_mut::<TestWidget>(obj).unwrap();
        let count = value.downcast::<i32>().map_err(|_| MetaError::PropertyTypeMismatch {
            expected: "i32",
            got: "unknown",
        })?;
        widget.set_count(*count);
        Ok(())
    }

    // Type-erased method invoker for increment
    fn test_widget_invoke_increment(obj: &mut dyn Object, _args: &[Box<dyn Any>]) -> Box<dyn Any> {
        let widget = crate::object_cast_mut::<TestWidget>(obj).unwrap();
        widget.increment();
        Box::new(())
    }

    // Static meta-object for TestWidget (simulates what #[derive(Object)] would generate)
    static TEST_WIDGET_META: MetaObject = MetaObject {
        type_id: TypeId::of::<TestWidget>(),
        type_name: "TestWidget",
        parent: None,
        properties: &[
            MetaProperty {
                name: "text",
                type_name: "String",
                type_id: TypeId::of::<String>(),
                read_only: false,
                notify_signal: Some("textChanged"),
                getter: test_widget_get_text,
                setter: Some(test_widget_set_text),
            },
            MetaProperty {
                name: "count",
                type_name: "i32",
                type_id: TypeId::of::<i32>(),
                read_only: false,
                notify_signal: Some("countChanged"),
                getter: test_widget_get_count,
                setter: Some(test_widget_set_count),
            },
        ],
        signals: &[
            SignalMeta {
                name: "clicked",
                param_types: &[],
                index: 0,
            },
            SignalMeta {
                name: "textChanged",
                param_types: &["String"],
                index: 1,
            },
            SignalMeta {
                name: "countChanged",
                param_types: &["i32"],
                index: 2,
            },
        ],
        methods: &[MethodMeta {
            name: "increment",
            param_types: &[],
            return_type: "()",
            invoke: test_widget_invoke_increment,
        }],
        create: None,
    };

    fn setup() {
        init_global_registry();
    }

    #[test]
    fn test_meta_object_type_info() {
        setup();

        let widget = TestWidget::new();
        let meta = widget.meta_object().unwrap();

        assert_eq!(meta.type_name, "TestWidget");
        assert_eq!(meta.type_id, TypeId::of::<TestWidget>());
        assert!(meta.parent.is_none());
    }

    #[test]
    fn test_meta_object_property_lookup() {
        setup();

        let widget = TestWidget::new();
        let meta = widget.meta_object().unwrap();

        // Find existing property
        let text_prop = meta.property("text");
        assert!(text_prop.is_some());
        assert_eq!(text_prop.unwrap().name, "text");
        assert_eq!(text_prop.unwrap().type_name, "String");

        // Non-existent property
        let missing = meta.property("nonexistent");
        assert!(missing.is_none());
    }

    #[test]
    fn test_meta_object_signal_lookup() {
        setup();

        let widget = TestWidget::new();
        let meta = widget.meta_object().unwrap();

        let clicked = meta.signal("clicked");
        assert!(clicked.is_some());
        assert_eq!(clicked.unwrap().param_types.len(), 0);

        let text_changed = meta.signal("textChanged");
        assert!(text_changed.is_some());
        assert_eq!(text_changed.unwrap().param_types, &["String"]);
    }

    #[test]
    fn test_meta_object_method_lookup() {
        setup();

        let widget = TestWidget::new();
        let meta = widget.meta_object().unwrap();

        let increment = meta.method("increment");
        assert!(increment.is_some());
        assert_eq!(increment.unwrap().param_count(), 0);
        assert_eq!(increment.unwrap().return_type, "()");
    }

    #[test]
    fn test_meta_property_get_set() {
        setup();

        let mut widget = TestWidget::new();
        let meta = widget.meta_object().unwrap();

        // Get initial value
        let text_value = meta.get_property(&widget, "text").unwrap();
        let text: &String = text_value.downcast_ref().unwrap();
        assert_eq!(text, "");

        // Set new value
        meta.set_property(&mut widget, "text", Box::new("Hello".to_string()))
            .unwrap();

        // Verify change
        assert_eq!(widget.text(), "Hello");

        // Get through meta again
        let text_value = meta.get_property(&widget, "text").unwrap();
        let text: &String = text_value.downcast_ref().unwrap();
        assert_eq!(text, "Hello");
    }

    #[test]
    fn test_meta_method_invoke() {
        setup();

        let mut widget = TestWidget::new();
        widget.set_count(5);

        let meta = widget.meta_object().unwrap();

        // Invoke increment method
        meta.invoke(&mut widget, "increment", &[]).unwrap();

        assert_eq!(widget.count(), 6);
    }

    #[test]
    fn test_meta_property_names() {
        setup();

        let widget = TestWidget::new();
        let meta = widget.meta_object().unwrap();

        let names = meta.property_names();
        assert!(names.contains(&"text"));
        assert!(names.contains(&"count"));
    }

    #[test]
    fn test_meta_signal_names() {
        setup();

        let widget = TestWidget::new();
        let meta = widget.meta_object().unwrap();

        let names = meta.signal_names();
        assert!(names.contains(&"clicked"));
        assert!(names.contains(&"textChanged"));
        assert!(names.contains(&"countChanged"));
    }

    #[test]
    fn test_meta_error_property_not_found() {
        setup();

        let widget = TestWidget::new();
        let meta = widget.meta_object().unwrap();

        let result = meta.get_property(&widget, "nonexistent");
        assert!(matches!(result, Err(MetaError::PropertyNotFound { .. })));
    }

    #[test]
    fn test_meta_error_method_not_found() {
        setup();

        let mut widget = TestWidget::new();
        let meta = widget.meta_object().unwrap();

        let result = meta.invoke(&mut widget, "nonexistent", &[]);
        assert!(matches!(result, Err(MetaError::MethodNotFound { .. })));
    }

    #[test]
    fn test_inherits_self() {
        setup();

        let widget = TestWidget::new();
        let meta = widget.meta_object().unwrap();

        assert!(meta.inherits(meta));
        assert!(meta.inherits_type_id(TypeId::of::<TestWidget>()));
    }

    // ========================================================================
    // TypeRegistry Tests
    // ========================================================================

    // Factory widget for testing dynamic creation
    struct FactoryWidget {
        base: ObjectBase,
    }

    impl FactoryWidget {
        fn new() -> Self {
            Self {
                base: ObjectBase::new::<Self>(),
            }
        }
    }

    impl Default for FactoryWidget {
        fn default() -> Self {
            Self::new()
        }
    }

    impl Object for FactoryWidget {
        fn object_id(&self) -> ObjectId {
            self.base.id()
        }

        fn meta_object(&self) -> Option<&'static MetaObject> {
            Some(&FACTORY_WIDGET_META)
        }
    }

    // Static meta-object with factory function
    static FACTORY_WIDGET_META: MetaObject = MetaObject {
        type_id: TypeId::of::<FactoryWidget>(),
        type_name: "FactoryWidget",
        parent: None,
        properties: &[],
        signals: &[],
        methods: &[],
        create: Some(|| Box::new(FactoryWidget::default())),
    };

    // Mutex to serialize TypeRegistry tests that rely on global state
    use std::sync::Mutex;
    static TYPE_REGISTRY_TEST_MUTEX: Mutex<()> = Mutex::new(());

    fn setup_type_registry() -> std::sync::MutexGuard<'static, ()> {
        setup();
        let guard = TYPE_REGISTRY_TEST_MUTEX.lock().unwrap();
        TypeRegistry::clear();
        guard
    }

    #[test]
    fn test_type_registry_register_and_lookup_by_name() {
        let _guard = setup_type_registry();

        // Initially not registered
        assert!(TypeRegistry::get_by_name("TestWidget").is_none());

        // Register
        TypeRegistry::register(&TEST_WIDGET_META);

        // Now can lookup by name
        let meta = TypeRegistry::get_by_name("TestWidget");
        assert!(meta.is_some());
        assert_eq!(meta.unwrap().type_name, "TestWidget");
    }

    #[test]
    fn test_type_registry_lookup_by_type_id() {
        let _guard = setup_type_registry();

        TypeRegistry::register(&TEST_WIDGET_META);

        // Lookup by TypeId
        let meta = TypeRegistry::get_by_type_id(TypeId::of::<TestWidget>());
        assert!(meta.is_some());
        assert_eq!(meta.unwrap().type_name, "TestWidget");

        // Convenience get<T> method
        let meta = TypeRegistry::get::<TestWidget>();
        assert!(meta.is_some());
    }

    #[test]
    fn test_type_registry_dynamic_creation() {
        let _guard = setup_type_registry();

        TypeRegistry::register(&FACTORY_WIDGET_META);

        // Create by type name
        let obj = TypeRegistry::create("FactoryWidget");
        assert!(obj.is_some());

        let obj = obj.unwrap();
        let meta = obj.meta_object().unwrap();
        assert_eq!(meta.type_name, "FactoryWidget");
    }

    #[test]
    fn test_type_registry_create_without_factory() {
        let _guard = setup_type_registry();

        TypeRegistry::register(&TEST_WIDGET_META);

        // TEST_WIDGET_META has create: None
        let obj = TypeRegistry::create("TestWidget");
        assert!(obj.is_none());
    }

    #[test]
    fn test_type_registry_create_unregistered() {
        let _guard = setup_type_registry();

        // Type not registered
        let obj = TypeRegistry::create("NonExistent");
        assert!(obj.is_none());
    }

    #[test]
    fn test_type_registry_contains() {
        let _guard = setup_type_registry();

        // Register then verify contains
        TypeRegistry::register(&TEST_WIDGET_META);

        assert!(TypeRegistry::contains("TestWidget"));
        assert!(TypeRegistry::contains_type_id(TypeId::of::<TestWidget>()));

        // Non-existent type should not be contained
        assert!(!TypeRegistry::contains("NonExistentType"));
    }

    #[test]
    fn test_type_registry_registered_types() {
        let _guard = setup_type_registry();

        TypeRegistry::register(&TEST_WIDGET_META);
        TypeRegistry::register(&FACTORY_WIDGET_META);

        let types = TypeRegistry::registered_types();
        assert!(types.contains(&"TestWidget"));
        assert!(types.contains(&"FactoryWidget"));
        assert_eq!(TypeRegistry::type_count(), 2);
    }

    #[test]
    fn test_type_registry_unregister() {
        let _guard = setup_type_registry();

        TypeRegistry::register(&TEST_WIDGET_META);
        assert!(TypeRegistry::contains("TestWidget"));

        let removed = TypeRegistry::unregister(&TEST_WIDGET_META);
        assert!(removed);
        assert!(!TypeRegistry::contains("TestWidget"));
    }

    #[test]
    fn test_type_registry_clear() {
        let _guard = setup_type_registry();

        TypeRegistry::register(&TEST_WIDGET_META);
        TypeRegistry::register(&FACTORY_WIDGET_META);
        assert_eq!(TypeRegistry::type_count(), 2);

        TypeRegistry::clear();
        assert_eq!(TypeRegistry::type_count(), 0);
    }
}
