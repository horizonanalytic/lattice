<!DOCTYPE HTML>
<html lang="en" class="rust sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Horizon Lattice Guide</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="A comprehensive guide to the Horizon Lattice GUI framework">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "rust";
            const default_dark_theme = "coal";
            window.path_to_searchindex_js = "searchindex-2ddae7e5.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-b89355f2.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('rust')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Horizon Lattice Guide</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/horizonanalytic/lattice" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <strong>Horizon Lattice</strong>, a Rust-native GUI framework inspired by Qt6’s comprehensive design philosophy.</p>
<h2 id="what-is-horizon-lattice"><a class="header" href="#what-is-horizon-lattice">What is Horizon Lattice?</a></h2>
<p>Horizon Lattice is a cross-platform GUI toolkit built from the ground up in Rust. It takes Qt’s proven concepts—signals/slots, declarative UI, comprehensive widget set, cross-platform support—and implements them idiomatically using Rust’s ownership model and safety guarantees.</p>
<h2 id="why-horizon-lattice"><a class="header" href="#why-horizon-lattice">Why Horizon Lattice?</a></h2>
<h3 id="pure-rust-no-c-dependencies"><a class="header" href="#pure-rust-no-c-dependencies">Pure Rust, No C++ Dependencies</a></h3>
<p>Unlike Qt bindings, Horizon Lattice is written entirely in Rust. This means:</p>
<ul>
<li>No external MOC tool required</li>
<li>Compile-time type checking for signals and slots</li>
<li>Memory safety guaranteed by the Rust compiler</li>
<li>Easy integration with the Rust ecosystem</li>
</ul>
<h3 id="qt-inspired-rust-idiomatic"><a class="header" href="#qt-inspired-rust-idiomatic">Qt-Inspired, Rust-Idiomatic</a></h3>
<p>We’ve adopted Qt’s battle-tested design patterns while making them feel natural in Rust:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Qt</th><th>Horizon Lattice</th></tr>
</thead>
<tbody>
<tr><td>Code generation</td><td>External MOC tool</td><td>Rust proc-macros</td></tr>
<tr><td>Signal type safety</td><td>Runtime</td><td>Compile-time</td></tr>
<tr><td>Memory management</td><td>Manual + parent-child</td><td>Rust ownership</td></tr>
<tr><td>License</td><td>LGPL/Commercial</td><td>MIT/Apache 2.0</td></tr>
</tbody>
</table>
</div>
<h3 id="modern-graphics"><a class="header" href="#modern-graphics">Modern Graphics</a></h3>
<p>Horizon Lattice uses modern graphics APIs through wgpu:</p>
<ul>
<li>Vulkan, Metal, DX12, and WebGPU backends</li>
<li>GPU-accelerated 2D rendering</li>
<li>Efficient damage tracking for minimal redraws</li>
</ul>
<h2 id="quick-example"><a class="header" href="#quick-example">Quick Example</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new();
    window.set_title("Hello, Horizon Lattice!");
    window.set_size(400, 300);

    let button = Button::new("Click me!");
    button.clicked().connect(|_| {
        println!("Button clicked!");
    });

    window.set_central_widget(button);
    window.show();

    app.run()
}</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<ul>
<li><strong>API Documentation</strong>: <a href="https://docs.rs/horizon-lattice">docs.rs/horizon-lattice</a></li>
<li><strong>GitHub</strong>: <a href="https://github.com/horizon-analytic-studios/horizon-lattice">github.com/horizon-analytic-studios/horizon-lattice</a></li>
<li><strong>Issues</strong>: Report bugs or request features on GitHub</li>
</ul>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>Horizon Lattice is dual-licensed under MIT and Apache 2.0. You may use it under either license.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>This guide covers how to add Horizon Lattice to your Rust project.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li><strong>Rust</strong>: 1.75 or later (for async features)</li>
<li><strong>Platform</strong>: Windows 10+, macOS 11+, or Linux with X11/Wayland</li>
</ul>
<h3 id="platform-specific-dependencies"><a class="header" href="#platform-specific-dependencies">Platform-Specific Dependencies</a></h3>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<p>On Linux, you’ll need development headers for graphics and windowing:</p>
<pre><code class="language-bash"># Ubuntu/Debian
sudo apt install libxkbcommon-dev libwayland-dev

# Fedora
sudo dnf install libxkbcommon-devel wayland-devel

# Arch
sudo pacman -S libxkbcommon wayland
</code></pre>
<h4 id="macos"><a class="header" href="#macos">macOS</a></h4>
<p>No additional dependencies required. Xcode Command Line Tools are recommended:</p>
<pre><code class="language-bash">xcode-select --install
</code></pre>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<p>No additional dependencies required. Visual Studio Build Tools are recommended.</p>
<h2 id="adding-to-your-project"><a class="header" href="#adding-to-your-project">Adding to Your Project</a></h2>
<p>Add Horizon Lattice to your <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
horizon-lattice = "0.1"
</code></pre>
<h3 id="optional-features"><a class="header" href="#optional-features">Optional Features</a></h3>
<p>Horizon Lattice provides several optional features:</p>
<pre><code class="language-toml">[dependencies]
horizon-lattice = { version = "0.1", features = ["multimedia", "network"] }
</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>multimedia</code></td><td>Audio/video playback support</td></tr>
<tr><td><code>network</code></td><td>HTTP client, WebSocket, TCP/UDP</td></tr>
<tr><td><code>accessibility</code></td><td>Screen reader support</td></tr>
</tbody>
</table>
</div>
<h2 id="verifying-installation"><a class="header" href="#verifying-installation">Verifying Installation</a></h2>
<p>Create a simple test application:</p>
<pre><code class="language-rust ignore">// src/main.rs
use horizon_lattice::prelude::*;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new();
    window.set_title("Installation Test");
    window.set_size(300, 200);
    window.show();

    app.run()
}</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">cargo run
</code></pre>
<p>If a window appears, you’re ready to go!</p>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="failed-to-create-graphics-context"><a class="header" href="#failed-to-create-graphics-context">“Failed to create graphics context”</a></h3>
<p>This usually means the GPU drivers don’t support the required graphics API. Try:</p>
<ul>
<li>Updating your GPU drivers</li>
<li>On Linux, ensure Vulkan is installed: <code>sudo apt install mesa-vulkan-drivers</code></li>
</ul>
<h3 id="build-errors-on-linux"><a class="header" href="#build-errors-on-linux">Build errors on Linux</a></h3>
<p>Ensure you have all development headers installed (see Platform-Specific Dependencies above).</p>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Continue to <a href="#your-first-application">Your First Application</a> to build something more interesting.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-application"><a class="header" href="#your-first-application">Your First Application</a></h1>
<p>Let’s build a simple counter application to learn the basics of Horizon Lattice.</p>
<h2 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h2>
<p>Create a new Rust project:</p>
<pre><code class="language-bash">cargo new counter-app
cd counter-app
</code></pre>
<p>Add Horizon Lattice to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
horizon-lattice = "0.1"
</code></pre>
<h2 id="the-counter-app"><a class="header" href="#the-counter-app">The Counter App</a></h2>
<p>Replace <code>src/main.rs</code> with:</p>
<pre><code class="language-rust ignore">use horizon_lattice::prelude::*;
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize the application
    let app = Application::new()?;

    // Create the main window
    let mut window = Window::new();
    window.set_title("Counter");
    window.set_size(300, 150);

    // Shared counter state
    let count = Arc::new(AtomicI32::new(0));

    // Create widgets
    let label = Label::new("Count: 0");
    let increment_btn = Button::new("+");
    let decrement_btn = Button::new("-");

    // Connect signals
    let label_clone = label.clone();
    let count_clone = count.clone();
    increment_btn.clicked().connect(move |_| {
        let new_value = count_clone.fetch_add(1, Ordering::SeqCst) + 1;
        label_clone.set_text(&amp;format!("Count: {}", new_value));
    });

    let label_clone = label.clone();
    let count_clone = count.clone();
    decrement_btn.clicked().connect(move |_| {
        let new_value = count_clone.fetch_sub(1, Ordering::SeqCst) - 1;
        label_clone.set_text(&amp;format!("Count: {}", new_value));
    });

    // Layout
    let mut layout = HBoxLayout::new();
    layout.add_widget(decrement_btn);
    layout.add_widget(label);
    layout.add_widget(increment_btn);

    let mut container = Container::new();
    container.set_layout(layout);

    window.set_central_widget(container);
    window.show();

    app.run()
}</code></pre>
<h2 id="understanding-the-code"><a class="header" href="#understanding-the-code">Understanding the Code</a></h2>
<h3 id="application-initialization"><a class="header" href="#application-initialization">Application Initialization</a></h3>
<pre><code class="language-rust ignore">let app = Application::new()?;</code></pre>
<p>Every Horizon Lattice application starts with <code>Application::new()</code>. This initializes the event loop, graphics context, and platform integration. There can only be one <code>Application</code> per process.</p>
<h3 id="creating-windows"><a class="header" href="#creating-windows">Creating Windows</a></h3>
<pre><code class="language-rust ignore">let mut window = Window::new();
window.set_title("Counter");
window.set_size(300, 150);</code></pre>
<p>Windows are top-level containers for your UI. Set properties like title, size, and position before calling <code>show()</code>.</p>
<h3 id="widgets"><a class="header" href="#widgets">Widgets</a></h3>
<pre><code class="language-rust ignore">let label = Label::new("Count: 0");
let increment_btn = Button::new("+");</code></pre>
<p>Widgets are the building blocks of your UI. Common widgets include:</p>
<ul>
<li><code>Label</code> - Display text</li>
<li><code>Button</code> - Clickable button</li>
<li><code>TextEdit</code> - Text input</li>
<li><code>Container</code> - Group other widgets</li>
</ul>
<h3 id="signals-and-slots"><a class="header" href="#signals-and-slots">Signals and Slots</a></h3>
<pre><code class="language-rust ignore">increment_btn.clicked().connect(move |_| {
    // Handle click
});</code></pre>
<p>Signals are the Qt-inspired way to handle events. When a button is clicked, it emits a <code>clicked</code> signal. You connect a closure (slot) to respond to it.</p>
<h3 id="layouts"><a class="header" href="#layouts">Layouts</a></h3>
<pre><code class="language-rust ignore">let mut layout = HBoxLayout::new();
layout.add_widget(decrement_btn);
layout.add_widget(label);
layout.add_widget(increment_btn);</code></pre>
<p>Layouts automatically arrange widgets. <code>HBoxLayout</code> arranges them horizontally. Other layouts include:</p>
<ul>
<li><code>VBoxLayout</code> - Vertical arrangement</li>
<li><code>GridLayout</code> - Grid arrangement</li>
<li><code>FormLayout</code> - Label/field pairs</li>
</ul>
<h3 id="running-the-event-loop"><a class="header" href="#running-the-event-loop">Running the Event Loop</a></h3>
<pre><code class="language-rust ignore">app.run()</code></pre>
<p>This starts the event loop, which:</p>
<ul>
<li>Processes user input (mouse, keyboard)</li>
<li>Dispatches signals</li>
<li>Repaints widgets as needed</li>
</ul>
<p>The function blocks until all windows are closed.</p>
<h2 id="run-it"><a class="header" href="#run-it">Run It</a></h2>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see a window with - and + buttons around a “Count: 0” label. Clicking the buttons updates the counter.</p>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Continue to <a href="#basic-concepts">Basic Concepts</a> to learn more about the widget system, signals, and layouts.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="basic-concepts"><a class="header" href="#basic-concepts">Basic Concepts</a></h1>
<p>This page covers the fundamental concepts you’ll use throughout Horizon Lattice.</p>
<h2 id="the-widget-tree"><a class="header" href="#the-widget-tree">The Widget Tree</a></h2>
<p>Widgets in Horizon Lattice form a tree structure. Every widget (except the root) has a parent, and can have children.</p>
<pre><code>Window
└── Container
    ├── Label
    ├── Button
    └── Container
        ├── TextEdit
        └── Button
</code></pre>
<p>This hierarchy determines:</p>
<ul>
<li><strong>Rendering order</strong>: Parents paint before children</li>
<li><strong>Event propagation</strong>: Events bubble up from children to parents</li>
<li><strong>Lifetime management</strong>: When a parent is destroyed, its children are too</li>
</ul>
<h2 id="widget-lifecycle"><a class="header" href="#widget-lifecycle">Widget Lifecycle</a></h2>
<ol>
<li><strong>Creation</strong>: <code>Widget::new()</code> creates the widget</li>
<li><strong>Configuration</strong>: Set properties, connect signals</li>
<li><strong>Layout</strong>: Widget is added to a layout or parent</li>
<li><strong>Showing</strong>: <code>show()</code> makes it visible</li>
<li><strong>Running</strong>: Widget responds to events and repaints</li>
<li><strong>Destruction</strong>: Widget goes out of scope or is explicitly removed</li>
</ol>
<h2 id="signals-and-slots-1"><a class="header" href="#signals-and-slots-1">Signals and Slots</a></h2>
<p>Signals are a type-safe way to connect events to handlers.</p>
<h3 id="emitting-signals"><a class="header" href="#emitting-signals">Emitting Signals</a></h3>
<p>Widgets define signals for events they can produce:</p>
<pre><code class="language-rust ignore">// Button has a clicked signal
button.clicked().connect(|_| {
    println!("Clicked!");
});</code></pre>
<h3 id="signal-parameters"><a class="header" href="#signal-parameters">Signal Parameters</a></h3>
<p>Signals can carry data:</p>
<pre><code class="language-rust ignore">// TextEdit emits the new text when changed
text_edit.text_changed().connect(|new_text: &amp;String| {
    println!("Text is now: {}", new_text);
});</code></pre>
<h3 id="connection-types"><a class="header" href="#connection-types">Connection Types</a></h3>
<p>By default, connections are automatic—direct if on the same thread, queued if cross-thread:</p>
<pre><code class="language-rust ignore">// Explicit connection type
button.clicked().connect_with_type(
    |_| { /* handler */ },
    ConnectionType::Queued,
);</code></pre>
<h2 id="layouts-1"><a class="header" href="#layouts-1">Layouts</a></h2>
<p>Layouts automatically position and size child widgets.</p>
<h3 id="hboxlayout-and-vboxlayout"><a class="header" href="#hboxlayout-and-vboxlayout">HBoxLayout and VBoxLayout</a></h3>
<p>Arrange widgets in a row or column:</p>
<pre><code class="language-rust ignore">let mut hbox = HBoxLayout::new();
hbox.add_widget(button1);
hbox.add_spacing(10);
hbox.add_widget(button2);
hbox.add_stretch(1); // Pushes remaining widgets to the right
hbox.add_widget(button3);</code></pre>
<h3 id="gridlayout"><a class="header" href="#gridlayout">GridLayout</a></h3>
<p>Arrange widgets in a grid:</p>
<pre><code class="language-rust ignore">let mut grid = GridLayout::new();
grid.add_widget(widget, row, column);
grid.add_widget_with_span(wide_widget, row, column, row_span, col_span);</code></pre>
<h3 id="size-policies"><a class="header" href="#size-policies">Size Policies</a></h3>
<p>Control how widgets grow and shrink:</p>
<pre><code class="language-rust ignore">// Fixed size - won't grow or shrink
widget.set_size_policy(SizePolicy::Fixed, SizePolicy::Fixed);

// Expanding - actively wants more space
widget.set_size_policy(SizePolicy::Expanding, SizePolicy::Preferred);</code></pre>
<h2 id="styling"><a class="header" href="#styling">Styling</a></h2>
<p>Widgets can be styled with CSS-like syntax:</p>
<pre><code class="language-rust ignore">// Inline style
button.set_style("background-color: #3498db; color: white;");

// From stylesheet
app.set_stylesheet(r#"
    Button {
        background-color: #3498db;
        color: white;
        padding: 8px 16px;
        border-radius: 4px;
    }

    Button:hover {
        background-color: #2980b9;
    }
"#)?;</code></pre>
<h2 id="coordinate-systems"><a class="header" href="#coordinate-systems">Coordinate Systems</a></h2>
<p>Widgets use several coordinate systems:</p>
<ul>
<li><strong>Local</strong>: Origin at widget’s top-left (0, 0)</li>
<li><strong>Parent</strong>: Relative to parent widget</li>
<li><strong>Window</strong>: Relative to window’s top-left</li>
<li><strong>Global</strong>: Screen coordinates</li>
</ul>
<p>Convert between them:</p>
<pre><code class="language-rust ignore">let parent_pos = widget.map_to_parent(local_pos);
let window_pos = widget.map_to_window(local_pos);
let global_pos = widget.map_to_global(local_pos);</code></pre>
<h2 id="event-handling"><a class="header" href="#event-handling">Event Handling</a></h2>
<p>Widgets receive events through the <code>event()</code> method:</p>
<pre><code class="language-rust ignore">impl Widget for MyWidget {
    fn event(&amp;mut self, event: &amp;mut WidgetEvent) -&gt; bool {
        match event {
            WidgetEvent::MousePress(e) =&gt; {
                println!("Clicked at {:?}", e.position());
                event.accept();
                true // Event was handled
            }
            WidgetEvent::KeyPress(e) =&gt; {
                if e.key() == Key::Enter {
                    self.submit();
                    event.accept();
                    true
                } else {
                    false // Let parent handle it
                }
            }
            _ =&gt; false,
        }
    }
}</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that you understand the basics, explore the detailed guides:</p>
<ul>
<li><a href="#widgets-guide">Widgets Guide</a> - Deep dive into the widget system</li>
<li><a href="#layouts-guide">Layouts Guide</a> - Master layout management</li>
<li><a href="#signals-and-slots-guide">Signals Guide</a> - Advanced signal patterns</li>
<li><a href="#styling-guide">Styling Guide</a> - CSS-like styling in depth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h1>
<p>This guide explains the high-level architecture of Horizon Lattice.</p>
<h2 id="system-overview"><a class="header" href="#system-overview">System Overview</a></h2>
<p>Horizon Lattice is organized into several crates:</p>
<pre><code>horizon-lattice          # Main crate (re-exports everything)
├── horizon-lattice-core     # Event loop, signals, properties, objects
├── horizon-lattice-render   # GPU rendering with wgpu
├── horizon-lattice-style    # CSS-like styling system
├── horizon-lattice-macros   # Procedural macros
├── horizon-lattice-multimedia  # Audio/video (optional)
└── horizon-lattice-net      # Networking (optional)
</code></pre>
<h2 id="core-components"><a class="header" href="#core-components">Core Components</a></h2>
<h3 id="application-and-event-loop"><a class="header" href="#application-and-event-loop">Application and Event Loop</a></h3>
<p>The <code>Application</code> singleton manages the main event loop. It:</p>
<ul>
<li>Processes platform events (window, input)</li>
<li>Dispatches signals</li>
<li>Schedules timers and async tasks</li>
<li>Coordinates repainting</li>
</ul>
<h3 id="object-system"><a class="header" href="#object-system">Object System</a></h3>
<p>All widgets inherit from <code>Object</code>, providing:</p>
<ul>
<li>Unique object IDs</li>
<li>Parent-child relationships</li>
<li>Dynamic properties</li>
<li>Thread affinity tracking</li>
</ul>
<h3 id="widget-system"><a class="header" href="#widget-system">Widget System</a></h3>
<p>The widget system provides:</p>
<ul>
<li>Base <code>Widget</code> trait with lifecycle methods</li>
<li><code>WidgetBase</code> for common functionality</li>
<li>Event dispatch and propagation</li>
<li>Focus management</li>
<li>Coordinate mapping</li>
</ul>
<h3 id="rendering"><a class="header" href="#rendering">Rendering</a></h3>
<p>The rendering system uses wgpu for GPU-accelerated 2D graphics:</p>
<ul>
<li>Immediate-mode <code>Renderer</code> trait</li>
<li>Damage tracking for efficient updates</li>
<li>Layer compositing with blend modes</li>
<li>Text shaping and rendering</li>
</ul>
<h3 id="styling-1"><a class="header" href="#styling-1">Styling</a></h3>
<p>The style system provides CSS-like styling:</p>
<ul>
<li>Selector matching (type, class, id, pseudo-class)</li>
<li>Property inheritance</li>
<li>Computed style caching</li>
</ul>
<h2 id="threading-model"><a class="header" href="#threading-model">Threading Model</a></h2>
<p>Horizon Lattice follows Qt’s threading model:</p>
<ul>
<li><strong>Main thread</strong>: All UI operations must happen here</li>
<li><strong>Worker threads</strong>: Background computation via <code>ThreadPool</code></li>
<li><strong>Signal delivery</strong>: Cross-thread signals are queued to the main thread</li>
</ul>
<h2 id="design-decisions"><a class="header" href="#design-decisions">Design Decisions</a></h2>
<h3 id="why-not-trait-objects-for-widgets"><a class="header" href="#why-not-trait-objects-for-widgets">Why Not Trait Objects for Widgets?</a></h3>
<p>We use <code>dyn Widget</code> trait objects for flexibility, but store widgets in a registry with <code>Arc&lt;Mutex&lt;dyn Widget&gt;&gt;</code>. This allows:</p>
<ul>
<li>Parent-child relationships via IDs</li>
<li>Safe cross-thread signal delivery</li>
<li>Dynamic widget creation</li>
</ul>
<h3 id="why-wgpu"><a class="header" href="#why-wgpu">Why wgpu?</a></h3>
<p>wgpu provides:</p>
<ul>
<li>Cross-platform GPU access (Vulkan, Metal, DX12, WebGPU)</li>
<li>Safe Rust API</li>
<li>Excellent performance for 2D rendering</li>
</ul>
<h3 id="why-signals-instead-of-callbacks"><a class="header" href="#why-signals-instead-of-callbacks">Why Signals Instead of Callbacks?</a></h3>
<p>Signals provide:</p>
<ul>
<li>Type-safe connections at compile time</li>
<li>Automatic cross-thread marshalling</li>
<li>Multiple connections to a single signal</li>
<li>Clean disconnection via <code>ConnectionId</code></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rendering-and-graphics"><a class="header" href="#rendering-and-graphics">Rendering and Graphics</a></h1>
<p>This guide covers the rendering primitives and graphics operations in Horizon Lattice.</p>
<h2 id="geometry-types"><a class="header" href="#geometry-types">Geometry Types</a></h2>
<h3 id="points-and-sizes"><a class="header" href="#points-and-sizes">Points and Sizes</a></h3>
<p>The fundamental types for positioning and dimensions:</p>
<pre><code class="language-rust">use horizon_lattice::render::{Point, Size};

// Creating points
let origin = Point::ZERO;
let p1 = Point::new(100.0, 50.0);
let p2: Point = (200.0, 100.0).into();

// Point arithmetic
let offset = Point::new(10.0, 5.0);
let moved = Point::new(p1.x + offset.x, p1.y + offset.y);

// Creating sizes
let size = Size::new(800.0, 600.0);
let empty = Size::ZERO;

// Check if empty
assert!(empty.is_empty());
assert!(!size.is_empty());

// From integer dimensions
let from_u32: Size = Size::from((1920u32, 1080u32));</code></pre>
<h3 id="rectangles"><a class="header" href="#rectangles">Rectangles</a></h3>
<p>Rectangles define regions for layout and drawing:</p>
<pre><code class="language-rust">use horizon_lattice::render::{Rect, Point, Size};

// Create from origin and size
let rect = Rect::new(10.0, 20.0, 200.0, 100.0);

// Create from points
let from_points = Rect::from_points(
    Point::new(10.0, 20.0),
    Point::new(210.0, 120.0),
);

// Access properties
assert_eq!(rect.x, 10.0);
assert_eq!(rect.y, 20.0);
assert_eq!(rect.width, 200.0);
assert_eq!(rect.height, 100.0);

// Corner accessors
let top_left = rect.origin();
let bottom_right = rect.bottom_right();
let center = rect.center();

// Point containment
let point = Point::new(50.0, 50.0);
assert!(rect.contains(point));

// Rectangle operations
let other = Rect::new(100.0, 50.0, 200.0, 100.0);
if let Some(intersection) = rect.intersection(&amp;other) {
    println!("Overlapping area: {:?}", intersection);
}

let bounding = rect.union(&amp;other);

// Inflate/deflate (grow or shrink)
let padded = rect.inflate(10.0, 10.0);
let inset = rect.deflate(5.0, 5.0);

// Offset (move)
let moved = rect.offset(50.0, 25.0);</code></pre>
<h3 id="rounded-rectangles"><a class="header" href="#rounded-rectangles">Rounded Rectangles</a></h3>
<p>For drawing rectangles with rounded corners:</p>
<pre><code class="language-rust">use horizon_lattice::render::{Rect, RoundedRect, CornerRadii};

let rect = Rect::new(0.0, 0.0, 200.0, 100.0);

// Uniform corner radius
let uniform = RoundedRect::new(rect, CornerRadii::uniform(8.0));

// Per-corner radii (top-left, top-right, bottom-right, bottom-left)
let varied = RoundedRect::with_radii(
    rect,
    10.0,  // top-left
    10.0,  // top-right
    0.0,   // bottom-right (square)
    0.0,   // bottom-left (square)
);

// Check if it's actually rounded
assert!(!uniform.is_rect());

// Access the underlying rect
let bounds = uniform.rect();</code></pre>
<h2 id="colors"><a class="header" href="#colors">Colors</a></h2>
<h3 id="creating-colors"><a class="header" href="#creating-colors">Creating Colors</a></h3>
<p>Multiple ways to create colors:</p>
<pre><code class="language-rust">use horizon_lattice::render::Color;

// From RGB (0.0-1.0 range)
let red = Color::from_rgb(1.0, 0.0, 0.0);

// From RGBA with alpha
let semi_transparent = Color::from_rgba(1.0, 0.0, 0.0, 0.5);

// From 8-bit RGB values (0-255)
let blue = Color::from_rgb8(0, 0, 255);
let green_alpha = Color::from_rgba8(0, 255, 0, 128);

// From hex string
let purple = Color::from_hex("#8B5CF6").unwrap();
let with_alpha = Color::from_hex("#8B5CF680").unwrap(); // 50% alpha

// From HSV (hue 0-360, saturation/value 0-1)
let orange = Color::from_hsv(30.0, 1.0, 1.0);

// Predefined constants
let white = Color::WHITE;
let black = Color::BLACK;
let transparent = Color::TRANSPARENT;</code></pre>
<h3 id="color-operations"><a class="header" href="#color-operations">Color Operations</a></h3>
<pre><code class="language-rust">use horizon_lattice::render::Color;

let color = Color::from_rgb(0.2, 0.4, 0.8);

// Modify alpha
let faded = color.with_alpha(0.5);

// Interpolate between colors
let start = Color::RED;
let end = Color::BLUE;
let midpoint = start.lerp(&amp;end, 0.5); // Purple-ish

// Convert to different formats
let [r, g, b, a] = color.to_array();
let (r8, g8, b8, a8) = color.to_rgba8();
let hex = color.to_hex(); // "#3366CC"

// Convert to HSV
let (h, s, v) = color.to_hsv();</code></pre>
<h2 id="paths"><a class="header" href="#paths">Paths</a></h2>
<p>Paths define shapes for filling and stroking.</p>
<h3 id="building-paths-manually"><a class="header" href="#building-paths-manually">Building Paths Manually</a></h3>
<pre><code class="language-rust">use horizon_lattice::render::{Path, Point};

let mut path = Path::new();

// Move to starting point
path.move_to(Point::new(0.0, 0.0));

// Draw lines
path.line_to(Point::new(100.0, 0.0));
path.line_to(Point::new(100.0, 100.0));
path.line_to(Point::new(0.0, 100.0));

// Close the path (connects back to start)
path.close();

// Get bounding box
let bounds = path.bounds();</code></pre>
<h3 id="path-factory-methods"><a class="header" href="#path-factory-methods">Path Factory Methods</a></h3>
<p>Convenient methods for common shapes:</p>
<pre><code class="language-rust">use horizon_lattice::render::{Path, Rect, Point};

// Rectangle
let rect_path = Path::rect(Rect::new(0.0, 0.0, 100.0, 50.0));

// Rounded rectangle
let rounded = Path::rounded_rect(
    Rect::new(0.0, 0.0, 100.0, 50.0),
    8.0, // corner radius
);

// Circle (center point and radius)
let circle = Path::circle(Point::new(50.0, 50.0), 25.0);

// Ellipse
let ellipse = Path::ellipse(
    Point::new(50.0, 50.0), // center
    40.0,                    // x radius
    25.0,                    // y radius
);

// Line segment
let line = Path::line(
    Point::new(0.0, 0.0),
    Point::new(100.0, 100.0),
);

// Polygon from points
let triangle = Path::polygon(&amp;[
    Point::new(50.0, 0.0),
    Point::new(100.0, 100.0),
    Point::new(0.0, 100.0),
]);

// Star shape
let star = Path::star(
    Point::new(50.0, 50.0), // center
    5,                       // points
    40.0,                    // outer radius
    20.0,                    // inner radius
);</code></pre>
<h3 id="bezier-curves"><a class="header" href="#bezier-curves">Bezier Curves</a></h3>
<pre><code class="language-rust">use horizon_lattice::render::{Path, Point};

let mut path = Path::new();
path.move_to(Point::new(0.0, 100.0));

// Quadratic bezier (one control point)
path.quad_to(
    Point::new(50.0, 0.0),   // control point
    Point::new(100.0, 100.0), // end point
);

// Cubic bezier (two control points)
path.move_to(Point::new(0.0, 50.0));
path.cubic_to(
    Point::new(25.0, 0.0),   // control point 1
    Point::new(75.0, 100.0), // control point 2
    Point::new(100.0, 50.0), // end point
);</code></pre>
<h2 id="transforms"><a class="header" href="#transforms">Transforms</a></h2>
<h3 id="2d-transforms"><a class="header" href="#2d-transforms">2D Transforms</a></h3>
<p>Transform matrices for rotating, scaling, and translating:</p>
<pre><code class="language-rust">use horizon_lattice::render::{Transform2D, Point};

// Identity (no transformation)
let identity = Transform2D::identity();

// Translation
let translate = Transform2D::translation(100.0, 50.0);

// Scaling
let scale = Transform2D::scale(2.0, 2.0); // 2x size

// Rotation (in radians)
use std::f32::consts::PI;
let rotate = Transform2D::rotation(PI / 4.0); // 45 degrees

// Composing transforms (order matters!)
// This scales first, then rotates, then translates
let combined = Transform2D::identity()
    .then_scale(2.0, 2.0)
    .then_rotate(PI / 4.0)
    .then_translate(100.0, 50.0);

// Transform a point
let point = Point::new(10.0, 20.0);
let transformed = combined.transform_point(point);

// Inverse transform
if let Some(inverse) = combined.inverse() {
    let back = inverse.transform_point(transformed);
    // back ≈ point
}

// Rotation around a specific point
let pivot = Point::new(50.0, 50.0);
let rotate_around = Transform2D::identity()
    .then_translate(-pivot.x, -pivot.y)
    .then_rotate(PI / 2.0)
    .then_translate(pivot.x, pivot.y);</code></pre>
<h3 id="transform-stack"><a class="header" href="#transform-stack">Transform Stack</a></h3>
<p>For hierarchical transforms (like nested widgets):</p>
<pre><code class="language-rust">use horizon_lattice::render::{TransformStack, Point};

let mut stack = TransformStack::new();

// Save current state
stack.save();

// Apply transforms
stack.translate(100.0, 50.0);
stack.scale(2.0, 2.0);

// Transform points
let local = Point::new(10.0, 10.0);
let world = stack.transform_point(local);

// Restore previous state
stack.restore();

// Point transforms back to original coordinate space
let restored = stack.transform_point(local);
assert_eq!(restored, local);</code></pre>
<h2 id="painting"><a class="header" href="#painting">Painting</a></h2>
<h3 id="solid-colors-and-gradients"><a class="header" href="#solid-colors-and-gradients">Solid Colors and Gradients</a></h3>
<pre><code class="language-rust">use horizon_lattice::render::{Paint, Color, GradientStop, Point};

// Solid color fill
let solid = Paint::solid(Color::from_rgb(0.2, 0.4, 0.8));

// Linear gradient
let linear = Paint::linear_gradient(
    Point::new(0.0, 0.0),   // start point
    Point::new(100.0, 0.0), // end point
    vec![
        GradientStop::new(0.0, Color::RED),
        GradientStop::new(0.5, Color::WHITE),
        GradientStop::new(1.0, Color::BLUE),
    ],
);

// Radial gradient
let radial = Paint::radial_gradient(
    Point::new(50.0, 50.0), // center
    50.0,                    // radius
    vec![
        GradientStop::new(0.0, Color::WHITE),
        GradientStop::new(1.0, Color::from_rgba(0.0, 0.0, 0.0, 0.0)),
    ],
);

// Radial gradient with offset focus
let spotlight = Paint::radial_gradient_with_focus(
    Point::new(50.0, 50.0), // center
    50.0,                    // radius
    Point::new(30.0, 30.0), // focus point (off-center)
    vec![
        GradientStop::new(0.0, Color::WHITE),
        GradientStop::new(1.0, Color::BLACK),
    ],
);</code></pre>
<h3 id="strokes"><a class="header" href="#strokes">Strokes</a></h3>
<p>Configure how paths are outlined:</p>
<pre><code class="language-rust">use horizon_lattice::render::{Stroke, Color, LineCap, LineJoin, DashPattern};

// Basic stroke
let basic = Stroke::new(Color::BLACK, 2.0);

// With line cap style
let rounded_caps = Stroke::new(Color::BLACK, 10.0)
    .with_cap(LineCap::Round);

// Line cap options:
// - LineCap::Butt   - flat, ends at exact endpoint
// - LineCap::Round  - semicircle extending past endpoint
// - LineCap::Square - square extending past endpoint

// With line join style
let rounded_corners = Stroke::new(Color::BLACK, 4.0)
    .with_join(LineJoin::Round);

// Line join options:
// - LineJoin::Miter - sharp corners (default)
// - LineJoin::Round - rounded corners
// - LineJoin::Bevel - flat corners

// Miter limit (prevents very sharp corners from extending too far)
let limited = Stroke::new(Color::BLACK, 4.0)
    .with_join(LineJoin::Miter)
    .with_miter_limit(2.0);

// Dashed lines
let dashed = Stroke::new(Color::BLACK, 2.0)
    .with_dash(DashPattern::simple(5.0, 5.0));

// Complex dash pattern: long, gap, short, gap
let complex_dash = Stroke::new(Color::BLACK, 2.0)
    .with_dash(DashPattern::new(vec![10.0, 3.0, 3.0, 3.0], 0.0));

// Animated dash (offset shifts the pattern)
let animated = Stroke::new(Color::BLACK, 2.0)
    .with_dash(DashPattern::new(vec![5.0, 5.0], 2.5));</code></pre>
<h2 id="blend-modes"><a class="header" href="#blend-modes">Blend Modes</a></h2>
<p>Control how colors combine when drawing overlapping content:</p>
<pre><code class="language-rust">use horizon_lattice::render::BlendMode;

// Standard alpha blending (default)
let normal = BlendMode::Normal;

// Darkening modes
let multiply = BlendMode::Multiply; // Darken by multiplying
let darken = BlendMode::Darken;     // Take minimum

// Lightening modes
let screen = BlendMode::Screen;   // Lighten (opposite of multiply)
let lighten = BlendMode::Lighten; // Take maximum
let add = BlendMode::Add;         // Additive (glow effects)

// Porter-Duff compositing
let source = BlendMode::Source;           // Replace destination
let dest_out = BlendMode::DestinationOut; // Cut out shape
let xor = BlendMode::Xor;                 // Either but not both</code></pre>
<h2 id="fill-rules"><a class="header" href="#fill-rules">Fill Rules</a></h2>
<p>Determine what’s “inside” a path with overlapping regions:</p>
<pre><code class="language-rust">use horizon_lattice::render::FillRule;

// NonZero (default) - considers winding direction
// A point is inside if the winding number is non-zero
let non_zero = FillRule::NonZero;

// EvenOdd - creates checkerboard pattern for overlaps
// A point is inside if it crosses an odd number of edges
let even_odd = FillRule::EvenOdd;</code></pre>
<p>The difference matters for paths with overlapping regions:</p>
<ul>
<li><strong>NonZero</strong>: Inner shapes are filled if they wind the same direction as outer</li>
<li><strong>EvenOdd</strong>: Overlapping regions alternate between filled and unfilled</li>
</ul>
<h2 id="images"><a class="header" href="#images">Images</a></h2>
<h3 id="loading-and-using-images"><a class="header" href="#loading-and-using-images">Loading and Using Images</a></h3>
<pre><code class="language-rust no_run">use horizon_lattice::render::{ImageLoader, ImageScaleMode};

// Create an image loader
let loader = ImageLoader::new();

// Load an image (async in real usage)
// let image = loader.load("path/to/image.png").await?;

// Scale modes for drawing
let mode = ImageScaleMode::Fit;        // Fit within bounds, preserve aspect
let mode = ImageScaleMode::Fill;       // Fill bounds, may crop
let mode = ImageScaleMode::Stretch;    // Stretch to fill, ignores aspect
let mode = ImageScaleMode::Tile;       // Repeat to fill
let mode = ImageScaleMode::Center;     // Center at original size
let mode = ImageScaleMode::None;       // Draw at original size from top-left</code></pre>
<h3 id="nine-patch-images"><a class="header" href="#nine-patch-images">Nine-Patch Images</a></h3>
<p>For scalable UI elements like buttons and panels:</p>
<pre><code class="language-rust no_run">use horizon_lattice::render::{NinePatch, Rect};

// Nine-patch divides an image into 9 regions:
// - 4 corners (don't scale)
// - 4 edges (scale in one direction)
// - 1 center (scales in both directions)

// Create with uniform borders
// let nine_patch = NinePatch::uniform(image, 10.0);

// Create with different border sizes
// let nine_patch = NinePatch::new(
//     image,
//     10.0,  // left border
//     10.0,  // right border
//     8.0,   // top border
//     12.0,  // bottom border
// );

// Get minimum size (sum of borders)
// let min_size = nine_patch.min_size();

// Calculate patch regions for rendering
// let dest = Rect::new(0.0, 0.0, 200.0, 60.0);
// let patches = nine_patch.calculate_patches(dest);</code></pre>
<h2 id="box-shadows"><a class="header" href="#box-shadows">Box Shadows</a></h2>
<p>For drop shadows and glow effects:</p>
<pre><code class="language-rust">use horizon_lattice::render::{BoxShadow, Color, Rect};

// Basic drop shadow
let shadow = BoxShadow {
    offset_x: 2.0,
    offset_y: 4.0,
    blur_radius: 8.0,
    spread_radius: 0.0,
    color: Color::from_rgba(0.0, 0.0, 0.0, 0.3),
    inset: false,
};

// Glow effect (no offset, larger blur)
let glow = BoxShadow {
    offset_x: 0.0,
    offset_y: 0.0,
    blur_radius: 20.0,
    spread_radius: 5.0,
    color: Color::from_rgba(0.3, 0.5, 1.0, 0.6),
    inset: false,
};

// Inset shadow (inner shadow)
let inset = BoxShadow {
    offset_x: 0.0,
    offset_y: 2.0,
    blur_radius: 4.0,
    spread_radius: 0.0,
    color: Color::from_rgba(0.0, 0.0, 0.0, 0.2),
    inset: true,
};

// Calculate the bounding rect needed to render the shadow
let widget_rect = Rect::new(10.0, 10.0, 100.0, 50.0);
let shadow_bounds = shadow.bounds(widget_rect);</code></pre>
<h2 id="text-rendering"><a class="header" href="#text-rendering">Text Rendering</a></h2>
<h3 id="font-configuration"><a class="header" href="#font-configuration">Font Configuration</a></h3>
<pre><code class="language-rust">use horizon_lattice::render::text::{Font, FontBuilder, FontWeight, FontStyle};

// Simple font
let font = Font::new("Helvetica", 14.0);

// Using the builder for more options
let custom = FontBuilder::new()
    .family("Inter")
    .fallback("Helvetica")
    .fallback("Arial")
    .fallback("sans-serif")
    .size(16.0)
    .weight(FontWeight::MEDIUM)
    .style(FontStyle::Normal)
    .letter_spacing(0.5)
    .build();

// Enable OpenType features
let with_features = FontBuilder::new()
    .family("Fira Code")
    .size(14.0)
    .feature("liga", 1) // Enable ligatures
    .feature("calt", 1) // Enable contextual alternates
    .build();</code></pre>
<h3 id="text-layout"><a class="header" href="#text-layout">Text Layout</a></h3>
<pre><code class="language-rust">use horizon_lattice::render::text::{
    TextLayoutOptions, HorizontalAlign, VerticalAlign, WrapMode
};

// Basic layout options
let options = TextLayoutOptions::default()
    .with_max_width(Some(300.0))
    .with_wrap_mode(WrapMode::Word);

// Alignment options
let centered = TextLayoutOptions::default()
    .with_horizontal_align(HorizontalAlign::Center)
    .with_vertical_align(VerticalAlign::Middle);

// Wrap modes:
// - WrapMode::None      - No wrapping, single line
// - WrapMode::Char      - Wrap at any character
// - WrapMode::Word      - Wrap at word boundaries
// - WrapMode::WordChar  - Try word, fall back to char

// Line spacing
let spaced = TextLayoutOptions::default()
    .with_line_height(1.5); // 150% line height</code></pre>
<h3 id="rich-text"><a class="header" href="#rich-text">Rich Text</a></h3>
<pre><code class="language-rust">use horizon_lattice::render::text::{TextSpan, TextDecoration};
use horizon_lattice::render::Color;

// Create styled text spans
let spans = vec![
    TextSpan::new("Hello ")
        .with_size(16.0)
        .with_color(Color::BLACK),
    TextSpan::new("World")
        .with_size(16.0)
        .with_color(Color::BLUE)
        .with_weight(700)
        .with_decoration(TextDecoration::Underline),
    TextSpan::new("!")
        .with_size(20.0)
        .with_color(Color::RED),
];</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<ul>
<li>See the <a href="#widgets-guide">Widget Guide</a> for how rendering integrates with widgets</li>
<li>See the <a href="#styling-guide">Styling Guide</a> for CSS-like styling of widgets</li>
<li>Check the <a href="https://docs.rs/horizon-lattice">API Documentation</a> for complete details</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="widgets-guide"><a class="header" href="#widgets-guide">Widgets Guide</a></h1>
<p>This guide covers the widget system in depth.</p>
<h2 id="widget-trait"><a class="header" href="#widget-trait">Widget Trait</a></h2>
<p>Every widget implements the <code>Widget</code> trait:</p>
<pre><code class="language-rust no_run">use horizon_lattice::widget::{Widget, WidgetBase, PaintContext};
use horizon_lattice::widget::SizeHint;
use horizon_lattice::widget::events::WidgetEvent;
use horizon_lattice_core::{Object, ObjectId};

pub trait WidgetDefinition {
    fn widget_base(&amp;self) -&gt; &amp;WidgetBase;
    fn widget_base_mut(&amp;mut self) -&gt; &amp;mut WidgetBase;

    fn size_hint(&amp;self) -&gt; SizeHint { SizeHint::default() }
    fn paint(&amp;self, ctx: &amp;mut PaintContext&lt;'_&gt;) {}
    fn event(&amp;mut self, event: &amp;mut WidgetEvent) -&gt; bool { false }
}</code></pre>
<h2 id="size-hints"><a class="header" href="#size-hints">Size Hints</a></h2>
<p>Size hints tell layouts what size a widget prefers:</p>
<pre><code class="language-rust">use horizon_lattice::widget::SizeHint;
use horizon_lattice::render::Size;

// Create a simple size hint with preferred dimensions
let hint = SizeHint::from_dimensions(100.0, 30.0);
assert_eq!(hint.preferred, Size::new(100.0, 30.0));

// Add minimum and maximum constraints
let constrained = SizeHint::from_dimensions(100.0, 30.0)
    .with_minimum_dimensions(50.0, 20.0)
    .with_maximum_dimensions(200.0, 50.0);

assert_eq!(constrained.minimum, Some(Size::new(50.0, 20.0)));
assert_eq!(constrained.maximum, Some(Size::new(200.0, 50.0)));

// Create a fixed size (cannot grow or shrink)
let fixed = SizeHint::fixed(Size::new(100.0, 100.0));
assert!(fixed.is_fixed());</code></pre>
<h2 id="size-policies-1"><a class="header" href="#size-policies-1">Size Policies</a></h2>
<p>Size policies control how widgets grow and shrink:</p>
<pre><code class="language-rust">use horizon_lattice::widget::{SizePolicy, SizePolicyPair};

// Fixed - cannot resize
let fixed = SizePolicyPair::fixed();
assert!(!fixed.horizontal.can_grow());
assert!(!fixed.horizontal.can_shrink());

// Preferred - can grow or shrink, prefers hint size
let preferred = SizePolicyPair::preferred();
assert!(preferred.horizontal.can_grow());
assert!(preferred.horizontal.can_shrink());

// Expanding - actively wants more space
let expanding = SizePolicyPair::expanding();
assert!(expanding.horizontal.wants_to_grow());

// Custom policy with stretch factor
let stretched = SizePolicyPair::new(SizePolicy::Expanding, SizePolicy::Fixed)
    .with_horizontal_stretch(2);  // Gets 2x extra space compared to stretch=1

assert_eq!(stretched.horizontal_stretch, 2);</code></pre>
<h2 id="widget-lifecycle-1"><a class="header" href="#widget-lifecycle-1">Widget Lifecycle</a></h2>
<ol>
<li><code>new()</code> - Create widget with WidgetBase</li>
<li>Configure properties and connect signals</li>
<li>Add to parent/layout</li>
<li><code>show()</code> is called (inherited from parent)</li>
<li><code>paint()</code> called when visible</li>
<li><code>event()</code> called for input</li>
<li>Widget dropped when parent is destroyed</li>
</ol>
<h2 id="creating-custom-widgets"><a class="header" href="#creating-custom-widgets">Creating Custom Widgets</a></h2>
<p>Here’s a conceptual example of creating a custom progress bar widget:</p>
<pre><code class="language-rust no_run">use horizon_lattice::widget::{Widget, WidgetBase, PaintContext};
use horizon_lattice::widget::SizeHint;
use horizon_lattice::widget::events::WidgetEvent;
use horizon_lattice::render::{Color, Rect};
use horizon_lattice_core::{Object, ObjectId};

struct ProgressBar {
    base: WidgetBase,
    value: f32,      // 0.0 to 1.0
    color: Color,
}

impl ProgressBar {
    pub fn new() -&gt; Self {
        Self {
            base: WidgetBase::new::&lt;Self&gt;(),
            value: 0.0,
            color: Color::from_rgb8(52, 152, 219),
        }
    }

    pub fn set_value(&amp;mut self, value: f32) {
        self.value = value.clamp(0.0, 1.0);
        self.base.update(); // Request repaint
    }

    pub fn value(&amp;self) -&gt; f32 {
        self.value
    }
}

impl Object for ProgressBar {
    fn object_id(&amp;self) -&gt; ObjectId {
        self.base.object_id()
    }
}

impl Widget for ProgressBar {
    fn widget_base(&amp;self) -&gt; &amp;WidgetBase { &amp;self.base }
    fn widget_base_mut(&amp;mut self) -&gt; &amp;mut WidgetBase { &amp;mut self.base }

    fn size_hint(&amp;self) -&gt; SizeHint {
        SizeHint::from_dimensions(200.0, 20.0)
            .with_minimum_dimensions(50.0, 10.0)
    }

    fn paint(&amp;self, ctx: &amp;mut PaintContext&lt;'_&gt;) {
        let rect = ctx.rect();

        // Background
        ctx.renderer().fill_rect(rect, Color::from_rgb8(200, 200, 200));

        // Progress fill
        let fill_width = rect.width() * self.value;
        let fill_rect = Rect::new(0.0, 0.0, fill_width, rect.height());
        ctx.renderer().fill_rect(fill_rect, self.color);
    }
}</code></pre>
<h2 id="size-hint-examples"><a class="header" href="#size-hint-examples">Size Hint Examples</a></h2>
<p>Different widgets have different size hint patterns:</p>
<pre><code class="language-rust">use horizon_lattice::widget::SizeHint;
use horizon_lattice::render::Size;

// Label - prefers text size, can't shrink below it
fn label_size_hint(text_width: f32, text_height: f32) -&gt; SizeHint {
    SizeHint::from_dimensions(text_width, text_height)
        .with_minimum_dimensions(text_width, text_height)
}

// Button - has padding around content
fn button_size_hint(content_width: f32, content_height: f32) -&gt; SizeHint {
    let padding = 16.0;
    SizeHint::from_dimensions(content_width + padding, content_height + padding)
        .with_minimum_dimensions(60.0, 30.0)
}

// Text input - can expand horizontally
fn text_input_size_hint() -&gt; SizeHint {
    SizeHint::from_dimensions(150.0, 30.0)
        .with_minimum_dimensions(50.0, 30.0)
}</code></pre>
<h2 id="geometry-methods"><a class="header" href="#geometry-methods">Geometry Methods</a></h2>
<p>Widgets provide methods to query and set their geometry:</p>
<pre><code class="language-rust">use horizon_lattice::render::{Point, Rect, Size};

// Simulating widget geometry operations
let geometry = Rect::new(10.0, 20.0, 100.0, 50.0);

// Position (relative to parent)
let pos = geometry.origin;
assert_eq!(pos, Point::new(10.0, 20.0));

// Size
let size = geometry.size;
assert_eq!(size, Size::new(100.0, 50.0));

// Local rect (always at origin 0,0)
let local_rect = Rect::new(0.0, 0.0, size.width, size.height);
assert_eq!(local_rect.origin, Point::new(0.0, 0.0));

// Check if a point is inside the local rect
let point = Point::new(50.0, 25.0);
assert!(local_rect.contains(point));

let outside = Point::new(150.0, 25.0);
assert!(!local_rect.contains(outside));</code></pre>
<h2 id="coordinate-mapping"><a class="header" href="#coordinate-mapping">Coordinate Mapping</a></h2>
<p>Map points between widget-local and parent coordinate systems:</p>
<pre><code class="language-rust">use horizon_lattice::render::Point;

// Widget at position (10, 20)
let widget_pos = Point::new(10.0, 20.0);

// Point in widget-local coordinates
let local_point = Point::new(5.0, 5.0);

// Map to parent coordinates
let parent_point = Point::new(
    local_point.x + widget_pos.x,
    local_point.y + widget_pos.y,
);
assert_eq!(parent_point, Point::new(15.0, 25.0));

// Map from parent back to local
let back_to_local = Point::new(
    parent_point.x - widget_pos.x,
    parent_point.y - widget_pos.y,
);
assert_eq!(back_to_local, local_point);</code></pre>
<h2 id="visibility-and-enabled-state"><a class="header" href="#visibility-and-enabled-state">Visibility and Enabled State</a></h2>
<p>Control widget visibility and interaction:</p>
<pre><code class="language-rust">// Visibility concepts
let mut visible = true;
let mut enabled = true;

// Hide a widget
visible = false;

// Disable a widget (grayed out, can't interact)
enabled = false;

// Check effective state (considering parent hierarchy)
// If parent is hidden, child is effectively hidden too
fn is_effectively_visible(self_visible: bool, parent_visible: bool) -&gt; bool {
    self_visible &amp;&amp; parent_visible
}

assert!(!is_effectively_visible(true, false));  // Parent hidden
assert!(!is_effectively_visible(false, true));  // Self hidden
assert!(is_effectively_visible(true, true));    // Both visible</code></pre>
<h2 id="focus-policy"><a class="header" href="#focus-policy">Focus Policy</a></h2>
<p>Control how widgets receive keyboard focus:</p>
<pre><code class="language-rust">use horizon_lattice::widget::FocusPolicy;

// NoFocus - widget cannot receive focus (e.g., labels)
let no_focus = FocusPolicy::NoFocus;

// TabFocus - focus via Tab key only (e.g., read-only controls)
let tab_focus = FocusPolicy::TabFocus;

// ClickFocus - focus via mouse click only
let click_focus = FocusPolicy::ClickFocus;

// StrongFocus - focus via both Tab and click (e.g., buttons, text fields)
let strong_focus = FocusPolicy::StrongFocus;</code></pre>
<h2 id="repaint-requests"><a class="header" href="#repaint-requests">Repaint Requests</a></h2>
<p>Request widget repainting when content changes:</p>
<pre><code class="language-rust">use horizon_lattice::render::Rect;

// Full repaint - entire widget needs redrawing
fn request_full_repaint(needs_repaint: &amp;mut bool) {
    *needs_repaint = true;
}

// Partial repaint - only a region needs redrawing
fn request_partial_repaint(dirty_region: &amp;mut Option&lt;Rect&gt;, new_dirty: Rect) {
    *dirty_region = Some(match dirty_region {
        Some(existing) =&gt; existing.union(&amp;new_dirty),
        None =&gt; new_dirty,
    });
}

let mut dirty = None;
request_partial_repaint(&amp;mut dirty, Rect::new(0.0, 0.0, 50.0, 50.0));
request_partial_repaint(&amp;mut dirty, Rect::new(40.0, 40.0, 50.0, 50.0));

// Dirty region is now the union of both rects
let combined = dirty.unwrap();
assert_eq!(combined.origin.x, 0.0);
assert_eq!(combined.origin.y, 0.0);</code></pre>
<h2 id="signals-and-properties"><a class="header" href="#signals-and-properties">Signals and Properties</a></h2>
<p>Widgets use signals to notify of changes:</p>
<pre><code class="language-rust">use horizon_lattice_core::{Signal, Property};

// Create signals for widget state changes
let visible_changed: Signal&lt;bool&gt; = Signal::new();
let geometry_changed: Signal&lt;(f32, f32, f32, f32)&gt; = Signal::new();

// Connect to signals
visible_changed.connect(|&amp;visible| {
    println!("Visibility changed to: {}", visible);
});

// Emit when state changes
visible_changed.emit(false);

// Properties with automatic change notification
let value: Property&lt;f32&gt; = Property::new(0.0);

// Get the current value
assert_eq!(value.get(), 0.0);

// Set returns true if value changed
assert!(value.set(0.5));
assert!(!value.set(0.5)); // Same value, returns false</code></pre>
<h2 id="built-in-widgets"><a class="header" href="#built-in-widgets">Built-in Widgets</a></h2>
<p>See the <a href="#widget-catalog">Widget Catalog</a> for all available widgets including:</p>
<ul>
<li><strong>Basic</strong>: Label, PushButton, CheckBox, RadioButton</li>
<li><strong>Input</strong>: LineEdit, TextEdit, SpinBox, Slider</li>
<li><strong>Containers</strong>: Frame, GroupBox, ScrollArea, TabWidget</li>
<li><strong>Display</strong>: ProgressBar, StatusBar</li>
<li><strong>Dialogs</strong>: MessageBox, FileDialog, ColorDialog</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="layouts-guide"><a class="header" href="#layouts-guide">Layouts Guide</a></h1>
<p>Layouts automatically arrange child widgets within a container.</p>
<h2 id="layout-algorithm"><a class="header" href="#layout-algorithm">Layout Algorithm</a></h2>
<p>Layouts use a two-pass algorithm:</p>
<ol>
<li><strong>Measure pass</strong>: Query each child’s <code>size_hint()</code> and size policy</li>
<li><strong>Arrange pass</strong>: Assign positions and sizes to children</li>
</ol>
<h2 id="content-margins"><a class="header" href="#content-margins">Content Margins</a></h2>
<p>All layouts support content margins - spacing between the layout’s content and its edges:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::ContentMargins;

// Create uniform margins (same on all sides)
let uniform = ContentMargins::uniform(10.0);
assert_eq!(uniform.left, 10.0);
assert_eq!(uniform.top, 10.0);
assert_eq!(uniform.right, 10.0);
assert_eq!(uniform.bottom, 10.0);

// Create symmetric margins (horizontal/vertical)
let symmetric = ContentMargins::symmetric(20.0, 10.0);
assert_eq!(symmetric.left, 20.0);
assert_eq!(symmetric.right, 20.0);
assert_eq!(symmetric.top, 10.0);
assert_eq!(symmetric.bottom, 10.0);

// Create custom margins
let custom = ContentMargins::new(5.0, 10.0, 15.0, 20.0);
assert_eq!(custom.horizontal(), 20.0); // left + right
assert_eq!(custom.vertical(), 30.0);   // top + bottom</code></pre>
<h2 id="layoutkind-enum"><a class="header" href="#layoutkind-enum">LayoutKind Enum</a></h2>
<p>The <code>LayoutKind</code> enum provides a unified interface for all layout types:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::LayoutKind;

// Create different layout types
let hbox = LayoutKind::horizontal();
let vbox = LayoutKind::vertical();
let grid = LayoutKind::grid();
let form = LayoutKind::form();
let stack = LayoutKind::stack();
let flow = LayoutKind::flow();
let anchor = LayoutKind::anchor();

// All layouts share a common interface
let mut layout = LayoutKind::vertical();
assert_eq!(layout.item_count(), 0);
assert!(layout.is_empty());</code></pre>
<h2 id="boxlayout-hbox-and-vbox"><a class="header" href="#boxlayout-hbox-and-vbox">BoxLayout (HBox and VBox)</a></h2>
<p>Arrange widgets horizontally or vertically:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::{BoxLayout, ContentMargins, Orientation};

// Create a horizontal layout
let mut hbox = BoxLayout::horizontal();
hbox.set_spacing(10.0);  // Space between widgets
hbox.set_content_margins(ContentMargins::uniform(8.0));  // Outer margins

assert_eq!(hbox.spacing(), 10.0);
assert_eq!(hbox.orientation(), Orientation::Horizontal);

// Create a vertical layout
let mut vbox = BoxLayout::vertical();
vbox.set_spacing(5.0);

assert_eq!(vbox.orientation(), Orientation::Vertical);</code></pre>
<h2 id="adding-items-to-layouts"><a class="header" href="#adding-items-to-layouts">Adding Items to Layouts</a></h2>
<p>Layouts can contain widgets, spacers, and nested layouts:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::{LayoutKind, LayoutItem, SpacerItem, SpacerType};
use horizon_lattice::render::Size;

let mut layout = LayoutKind::vertical();

// Add a fixed spacer (takes a specific amount of space)
let fixed_spacer = LayoutItem::Spacer(SpacerItem::fixed(Size::new(0.0, 20.0)));
layout.add_item(fixed_spacer);

// Add an expanding spacer (fills available space)
let expanding_spacer = LayoutItem::Spacer(SpacerItem::new(
    Size::ZERO,
    SpacerType::Expanding,
));
layout.add_item(expanding_spacer);

assert_eq!(layout.item_count(), 2);</code></pre>
<h2 id="gridlayout-1"><a class="header" href="#gridlayout-1">GridLayout</a></h2>
<p>Arrange widgets in rows and columns:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::GridLayout;

let mut grid = GridLayout::new();

// Set spacing between cells
grid.set_spacing(10.0);
grid.set_horizontal_spacing(15.0);  // Override horizontal only
grid.set_vertical_spacing(5.0);     // Override vertical only

// Set column stretch factors (column 1 expands more)
grid.set_column_stretch(0, 0);  // Column 0: no stretch
grid.set_column_stretch(1, 1);  // Column 1: stretch factor 1

// Set row stretch
grid.set_row_stretch(0, 0);  // Row 0: no stretch
grid.set_row_stretch(1, 2);  // Row 1: stretch factor 2

// Set minimum column width
grid.set_column_minimum_width(0, 100.0);</code></pre>
<h2 id="formlayout"><a class="header" href="#formlayout">FormLayout</a></h2>
<p>Convenient layout for label-field pairs:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::{FormLayout, RowWrapPolicy, FieldGrowthPolicy};

let mut form = FormLayout::new();

// Configure form behavior
form.set_row_wrap_policy(RowWrapPolicy::WrapLongRows);
form.set_field_growth_policy(FieldGrowthPolicy::ExpandingFieldsGrow);

// Set spacing
form.set_horizontal_spacing(10.0);
form.set_vertical_spacing(8.0);

// The form automatically aligns labels and fields
// Labels go in the left column, fields in the right</code></pre>
<h2 id="stacklayout"><a class="header" href="#stacklayout">StackLayout</a></h2>
<p>Stack widgets on top of each other (only one visible at a time):</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::{StackLayout, StackSizeMode};

let mut stack = StackLayout::new();

// Configure how the stack calculates its size
stack.set_size_mode(StackSizeMode::CurrentWidgetSize);  // Size based on current widget
// or
stack.set_size_mode(StackSizeMode::MaximumSize);  // Size based on largest widget

// Set the current index (which widget is visible)
stack.set_current_index(0);
assert_eq!(stack.current_index(), 0);</code></pre>
<h2 id="flowlayout"><a class="header" href="#flowlayout">FlowLayout</a></h2>
<p>Arrange widgets in a flowing pattern (like text wrapping):</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::FlowLayout;

let mut flow = FlowLayout::new();

// Set spacing between items
flow.set_spacing(10.0);
flow.set_horizontal_spacing(15.0);  // Between items in a row
flow.set_vertical_spacing(8.0);     // Between rows</code></pre>
<h2 id="anchorlayout"><a class="header" href="#anchorlayout">AnchorLayout</a></h2>
<p>Position widgets relative to each other or the container:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::{AnchorLayout, Anchor, AnchorLine, AnchorTarget};
use horizon_lattice_core::ObjectId;

let mut anchor = AnchorLayout::new();

// Anchors connect widget edges to targets
// For example: widget's left edge to parent's left edge plus margin
let left_anchor = Anchor {
    line: AnchorLine::Left,
    target: AnchorTarget::Parent,
    target_line: AnchorLine::Left,
    margin: 10.0,
};

// Center horizontally in parent
let center_anchor = Anchor {
    line: AnchorLine::HorizontalCenter,
    target: AnchorTarget::Parent,
    target_line: AnchorLine::HorizontalCenter,
    margin: 0.0,
};</code></pre>
<h2 id="nested-layouts"><a class="header" href="#nested-layouts">Nested Layouts</a></h2>
<p>Layouts can be nested for complex UIs:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::{LayoutKind, BoxLayout, ContentMargins};

// Main vertical layout
let mut main = LayoutKind::vertical();

// Header as a horizontal layout
let mut header = BoxLayout::horizontal();
header.set_spacing(10.0);
header.set_content_margins(ContentMargins::uniform(5.0));

// Convert to LayoutKind for nesting
let header_kind = LayoutKind::from(header);

// In a real app, you would add the header layout as an item
// to the main layout</code></pre>
<h2 id="layout-invalidation"><a class="header" href="#layout-invalidation">Layout Invalidation</a></h2>
<p>Layouts track when they need recalculation:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::LayoutKind;

let mut layout = LayoutKind::vertical();

// Check if layout needs recalculation
if layout.needs_recalculation() {
    println!("Layout needs to be recalculated");
}

// Invalidate to force recalculation
layout.invalidate();
assert!(layout.needs_recalculation());</code></pre>
<h2 id="layout-geometry"><a class="header" href="#layout-geometry">Layout Geometry</a></h2>
<p>Set and query layout geometry:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::LayoutKind;
use horizon_lattice::render::Rect;

let mut layout = LayoutKind::vertical();

// Set the layout's bounding rectangle
let rect = Rect::new(10.0, 20.0, 300.0, 400.0);
layout.set_geometry(rect);

// Query the geometry
let geom = layout.geometry();
assert_eq!(geom.origin.x, 10.0);
assert_eq!(geom.origin.y, 20.0);
assert_eq!(geom.size.width, 300.0);
assert_eq!(geom.size.height, 400.0);</code></pre>
<h2 id="custom-layout-implementation"><a class="header" href="#custom-layout-implementation">Custom Layout Implementation</a></h2>
<p>Creating a custom layout involves implementing the <code>Layout</code> trait and optionally using <code>LayoutBase</code> to handle common functionality.</p>
<h3 id="architecture-overview-1"><a class="header" href="#architecture-overview-1">Architecture Overview</a></h3>
<p>Custom layouts in Horizon Lattice follow this architecture:</p>
<ol>
<li><strong>Layout trait</strong>: Defines 21 methods for item management, size calculation, geometry, and invalidation</li>
<li><strong>LayoutBase</strong>: A helper struct that provides common functionality (item storage, margins, spacing, caching)</li>
<li><strong>LayoutItem</strong>: Enum wrapping widgets, spacers, or nested layouts</li>
<li><strong>Two-pass algorithm</strong>: Collection (size hints) followed by distribution (positioning)</li>
</ol>
<h3 id="step-by-step-creating-a-centered-layout"><a class="header" href="#step-by-step-creating-a-centered-layout">Step-by-Step: Creating a Centered Layout</a></h3>
<p>Let’s build a <code>CenteredLayout</code> that centers a single widget within its bounds.</p>
<h4 id="step-1-define-the-struct"><a class="header" href="#step-1-define-the-struct">Step 1: Define the Struct</a></h4>
<pre><code class="language-rust">use horizon_lattice::widget::layout::{Layout, LayoutBase, LayoutItem, ContentMargins};
use horizon_lattice::widget::geometry::{SizeHint, SizePolicyPair};
use horizon_lattice::widget::dispatcher::WidgetAccess;
use horizon_lattice_core::ObjectId;
use horizon_lattice_render::{Rect, Size};

/// A layout that centers its single child widget.
#[derive(Debug, Clone)]
pub struct CenteredLayout {
    /// Delegate common functionality to LayoutBase.
    base: LayoutBase,
}

impl CenteredLayout {
    /// Create a new centered layout.
    pub fn new() -&gt; Self {
        Self {
            base: LayoutBase::new(),
        }
    }
}

impl Default for CenteredLayout {
    fn default() -&gt; Self {
        Self::new()
    }
}</code></pre>
<h4 id="step-2-implement-the-layout-trait"><a class="header" href="#step-2-implement-the-layout-trait">Step 2: Implement the Layout Trait</a></h4>
<p>The <code>Layout</code> trait requires implementing methods across several categories:</p>
<p><strong>Item Management</strong> - Delegate to LayoutBase:</p>
<pre><code class="language-rust">impl Layout for CenteredLayout {
    fn add_item(&amp;mut self, item: LayoutItem) {
        // Only allow one item for centering
        if self.base.is_empty() {
            self.base.add_item(item);
        }
    }

    fn insert_item(&amp;mut self, index: usize, item: LayoutItem) {
        if self.base.is_empty() &amp;&amp; index == 0 {
            self.base.insert_item(index, item);
        }
    }

    fn remove_item(&amp;mut self, index: usize) -&gt; Option&lt;LayoutItem&gt; {
        self.base.remove_item(index)
    }

    fn remove_widget(&amp;mut self, widget: ObjectId) -&gt; bool {
        self.base.remove_widget(widget)
    }

    fn item_count(&amp;self) -&gt; usize {
        self.base.item_count()
    }

    fn item_at(&amp;self, index: usize) -&gt; Option&lt;&amp;LayoutItem&gt; {
        self.base.item_at(index)
    }

    fn item_at_mut(&amp;mut self, index: usize) -&gt; Option&lt;&amp;mut LayoutItem&gt; {
        self.base.item_at_mut(index)
    }

    fn clear(&amp;mut self) {
        self.base.clear();
    }
    // ... continued below
}</code></pre>
<p><strong>Size Hints</strong> - Calculate based on the child:</p>
<pre><code class="language-rust">impl Layout for CenteredLayout {
    // ... item management above

    fn size_hint&lt;S: WidgetAccess&gt;(&amp;self, storage: &amp;S) -&gt; SizeHint {
        // Return cached hint if available
        if let Some(cached) = self.base.cached_size_hint() {
            return cached;
        }

        // Get child's size hint (if we have a child)
        let child_hint = if let Some(item) = self.base.item_at(0) {
            self.base.get_item_size_hint(storage, item)
        } else {
            SizeHint::default()
        };

        // Add margins
        let margins = self.base.content_margins();
        SizeHint {
            preferred: Size::new(
                child_hint.preferred.width + margins.horizontal(),
                child_hint.preferred.height + margins.vertical(),
            ),
            minimum: child_hint.minimum.map(|s| Size::new(
                s.width + margins.horizontal(),
                s.height + margins.vertical(),
            )),
            maximum: child_hint.maximum.map(|s| Size::new(
                s.width + margins.horizontal(),
                s.height + margins.vertical(),
            )),
        }
    }

    fn minimum_size&lt;S: WidgetAccess&gt;(&amp;self, storage: &amp;S) -&gt; Size {
        self.size_hint(storage).effective_minimum()
    }

    fn size_policy(&amp;self) -&gt; SizePolicyPair {
        SizePolicyPair::default()
    }
    // ... continued below
}</code></pre>
<p><strong>Geometry</strong> - Delegate to LayoutBase:</p>
<pre><code class="language-rust">impl Layout for CenteredLayout {
    // ... size hints above

    fn geometry(&amp;self) -&gt; Rect {
        self.base.geometry()
    }

    fn set_geometry(&amp;mut self, rect: Rect) {
        self.base.set_geometry(rect);
    }

    fn content_margins(&amp;self) -&gt; ContentMargins {
        self.base.content_margins()
    }

    fn set_content_margins(&amp;mut self, margins: ContentMargins) {
        self.base.set_content_margins(margins);
    }

    fn spacing(&amp;self) -&gt; f32 {
        self.base.spacing()
    }

    fn set_spacing(&amp;mut self, spacing: f32) {
        self.base.set_spacing(spacing);
    }
    // ... continued below
}</code></pre>
<p><strong>Layout Calculation</strong> - The core algorithm:</p>
<pre><code class="language-rust">impl Layout for CenteredLayout {
    // ... geometry above

    fn calculate&lt;S: WidgetAccess&gt;(&amp;mut self, storage: &amp;S, _available: Size) -&gt; Size {
        let content_rect = self.base.content_rect();

        if let Some(item) = self.base.item_at(0) {
            // Get the child's preferred size
            let hint = self.base.get_item_size_hint(storage, item);

            // Constrain to available space
            let child_width = hint.preferred.width.min(content_rect.width());
            let child_height = hint.preferred.height.min(content_rect.height());

            // Calculate centered position
            let x = content_rect.origin.x + (content_rect.width() - child_width) / 2.0;
            let y = content_rect.origin.y + (content_rect.height() - child_height) / 2.0;

            // Store the calculated geometry
            self.base.set_item_geometry(0, Rect::new(x, y, child_width, child_height));
        }

        // Cache size hint for performance
        let hint = self.size_hint(storage);
        self.base.set_cached_size_hint(hint);
        self.base.mark_valid();

        self.base.geometry().size
    }

    fn apply&lt;S: WidgetAccess&gt;(&amp;self, storage: &amp;mut S) {
        // Apply calculated geometry to the widget
        if let Some(item) = self.base.item_at(0) {
            if let Some(geometry) = self.base.item_geometry(0) {
                LayoutBase::apply_item_geometry(storage, item, geometry);
            }
        }
    }
    // ... continued below
}</code></pre>
<p><strong>Invalidation and Ownership</strong> - Delegate to LayoutBase:</p>
<pre><code class="language-rust">impl Layout for CenteredLayout {
    // ... calculate and apply above

    fn invalidate(&amp;mut self) {
        self.base.invalidate();
    }

    fn needs_recalculation(&amp;self) -&gt; bool {
        self.base.needs_recalculation()
    }

    fn parent_widget(&amp;self) -&gt; Option&lt;ObjectId&gt; {
        self.base.parent_widget()
    }

    fn set_parent_widget(&amp;mut self, parent: Option&lt;ObjectId&gt;) {
        self.base.set_parent_widget(parent);
    }
}</code></pre>
<h3 id="using-layoutbase-helpers"><a class="header" href="#using-layoutbase-helpers">Using LayoutBase Helpers</a></h3>
<p><code>LayoutBase</code> provides several helper methods for implementing layouts:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::LayoutBase;

// In your calculate() implementation:
fn calculate&lt;S: WidgetAccess&gt;(&amp;mut self, storage: &amp;S, available: Size) -&gt; Size {
    // Get the content area (geometry minus margins)
    let content = self.base.content_rect();

    // Iterate over items and check visibility
    for (i, item) in self.base.items().iter().enumerate() {
        // Skip hidden widgets
        if !self.base.is_item_visible(storage, item) {
            continue;
        }

        // Get size hint for this item
        let hint = self.base.get_item_size_hint(storage, item);

        // Get size policy for this item
        let policy = self.base.get_item_size_policy(storage, item);

        // Calculate position and store it
        let rect = Rect::new(/* your calculation */);
        self.base.set_item_geometry(i, rect);
    }

    // Count visible items (for spacing calculations)
    let visible_count = self.base.visible_item_count(storage);

    self.base.mark_valid();
    available
}</code></pre>
<h3 id="space-distribution"><a class="header" href="#space-distribution">Space Distribution</a></h3>
<p>For layouts that distribute space among multiple items, use <code>LayoutBase::distribute_space</code>:</p>
<pre><code class="language-rust">use horizon_lattice::widget::geometry::{SizeHint, SizePolicy};

// Collect item information: (size_hint, policy, stretch_factor)
let items: Vec&lt;(SizeHint, SizePolicy, u8)&gt; = /* gather from items */;

// Calculate totals
let total_hint: f32 = items.iter().map(|(h, _, _)| h.preferred.width).sum();
let total_min: f32 = items.iter().map(|(h, _, _)| h.effective_minimum().width).sum();
let total_max: f32 = items.iter().map(|(h, _, _)| h.effective_maximum().width).sum();

// Distribute available space
let sizes = LayoutBase::distribute_space(
    &amp;items,
    available_width,  // Total available space
    total_hint,       // Sum of preferred sizes
    total_min,        // Sum of minimum sizes
    total_max,        // Sum of maximum sizes
);

// sizes[i] is the width to assign to item i</code></pre>
<h3 id="rtl-right-to-left-support"><a class="header" href="#rtl-right-to-left-support">RTL (Right-to-Left) Support</a></h3>
<p>For horizontal layouts, support RTL text direction:</p>
<pre><code class="language-rust">fn calculate&lt;S: WidgetAccess&gt;(&amp;mut self, storage: &amp;S, available: Size) -&gt; Size {
    let content = self.base.content_rect();
    let mut x_pos: f32 = 0.0;

    for (i, item) in self.base.items().iter().enumerate() {
        let item_width = /* calculated width */;

        // Mirror x position for RTL layouts
        let x = self.base.mirror_x(x_pos, item_width, content.width());

        let rect = Rect::new(
            content.origin.x + x,
            content.origin.y,
            item_width,
            content.height(),
        );
        self.base.set_item_geometry(i, rect);

        x_pos += item_width + self.base.spacing();
    }

    self.base.mark_valid();
    available
}</code></pre>
<h3 id="height-for-width-layouts"><a class="header" href="#height-for-width-layouts">Height-for-Width Layouts</a></h3>
<p>Some layouts (like flow layouts) need to adjust height based on available width:</p>
<pre><code class="language-rust">impl Layout for FlowingLayout {
    fn has_height_for_width(&amp;self) -&gt; bool {
        true
    }

    fn height_for_width&lt;S: WidgetAccess&gt;(&amp;self, storage: &amp;S, width: f32) -&gt; Option&lt;f32&gt; {
        // Calculate how many rows needed at this width
        let mut current_x: f32 = 0.0;
        let mut current_row_height: f32 = 0.0;
        let mut total_height: f32 = 0.0;
        let content_width = width - self.base.content_margins().horizontal();

        for item in self.base.items() {
            let hint = self.base.get_item_size_hint(storage, item);
            let item_width = hint.preferred.width;
            let item_height = hint.preferred.height;

            if current_x + item_width &gt; content_width &amp;&amp; current_x &gt; 0.0 {
                // Wrap to next row
                total_height += current_row_height + self.base.spacing();
                current_x = 0.0;
                current_row_height = 0.0;
            }

            current_row_height = current_row_height.max(item_height);
            current_x += item_width + self.base.spacing();
        }

        total_height += current_row_height;
        Some(total_height + self.base.content_margins().vertical())
    }
}</code></pre>
<h3 id="complete-example-diagonal-layout"><a class="header" href="#complete-example-diagonal-layout">Complete Example: Diagonal Layout</a></h3>
<p>Here’s a complete custom layout that arranges items diagonally:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::{Layout, LayoutBase, LayoutItem, ContentMargins};
use horizon_lattice::widget::geometry::{SizeHint, SizePolicyPair};
use horizon_lattice::widget::dispatcher::WidgetAccess;
use horizon_lattice_core::ObjectId;
use horizon_lattice_render::{Rect, Size};

/// Arranges items diagonally from top-left to bottom-right.
#[derive(Debug, Clone)]
pub struct DiagonalLayout {
    base: LayoutBase,
    /// Horizontal offset per item.
    x_offset: f32,
    /// Vertical offset per item.
    y_offset: f32,
}

impl DiagonalLayout {
    pub fn new(x_offset: f32, y_offset: f32) -&gt; Self {
        Self {
            base: LayoutBase::new(),
            x_offset,
            y_offset,
        }
    }
}

impl Layout for DiagonalLayout {
    // Item management - delegate to base
    fn add_item(&amp;mut self, item: LayoutItem) { self.base.add_item(item); }
    fn insert_item(&amp;mut self, index: usize, item: LayoutItem) { self.base.insert_item(index, item); }
    fn remove_item(&amp;mut self, index: usize) -&gt; Option&lt;LayoutItem&gt; { self.base.remove_item(index) }
    fn remove_widget(&amp;mut self, widget: ObjectId) -&gt; bool { self.base.remove_widget(widget) }
    fn item_count(&amp;self) -&gt; usize { self.base.item_count() }
    fn item_at(&amp;self, index: usize) -&gt; Option&lt;&amp;LayoutItem&gt; { self.base.item_at(index) }
    fn item_at_mut(&amp;mut self, index: usize) -&gt; Option&lt;&amp;mut LayoutItem&gt; { self.base.item_at_mut(index) }
    fn clear(&amp;mut self) { self.base.clear(); }

    fn size_hint&lt;S: WidgetAccess&gt;(&amp;self, storage: &amp;S) -&gt; SizeHint {
        let margins = self.base.content_margins();
        let visible_count = self.base.visible_item_count(storage);
        let mut max_width: f32 = 0.0;
        let mut max_height: f32 = 0.0;

        for (i, item) in self.base.items().iter().enumerate() {
            if !self.base.is_item_visible(storage, item) { continue; }
            let hint = self.base.get_item_size_hint(storage, item);
            let x_end = (i as f32) * self.x_offset + hint.preferred.width;
            let y_end = (i as f32) * self.y_offset + hint.preferred.height;
            max_width = max_width.max(x_end);
            max_height = max_height.max(y_end);
        }

        SizeHint::new(Size::new(
            max_width + margins.horizontal(),
            max_height + margins.vertical(),
        ))
    }

    fn minimum_size&lt;S: WidgetAccess&gt;(&amp;self, storage: &amp;S) -&gt; Size {
        self.size_hint(storage).effective_minimum()
    }

    fn size_policy(&amp;self) -&gt; SizePolicyPair { SizePolicyPair::default() }

    // Geometry - delegate to base
    fn geometry(&amp;self) -&gt; Rect { self.base.geometry() }
    fn set_geometry(&amp;mut self, rect: Rect) { self.base.set_geometry(rect); }
    fn content_margins(&amp;self) -&gt; ContentMargins { self.base.content_margins() }
    fn set_content_margins(&amp;mut self, margins: ContentMargins) { self.base.set_content_margins(margins); }
    fn spacing(&amp;self) -&gt; f32 { self.base.spacing() }
    fn set_spacing(&amp;mut self, spacing: f32) { self.base.set_spacing(spacing); }

    fn calculate&lt;S: WidgetAccess&gt;(&amp;mut self, storage: &amp;S, available: Size) -&gt; Size {
        let content = self.base.content_rect();
        let mut visible_index = 0;

        for (i, item) in self.base.items().iter().enumerate() {
            if !self.base.is_item_visible(storage, item) {
                self.base.set_item_geometry(i, Rect::ZERO);
                continue;
            }

            let hint = self.base.get_item_size_hint(storage, item);
            let x = content.origin.x + (visible_index as f32) * self.x_offset;
            let y = content.origin.y + (visible_index as f32) * self.y_offset;

            self.base.set_item_geometry(i, Rect::new(
                x,
                y,
                hint.preferred.width.min(content.width()),
                hint.preferred.height.min(content.height()),
            ));

            visible_index += 1;
        }

        self.base.mark_valid();
        available
    }

    fn apply&lt;S: WidgetAccess&gt;(&amp;self, storage: &amp;mut S) {
        for (i, item) in self.base.items().iter().enumerate() {
            if let Some(geometry) = self.base.item_geometry(i) {
                LayoutBase::apply_item_geometry(storage, item, geometry);
            }
        }
    }

    // Invalidation - delegate to base
    fn invalidate(&amp;mut self) { self.base.invalidate(); }
    fn needs_recalculation(&amp;self) -&gt; bool { self.base.needs_recalculation() }
    fn parent_widget(&amp;self) -&gt; Option&lt;ObjectId&gt; { self.base.parent_widget() }
    fn set_parent_widget(&amp;mut self, parent: Option&lt;ObjectId&gt;) { self.base.set_parent_widget(parent); }
}</code></pre>
<h3 id="best-practices-for-custom-layouts"><a class="header" href="#best-practices-for-custom-layouts">Best Practices for Custom Layouts</a></h3>
<ol>
<li><strong>Always use LayoutBase</strong> - It handles caching, invalidation, and common operations</li>
<li><strong>Mark layout valid after calculation</strong> - Call <code>self.base.mark_valid()</code> at the end of <code>calculate()</code></li>
<li><strong>Skip hidden items</strong> - Use <code>is_item_visible()</code> to skip hidden widgets</li>
<li><strong>Cache size hints</strong> - Use <code>set_cached_size_hint()</code> for performance</li>
<li><strong>Handle empty layouts</strong> - Return early if <code>item_count() == 0</code></li>
<li><strong>Respect size policies</strong> - Use <code>get_item_size_policy()</code> to determine if items can grow/shrink</li>
<li><strong>Account for margins</strong> - Use <code>content_rect()</code> to get the area inside margins</li>
<li><strong>Test with RTL</strong> - If horizontal, test with RTL text direction</li>
</ol>
<h2 id="default-layout-constants"><a class="header" href="#default-layout-constants">Default Layout Constants</a></h2>
<p>The layout system provides sensible defaults:</p>
<pre><code class="language-rust">use horizon_lattice::widget::layout::{DEFAULT_SPACING, DEFAULT_MARGINS};

// Default spacing between items
assert_eq!(DEFAULT_SPACING, 6.0);

// Default content margins
assert_eq!(DEFAULT_MARGINS.left, 9.0);
assert_eq!(DEFAULT_MARGINS.top, 9.0);
assert_eq!(DEFAULT_MARGINS.right, 9.0);
assert_eq!(DEFAULT_MARGINS.bottom, 9.0);</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Use appropriate layouts</strong> - VBox/HBox for linear arrangements, Grid for tables, Form for input forms</li>
<li><strong>Set size policies</strong> - Help layouts make better decisions about space distribution</li>
<li><strong>Use stretch factors</strong> - Control how extra space is distributed between widgets</li>
<li><strong>Nest layouts</strong> - Combine simple layouts for complex UIs rather than using one complex layout</li>
<li><strong>Set minimum sizes</strong> - Prevent layouts from shrinking widgets too small</li>
<li><strong>Use spacers</strong> - Add flexible space to push widgets apart or fill gaps</li>
</ol>
<p>See the <a href="#layout-reference">Layout Reference</a> for all layout types.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="styling-guide"><a class="header" href="#styling-guide">Styling Guide</a></h1>
<p>Horizon Lattice uses a CSS-like styling system for widget appearance.</p>
<h2 id="selectors"><a class="header" href="#selectors">Selectors</a></h2>
<h3 id="type-selectors"><a class="header" href="#type-selectors">Type Selectors</a></h3>
<p>Match widgets by type name:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// Simple type selector
let button = Selector::type_selector("Button");
assert_eq!(button.to_string(), "Button");

let label = Selector::type_selector("Label");
assert_eq!(label.to_string(), "Label");

// Universal selector (matches any widget)
let any = Selector::universal();
assert_eq!(any.to_string(), "*");</code></pre>
<h3 id="class-selectors"><a class="header" href="#class-selectors">Class Selectors</a></h3>
<p>Match widgets with a specific class:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// Class selector
let primary = Selector::class("primary");
assert_eq!(primary.to_string(), ".primary");

let danger = Selector::class("danger");
assert_eq!(danger.to_string(), ".danger");

// Combine type and class
let primary_button = Selector::type_selector("Button")
    .descendant(SelectorPart::class_only("primary"));
assert_eq!(primary_button.to_string(), "Button .primary");</code></pre>
<h3 id="id-selectors"><a class="header" href="#id-selectors">ID Selectors</a></h3>
<p>Match a specific widget by ID:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// ID selector
let submit = Selector::id("submit-button");
assert_eq!(submit.to_string(), "#submit-button");

let header = Selector::id("main-header");
assert_eq!(header.to_string(), "#main-header");</code></pre>
<h3 id="pseudo-classes"><a class="header" href="#pseudo-classes">Pseudo-Classes</a></h3>
<p>Match widget states:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// Create a selector with hover pseudo-class
let hover = Selector::type_selector("Button")
    .descendant(SelectorPart::new().with_pseudo(PseudoClass::Hover));
assert_eq!(hover.to_string(), "Button :hover");

// Button with pressed state
let pressed = SelectorPart::type_only("Button")
    .with_pseudo(PseudoClass::Pressed);
assert_eq!(pressed.to_string(), "Button:pressed");

// Available pseudo-classes
let _ = PseudoClass::Hover;     // Mouse over widget
let _ = PseudoClass::Pressed;   // Mouse button down
let _ = PseudoClass::Focused;   // Has keyboard focus
let _ = PseudoClass::Disabled;  // Widget is disabled
let _ = PseudoClass::Enabled;   // Widget is enabled
let _ = PseudoClass::Checked;   // For checkable widgets
let _ = PseudoClass::Unchecked; // For checkable widgets
let _ = PseudoClass::FirstChild;  // First among siblings
let _ = PseudoClass::LastChild;   // Last among siblings
let _ = PseudoClass::OnlyChild;   // Only child of parent
let _ = PseudoClass::Empty;       // Has no children</code></pre>
<h3 id="combinators"><a class="header" href="#combinators">Combinators</a></h3>
<p>Combine selectors for hierarchical matching:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// Descendant combinator (any depth)
let nested = Selector::type_selector("Container")
    .descendant(SelectorPart::type_only("Button"));
assert_eq!(nested.to_string(), "Container Button");

// Child combinator (direct child only)
let child = Selector::type_selector("Form")
    .child(SelectorPart::type_only("Label"));
assert_eq!(child.to_string(), "Form &gt; Label");

// Multiple levels
let deep = Selector::type_selector("Window")
    .descendant(SelectorPart::type_only("Container"))
    .child(SelectorPart::class_only("button-row"))
    .descendant(SelectorPart::type_only("Button"));
assert_eq!(deep.to_string(), "Window Container &gt; .button-row Button");</code></pre>
<h2 id="specificity"><a class="header" href="#specificity">Specificity</a></h2>
<p>CSS specificity determines which styles take precedence:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// Specificity is (IDs, Classes+PseudoClasses, Types)

// * -&gt; (0,0,0)
let universal = Selector::universal();
assert_eq!(Specificity::of_selector(&amp;universal), Specificity(0, 0, 0));

// Button -&gt; (0,0,1)
let button = Selector::type_selector("Button");
assert_eq!(Specificity::of_selector(&amp;button), Specificity(0, 0, 1));

// .primary -&gt; (0,1,0)
let class = Selector::class("primary");
assert_eq!(Specificity::of_selector(&amp;class), Specificity(0, 1, 0));

// #submit -&gt; (1,0,0)
let id = Selector::id("submit");
assert_eq!(Specificity::of_selector(&amp;id), Specificity(1, 0, 0));

// Button.primary:hover -&gt; (0,2,1) = 1 type + 1 class + 1 pseudo-class
let complex = Selector {
    parts: vec![
        SelectorPart::type_only("Button")
            .with_class("primary")
            .with_pseudo(PseudoClass::Hover)
    ],
    combinators: vec![],
};
assert_eq!(Specificity::of_selector(&amp;complex), Specificity(0, 2, 1));

// Higher specificity wins
assert!(Specificity(1, 0, 0) &gt; Specificity(0, 99, 99)); // ID beats many classes
assert!(Specificity(0, 1, 0) &gt; Specificity(0, 0, 99));  // Class beats many types</code></pre>
<h2 id="building-selectors"><a class="header" href="#building-selectors">Building Selectors</a></h2>
<p>Use the builder pattern for complex selectors:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// Build a selector programmatically
let selector = Selector::type_selector("Button")
    .child(SelectorPart::class_only("icon"))
    .descendant(SelectorPart::type_only("Image"));

assert_eq!(selector.to_string(), "Button &gt; .icon Image");

// Get the subject (rightmost part)
let subject = selector.subject().unwrap();
assert!(matches!(subject.type_selector, Some(TypeSelector::Type(ref t)) if t == "Image"));

// Build a complex selector part
let part = SelectorPart::type_only("Button")
    .with_class("primary")
    .with_class("large")
    .with_pseudo(PseudoClass::Hover);
assert_eq!(part.to_string(), "Button.primary.large:hover");</code></pre>
<h2 id="themes"><a class="header" href="#themes">Themes</a></h2>
<p>Create and use themes for consistent styling:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// Use built-in themes
let light = Theme::light();
let dark = Theme::dark();
let high_contrast = Theme::high_contrast();

// Check theme mode
assert_eq!(light.mode, ThemeMode::Light);
assert_eq!(dark.mode, ThemeMode::Dark);
assert_eq!(high_contrast.mode, ThemeMode::HighContrast);

// Access theme colors
let primary_color = light.primary();
let background = light.background();
let text_color = light.text_color();</code></pre>
<h2 id="nth-child-expressions"><a class="header" href="#nth-child-expressions">Nth-Child Expressions</a></h2>
<p>Use nth-child for pattern-based selection:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// :nth-child(odd) matches 1st, 3rd, 5th... (2n+1)
let odd = NthExpr::odd();
assert!(odd.matches(0));   // 1st child (0-indexed)
assert!(!odd.matches(1));  // 2nd child
assert!(odd.matches(2));   // 3rd child

// :nth-child(even) matches 2nd, 4th, 6th... (2n)
let even = NthExpr::even();
assert!(!even.matches(0)); // 1st child
assert!(even.matches(1));  // 2nd child
assert!(!even.matches(2)); // 3rd child

// :nth-child(3) matches only the 3rd child
let third = NthExpr::new(0, 3);
assert!(!third.matches(0));
assert!(!third.matches(1));
assert!(third.matches(2));  // 3rd child (0-indexed = 2)

// Custom expression: every 3rd starting from 2nd (3n+2)
let custom = NthExpr::new(3, 2);
println!("Formula: {}", custom); // "3n+2"</code></pre>
<h2 id="css-pseudo-class-parsing"><a class="header" href="#css-pseudo-class-parsing">CSS Pseudo-Class Parsing</a></h2>
<p>Parse pseudo-classes from CSS strings:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// Parse standard pseudo-classes
assert_eq!(PseudoClass::from_css("hover"), Some(PseudoClass::Hover));
assert_eq!(PseudoClass::from_css("pressed"), Some(PseudoClass::Pressed));
assert_eq!(PseudoClass::from_css("active"), Some(PseudoClass::Pressed)); // CSS alias
assert_eq!(PseudoClass::from_css("focused"), Some(PseudoClass::Focused));
assert_eq!(PseudoClass::from_css("focus"), Some(PseudoClass::Focused)); // CSS alias
assert_eq!(PseudoClass::from_css("disabled"), Some(PseudoClass::Disabled));
assert_eq!(PseudoClass::from_css("first-child"), Some(PseudoClass::FirstChild));

// Unknown pseudo-class returns None
assert_eq!(PseudoClass::from_css("unknown"), None);</code></pre>
<h2 id="specificity-with-source-order"><a class="header" href="#specificity-with-source-order">Specificity With Source Order</a></h2>
<p>When specificity is equal, later rules win:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

// Same specificity, different source order
let s1 = Specificity(0, 1, 0).with_order(1);
let s2 = Specificity(0, 1, 0).with_order(2);

// Higher order (later in stylesheet) wins
assert!(s2 &gt; s1);

// But higher specificity always beats lower
let s3 = Specificity(0, 2, 0).with_order(0);
assert!(s3 &gt; s1); // More specific, even though earlier
assert!(s3 &gt; s2);</code></pre>
<h2 id="theme-modes"><a class="header" href="#theme-modes">Theme Modes</a></h2>
<p>Support different visual modes:</p>
<pre><code class="language-rust">use horizon_lattice_style::prelude::*;

fn select_theme(user_preference: &amp;str) -&gt; Theme {
    match user_preference {
        "dark" =&gt; Theme::dark(),
        "high-contrast" =&gt; Theme::high_contrast(),
        _ =&gt; Theme::light(),
    }
}

// Check and respond to theme mode
let theme = Theme::dark();
match theme.mode {
    ThemeMode::Light =&gt; println!("Using light theme"),
    ThemeMode::Dark =&gt; println!("Using dark theme"),
    ThemeMode::HighContrast =&gt; println!("Using high contrast theme"),
}</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li><strong>Use class selectors</strong> for reusable styles across widget types</li>
<li><strong>Use type selectors</strong> for widget-specific default styles</li>
<li><strong>Use ID selectors sparingly</strong> - they have high specificity and are harder to override</li>
<li><strong>Keep specificity low</strong> - makes styles easier to maintain and override</li>
<li><strong>Use combinators</strong> to scope styles without increasing specificity too much</li>
<li><strong>Leverage themes</strong> for consistent colors and spacing across your application</li>
<li><strong>Use pseudo-classes</strong> for interactive states instead of JavaScript-style state changes</li>
</ol>
<h2 id="supported-properties"><a class="header" href="#supported-properties">Supported Properties</a></h2>
<h3 id="box-model"><a class="header" href="#box-model">Box Model</a></h3>
<ul>
<li><code>margin</code>, <code>padding</code> - Edge spacing</li>
<li><code>border-width</code>, <code>border-color</code>, <code>border-style</code> - Borders</li>
<li><code>border-radius</code> - Rounded corners</li>
</ul>
<h3 id="colors-1"><a class="header" href="#colors-1">Colors</a></h3>
<ul>
<li><code>color</code> - Text color</li>
<li><code>background-color</code> - Background fill</li>
</ul>
<h3 id="typography"><a class="header" href="#typography">Typography</a></h3>
<ul>
<li><code>font-size</code>, <code>font-weight</code>, <code>font-style</code></li>
<li><code>font-family</code> - Font name or generic</li>
<li><code>text-align</code> - left, center, right</li>
<li><code>line-height</code> - Line spacing</li>
</ul>
<h3 id="effects"><a class="header" href="#effects">Effects</a></h3>
<ul>
<li><code>opacity</code> - 0.0 to 1.0</li>
</ul>
<h3 id="cursor"><a class="header" href="#cursor">Cursor</a></h3>
<ul>
<li><code>cursor</code> - pointer, text, etc.</li>
</ul>
<p>See <a href="#style-properties-reference">Style Properties Reference</a> for the complete list.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="signals-and-slots-guide"><a class="header" href="#signals-and-slots-guide">Signals and Slots Guide</a></h1>
<p>Signals are Horizon Lattice’s mechanism for event-driven programming. They provide type-safe, thread-safe communication between objects.</p>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h2>
<p>Signals emit values that connected slots (callbacks) receive:</p>
<pre><code class="language-rust">use horizon_lattice_core::Signal;

// Create a signal
let clicked = Signal::&lt;()&gt;::new();

// Connect a slot
let conn_id = clicked.connect(|_| {
    println!("Button clicked!");
});

// Emit the signal
clicked.emit(());

// Disconnect later if needed
clicked.disconnect(conn_id);</code></pre>
<h2 id="signal-types"><a class="header" href="#signal-types">Signal Types</a></h2>
<h3 id="parameterless-signals"><a class="header" href="#parameterless-signals">Parameterless Signals</a></h3>
<p>For events that don’t carry data:</p>
<pre><code class="language-rust">use horizon_lattice_core::Signal;

let clicked = Signal::&lt;()&gt;::new();
clicked.connect(|_| println!("Clicked!"));
clicked.emit(());</code></pre>
<h3 id="signals-with-parameters"><a class="header" href="#signals-with-parameters">Signals with Parameters</a></h3>
<p>For events that carry data:</p>
<pre><code class="language-rust">use horizon_lattice_core::Signal;

// Single parameter
let text_changed = Signal::&lt;String&gt;::new();
text_changed.connect(|new_text| {
    println!("Text is: {}", new_text);
});
text_changed.emit("Hello".to_string());

// Primitive parameter (note the reference pattern)
let value_changed = Signal::&lt;i32&gt;::new();
value_changed.connect(|&amp;value| {
    println!("Value: {}", value);
});
value_changed.emit(42);</code></pre>
<h3 id="signals-with-multiple-parameters"><a class="header" href="#signals-with-multiple-parameters">Signals with Multiple Parameters</a></h3>
<p>Use tuples for multiple values:</p>
<pre><code class="language-rust">use horizon_lattice_core::Signal;

let position_changed = Signal::&lt;(f32, f32)&gt;::new();
position_changed.connect(|(x, y)| {
    println!("Position: ({}, {})", x, y);
});
position_changed.emit((100.0, 200.0));</code></pre>
<h2 id="connection-types-1"><a class="header" href="#connection-types-1">Connection Types</a></h2>
<p>Control how slots are invoked:</p>
<pre><code class="language-rust">use horizon_lattice_core::{Signal, ConnectionType};

let signal = Signal::&lt;i32&gt;::new();

// Auto (default) - Direct if same thread, Queued if different
signal.connect(|&amp;n| println!("Auto: {}", n));

// Direct - Called immediately, same thread
signal.connect_with_type(|&amp;n| println!("Direct: {}", n), ConnectionType::Direct);

// Queued - Always posted to event loop (cross-thread safe)
signal.connect_with_type(|&amp;n| println!("Queued: {}", n), ConnectionType::Queued);

signal.emit(42);</code></pre>
<h3 id="connection-type-details"><a class="header" href="#connection-type-details">Connection Type Details</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Type</th><th>Behavior</th><th>Use Case</th></tr>
</thead>
<tbody>
<tr><td><code>Auto</code></td><td>Direct if same thread, Queued otherwise</td><td>Most situations (default)</td></tr>
<tr><td><code>Direct</code></td><td>Immediate, synchronous call</td><td>Same-thread, performance critical</td></tr>
<tr><td><code>Queued</code></td><td>Posted to event loop</td><td>Cross-thread communication</td></tr>
<tr><td><code>BlockingQueued</code></td><td>Queued but blocks until complete</td><td>Synchronization across threads</td></tr>
</tbody>
</table>
</div>
<h2 id="creating-custom-signals"><a class="header" href="#creating-custom-signals">Creating Custom Signals</a></h2>
<p>Embed signals in your types:</p>
<pre><code class="language-rust">use horizon_lattice_core::{Signal, Property};

struct Counter {
    value: Property&lt;i32&gt;,
    value_changed: Signal&lt;i32&gt;,
}

impl Counter {
    pub fn new() -&gt; Self {
        Self {
            value: Property::new(0),
            value_changed: Signal::new(),
        }
    }

    pub fn value_changed(&amp;self) -&gt; &amp;Signal&lt;i32&gt; {
        &amp;self.value_changed
    }

    pub fn value(&amp;self) -&gt; i32 {
        self.value.get()
    }

    pub fn set_value(&amp;self, new_value: i32) {
        if self.value.set(new_value) {
            self.value_changed.emit(new_value);
        }
    }

    pub fn increment(&amp;self) {
        self.set_value(self.value() + 1);
    }
}

// Usage
let counter = Counter::new();
counter.value_changed().connect(|&amp;v| println!("Counter: {}", v));
counter.increment();  // Prints: Counter: 1
counter.increment();  // Prints: Counter: 2</code></pre>
<h2 id="scoped-connections"><a class="header" href="#scoped-connections">Scoped Connections</a></h2>
<p>Automatically disconnect when the guard is dropped (RAII pattern):</p>
<pre><code class="language-rust">use horizon_lattice_core::Signal;
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;

let signal = Signal::&lt;i32&gt;::new();
let counter = Arc::new(AtomicI32::new(0));

{
    let counter_clone = counter.clone();
    let _guard = signal.connect_scoped(move |&amp;n| {
        counter_clone.fetch_add(n, Ordering::SeqCst);
    });
    signal.emit(10);  // counter = 10
    // _guard is dropped here
}

signal.emit(20);  // Nothing happens, connection was dropped
assert_eq!(counter.load(Ordering::SeqCst), 10);</code></pre>
<h2 id="blocking-signal-emission"><a class="header" href="#blocking-signal-emission">Blocking Signal Emission</a></h2>
<p>Temporarily disable a signal:</p>
<pre><code class="language-rust">use horizon_lattice_core::Signal;
use std::sync::atomic::{AtomicI32, Ordering};
use std::sync::Arc;

let signal = Signal::&lt;i32&gt;::new();
let counter = Arc::new(AtomicI32::new(0));

let counter_clone = counter.clone();
signal.connect(move |&amp;n| {
    counter_clone.fetch_add(n, Ordering::SeqCst);
});

signal.emit(1);  // counter = 1
signal.set_blocked(true);
signal.emit(2);  // Blocked - nothing happens
signal.set_blocked(false);
signal.emit(3);  // counter = 4

assert_eq!(counter.load(Ordering::SeqCst), 4);</code></pre>
<h2 id="thread-safety"><a class="header" href="#thread-safety">Thread Safety</a></h2>
<p>Signals are thread-safe (<code>Send + Sync</code>). Cross-thread emissions are automatically handled:</p>
<pre><code class="language-rust">use horizon_lattice_core::{Signal, ConnectionType};
use std::sync::Arc;
use std::sync::atomic::{AtomicI32, Ordering};

let signal = Arc::new(Signal::&lt;i32&gt;::new());
let counter = Arc::new(AtomicI32::new(0));

// Connect from main thread
let counter_clone = counter.clone();
signal.connect_with_type(move |&amp;n| {
    counter_clone.fetch_add(n, Ordering::SeqCst);
}, ConnectionType::Direct);

// Emit from worker thread
let signal_clone = signal.clone();
let handle = std::thread::spawn(move || {
    signal_clone.emit(42);
});

handle.join().unwrap();
assert_eq!(counter.load(Ordering::SeqCst), 42);</code></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<ol>
<li><strong>Keep slots short</strong> - Long operations should spawn background tasks</li>
<li><strong>Avoid blocking</strong> - Never block the main thread in a slot</li>
<li><strong>Use scoped connections</strong> - When the receiver has a shorter lifetime than the signal</li>
<li><strong>Don’t recurse</strong> - Emitting the same signal from its handler can cause infinite loops</li>
<li><strong>Use Direct for performance</strong> - When you know both sides are on the same thread</li>
<li><strong>Use Queued for safety</strong> - When crossing thread boundaries or uncertain</li>
</ol>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="one-shot-connection"><a class="header" href="#one-shot-connection">One-shot Connection</a></h3>
<p>Connect, emit once, then auto-disconnect:</p>
<pre><code class="language-rust">use horizon_lattice_core::Signal;
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;

let signal = Signal::&lt;()&gt;::new();
let done = Arc::new(AtomicBool::new(false));

let done_clone = done.clone();
let id = signal.connect(move |_| {
    done_clone.store(true, Ordering::SeqCst);
});

signal.emit(());
signal.disconnect(id);  // Manually disconnect after first use</code></pre>
<h3 id="forwarding-signals"><a class="header" href="#forwarding-signals">Forwarding Signals</a></h3>
<p>Chain signals together:</p>
<pre><code class="language-rust">use horizon_lattice_core::Signal;
use std::sync::Arc;

let source = Arc::new(Signal::&lt;String&gt;::new());
let destination = Arc::new(Signal::&lt;String&gt;::new());

// Forward from source to destination
let dest_clone = destination.clone();
source.connect(move |s| {
    dest_clone.emit(s.clone());
});</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="threading-guide"><a class="header" href="#threading-guide">Threading Guide</a></h1>
<p>Horizon Lattice follows a single-threaded UI model with support for background tasks.</p>
<h2 id="threading-model-1"><a class="header" href="#threading-model-1">Threading Model</a></h2>
<ul>
<li><strong>Main thread</strong>: All UI operations must happen here</li>
<li><strong>Worker threads</strong>: For CPU-intensive or blocking operations</li>
<li><strong>Signal marshalling</strong>: Cross-thread signals are automatically queued</li>
</ul>
<h2 id="main-thread-rule"><a class="header" href="#main-thread-rule">Main Thread Rule</a></h2>
<p>UI widgets are not thread-safe. Always access them from the main thread:</p>
<pre><code class="language-rust no_run">use horizon_lattice::Application;

// BAD - Don't do this!
// std::thread::spawn(|| {
//     label.set_text("Updated");  // Undefined behavior!
// });

// GOOD - Post to main thread
fn update_label_safely(app: &amp;Application) {
    app.post_task(|| {
        // UI operations are safe here - runs on main thread
        println!("This runs on the main thread!");
    });
}</code></pre>
<h2 id="thread-pool"><a class="header" href="#thread-pool">Thread Pool</a></h2>
<p>Use <code>ThreadPool</code> for CPU-intensive work:</p>
<pre><code class="language-rust">use horizon_lattice_core::threadpool::{ThreadPool, ThreadPoolConfig};

// Create a custom thread pool
let pool = ThreadPool::new(ThreadPoolConfig::with_threads(4))
    .expect("Failed to create thread pool");

// Spawn a background task
let handle = pool.spawn(|| {
    // Heavy computation here
    let mut sum = 0u64;
    for i in 0..1_000_000 {
        sum += i;
    }
    sum
});

// Wait for the result
let result = handle.wait();
assert_eq!(result, Some(499999500000));</code></pre>
<h2 id="thread-pool-with-ui-callbacks"><a class="header" href="#thread-pool-with-ui-callbacks">Thread Pool with UI Callbacks</a></h2>
<p>Spawn tasks that deliver results to the main thread:</p>
<pre><code class="language-rust no_run">use horizon_lattice_core::threadpool::ThreadPool;

let pool = ThreadPool::global();

// Spawn a task that delivers its result to the UI thread
pool.spawn_with_callback(
    || {
        // Background work - runs on worker thread
        std::thread::sleep(std::time::Duration::from_millis(100));
        "computed result".to_string()
    },
    |result| {
        // This callback runs on the UI thread
        println!("Got result: {}", result);
    },
);</code></pre>
<h2 id="cancellable-tasks"><a class="header" href="#cancellable-tasks">Cancellable Tasks</a></h2>
<p>Use <code>CancellationToken</code> for cooperative task cancellation:</p>
<pre><code class="language-rust">use horizon_lattice_core::threadpool::{ThreadPool, ThreadPoolConfig, CancellationToken};
use std::time::Duration;

let pool = ThreadPool::new(ThreadPoolConfig::with_threads(2)).unwrap();

let (handle, token) = pool.spawn_cancellable(|cancel_token| {
    for i in 0..100 {
        if cancel_token.is_cancelled() {
            return format!("Cancelled at step {}", i);
        }
        std::thread::sleep(Duration::from_millis(10));
    }
    "Completed".to_string()
});

// Cancel after a short delay
std::thread::sleep(Duration::from_millis(50));
token.cancel();

// The task will return early due to cancellation
let result = handle.wait();
assert!(result.is_some());
println!("Task result: {:?}", result);</code></pre>
<h2 id="worker-objects"><a class="header" href="#worker-objects">Worker Objects</a></h2>
<p>For persistent background workers that process tasks sequentially:</p>
<pre><code class="language-rust">use horizon_lattice_core::worker::Worker;
use std::sync::{Arc, atomic::{AtomicI32, Ordering}};

// Create a worker that produces String results
let worker = Worker::&lt;String&gt;::new();
let counter = Arc::new(AtomicI32::new(0));

// Connect to the result signal
let counter_clone = counter.clone();
worker.on_result().connect(move |result| {
    println!("Worker produced: {}", result);
    counter_clone.fetch_add(1, Ordering::SeqCst);
});

// Send tasks to the worker (processed sequentially)
worker.send(|| "Task 1 complete".to_string());
worker.send(|| "Task 2 complete".to_string());

// Wait for processing
std::thread::sleep(std::time::Duration::from_millis(100));

// Graceful shutdown
worker.stop();
worker.join();

assert!(counter.load(Ordering::SeqCst) &gt;= 1);</code></pre>
<h2 id="worker-with-callbacks"><a class="header" href="#worker-with-callbacks">Worker with Callbacks</a></h2>
<p>Send tasks with direct callbacks that bypass the signal:</p>
<pre><code class="language-rust">use horizon_lattice_core::worker::Worker;
use std::sync::{Arc, Mutex};

let worker = Worker::&lt;i32&gt;::new();
let result_holder = Arc::new(Mutex::new(None));

let result_clone = result_holder.clone();
worker.send_with_callback(
    || {
        // Compute something
        42 * 2
    },
    move |result| {
        // Callback receives the result
        *result_clone.lock().unwrap() = Some(result);
    },
);

// Wait for processing
std::thread::sleep(std::time::Duration::from_millis(100));

assert_eq!(*result_holder.lock().unwrap(), Some(84));

worker.stop_and_join();</code></pre>
<h2 id="progress-reporting"><a class="header" href="#progress-reporting">Progress Reporting</a></h2>
<p>Report progress from background tasks:</p>
<pre><code class="language-rust">use horizon_lattice_core::progress::ProgressReporter;
use std::sync::{Arc, Mutex};

let reporter = ProgressReporter::new();
let progress_values = Arc::new(Mutex::new(Vec::new()));

// Connect to progress updates
let values_clone = progress_values.clone();
reporter.on_progress_changed().connect(move |&amp;progress| {
    values_clone.lock().unwrap().push(progress);
});

// Simulate progress updates
reporter.set_progress(0.25);
reporter.set_progress(0.50);
reporter.set_progress(0.75);
reporter.set_progress(1.0);

// Verify progress was tracked
let values = progress_values.lock().unwrap();
assert!(values.len() &gt;= 4);
assert!((reporter.progress() - 1.0).abs() &lt; f32::EPSILON);</code></pre>
<h2 id="progress-with-status-messages"><a class="header" href="#progress-with-status-messages">Progress with Status Messages</a></h2>
<p>Combine progress values with status messages:</p>
<pre><code class="language-rust">use horizon_lattice_core::progress::ProgressReporter;

let reporter = ProgressReporter::new();

// Connect to combined updates
reporter.on_updated().connect(|update| {
    if let Some(ref msg) = update.message {
        println!("Progress: {:.0}% - {}", update.progress * 100.0, msg);
    }
});

// Update both progress and message atomically
reporter.update(0.25, "Loading resources...");
reporter.update(0.50, "Processing data...");
reporter.update(0.75, "Generating output...");
reporter.update(1.0, "Complete!");

assert_eq!(reporter.message(), Some("Complete!".to_string()));</code></pre>
<h2 id="aggregate-progress"><a class="header" href="#aggregate-progress">Aggregate Progress</a></h2>
<p>For multi-step operations, combine weighted sub-tasks:</p>
<pre><code class="language-rust">use horizon_lattice_core::progress::AggregateProgress;

let mut aggregate = AggregateProgress::new();

// Add weighted sub-tasks (weight determines contribution to total)
let download = aggregate.add_task("download", 3.0);  // 75% of total weight
let process = aggregate.add_task("process", 1.0);    // 25% of total weight

// Initial state
assert_eq!(aggregate.progress(), 0.0);

// Complete download only (75% of total due to weight)
download.set_progress(1.0);
assert!((aggregate.progress() - 0.75).abs() &lt; 0.01);

// Complete processing (now at 100%)
process.set_progress(1.0);
assert!((aggregate.progress() - 1.0).abs() &lt; 0.01);</code></pre>
<h2 id="tasks-with-progress-reporting"><a class="header" href="#tasks-with-progress-reporting">Tasks with Progress Reporting</a></h2>
<p>Combine thread pool tasks with progress reporting:</p>
<pre><code class="language-rust">use horizon_lattice_core::threadpool::{ThreadPool, ThreadPoolConfig};
use std::time::Duration;

let pool = ThreadPool::new(ThreadPoolConfig::with_threads(2)).unwrap();

let (handle, token, reporter) = pool.spawn_with_progress(|cancel, progress| {
    for i in 0..=10 {
        if cancel.is_cancelled() {
            return "Cancelled".to_string();
        }
        progress.update(i as f32 / 10.0, format!("Step {} of 10", i));
        std::thread::sleep(Duration::from_millis(5));
    }
    "Complete".to_string()
});

// Connect to progress updates
reporter.on_progress_changed().connect(|&amp;p| {
    println!("Progress: {:.0}%", p * 100.0);
});

// Wait for completion
let result = handle.wait();
assert_eq!(result, Some("Complete".to_string()));
assert!((reporter.progress() - 1.0).abs() &lt; f32::EPSILON);</code></pre>
<h2 id="thread-safety-checks"><a class="header" href="#thread-safety-checks">Thread Safety Checks</a></h2>
<p>The framework includes thread affinity checking:</p>
<pre><code class="language-rust">use horizon_lattice_core::thread_check::{is_main_thread, main_thread_id};

// Check if we're on the main thread
if is_main_thread() {
    println!("Running on main thread");
} else {
    println!("Running on a background thread");
}

// Get the main thread ID (set when Application is created)
if let Some(id) = main_thread_id() {
    println!("Main thread ID: {:?}", id);
}</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<ol>
<li><strong>Never block the main thread</strong> - Keep UI responsive</li>
<li><strong>Minimize cross-thread communication</strong> - Batch updates when possible</li>
<li><strong>Use signals for thread communication</strong> - They handle marshalling automatically</li>
<li><strong>Prefer async for I/O</strong> - Don’t waste threads waiting on network/disk</li>
<li><strong>Check cancellation tokens</strong> - Enable graceful shutdown of long-running tasks</li>
<li><strong>Use progress reporters</strong> - Keep users informed about long operations</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial-hello-world"><a class="header" href="#tutorial-hello-world">Tutorial: Hello World</a></h1>
<p>Build your first Horizon Lattice application.</p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You’ll Learn</a></h2>
<ul>
<li>Creating an Application instance</li>
<li>Showing a Window</li>
<li>Adding a Label widget</li>
<li>Understanding the basic structure</li>
</ul>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<ul>
<li>Rust installed (1.75+)</li>
<li>A new Cargo project</li>
</ul>
<h2 id="project-setup-1"><a class="header" href="#project-setup-1">Project Setup</a></h2>
<p>Create a new Rust project:</p>
<pre><code class="language-bash">cargo new hello-lattice
cd hello-lattice
</code></pre>
<p>Add Horizon Lattice to <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
horizon-lattice = "0.1"
</code></pre>
<h2 id="step-1-the-minimal-application"><a class="header" href="#step-1-the-minimal-application">Step 1: The Minimal Application</a></h2>
<p>Every Horizon Lattice application starts with creating an <code>Application</code>. This initializes the event loop, graphics context, and platform integration.</p>
<p>Replace <code>src/main.rs</code> with:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize the application (must be first)
    let app = Application::new()?;

    // Run the event loop (blocks until quit)
    Ok(app.run()?)
}</code></pre>
<p>This compiles and runs, but does nothing visible because there’s no window.</p>
<h2 id="step-2-create-a-window"><a class="header" href="#step-2-create-a-window">Step 2: Create a Window</a></h2>
<p>Windows are top-level containers for your UI. Import the Window widget and create one:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::Window;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    // Create a window
    let mut window = Window::new("Hello, World!")
        .with_size(400.0, 300.0);

    // Show the window
    window.show();

    app.run()
}</code></pre>
<p>Now when you run the application, you’ll see an empty window titled “Hello, World!” that’s 400x300 pixels.</p>
<h3 id="window-properties"><a class="header" href="#window-properties">Window Properties</a></h3>
<p>Windows support many properties:</p>
<pre><code class="language-rust ignore">let mut window = Window::new("My App")
    .with_size(800.0, 600.0)         // Width x Height
    .with_position(100.0, 100.0)     // X, Y position
    .with_minimum_size(320.0, 240.0) // Minimum allowed size
    .with_flags(WindowFlags::DEFAULT);</code></pre>
<h2 id="step-3-add-a-label"><a class="header" href="#step-3-add-a-label">Step 3: Add a Label</a></h2>
<p>Labels display text. Let’s add one to our window:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{Label, Window};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    // Create a window
    let mut window = Window::new("Hello, World!")
        .with_size(400.0, 300.0);

    // Create a label
    let label = Label::new("Hello, World!");

    // Set the label as the window's content widget
    window.set_content_widget(label.object_id());
    window.show();

    app.run()
}</code></pre>
<p>Run this and you’ll see “Hello, World!” displayed in the window.</p>
<h2 id="step-4-style-the-label"><a class="header" href="#step-4-style-the-label">Step 4: Style the Label</a></h2>
<p>Labels support various styling options:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{Label, Window};
use horizon_lattice::render::{Color, HorizontalAlign, VerticalAlign};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Hello, World!")
        .with_size(400.0, 300.0);

    // Create a styled label
    let label = Label::new("Hello, World!")
        .with_horizontal_align(HorizontalAlign::Center)
        .with_vertical_align(VerticalAlign::Center)
        .with_text_color(Color::from_rgb8(50, 100, 200));

    window.set_content_widget(label.object_id());
    window.show();

    app.run()
}</code></pre>
<p>Now the text is centered and colored blue.</p>
<h3 id="label-options"><a class="header" href="#label-options">Label Options</a></h3>
<p>Labels support many display options:</p>
<pre><code class="language-rust ignore">// Word wrapping for long text
let wrapped = Label::new("This is a very long text that will wrap to multiple lines")
    .with_word_wrap(true);

// Text elision (truncation with "...")
use horizon_lattice::widget::widgets::ElideMode;

let elided = Label::new("very_long_filename_that_doesnt_fit.txt")
    .with_elide_mode(ElideMode::Right);  // Shows "very_long_filen..."

// Rich text with HTML
let rich = Label::from_html("Hello &lt;b&gt;bold&lt;/b&gt; and &lt;i&gt;italic&lt;/i&gt;!");</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Here’s the complete Hello World application:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{Label, Window};
use horizon_lattice::render::{Color, HorizontalAlign, VerticalAlign};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    // Initialize the application
    let app = Application::new()?;

    // Create the main window
    let mut window = Window::new("Hello, World!")
        .with_size(400.0, 300.0);

    // Create a centered, styled label
    let label = Label::new("Hello, Horizon Lattice!")
        .with_horizontal_align(HorizontalAlign::Center)
        .with_vertical_align(VerticalAlign::Center)
        .with_text_color(Color::from_rgb8(50, 100, 200));

    // Set up the window
    window.set_content_widget(label.object_id());
    window.show();

    // Run until window is closed
    app.run()
}</code></pre>
<h2 id="understanding-the-code-1"><a class="header" href="#understanding-the-code-1">Understanding the Code</a></h2>
<h3 id="application-singleton"><a class="header" href="#application-singleton">Application Singleton</a></h3>
<pre><code class="language-rust ignore">let app = Application::new()?;</code></pre>
<p>The <code>Application</code> is a singleton - only one can exist per process. It:</p>
<ul>
<li>Initializes the graphics system (wgpu)</li>
<li>Sets up the event loop (winit)</li>
<li>Registers the main thread for thread-safety checks</li>
<li>Creates the global object registry</li>
</ul>
<h3 id="window-lifecycle"><a class="header" href="#window-lifecycle">Window Lifecycle</a></h3>
<pre><code class="language-rust ignore">let mut window = Window::new("Title")
    .with_size(400.0, 300.0);
window.show();</code></pre>
<p>Windows are created hidden by default. Call <code>show()</code> to make them visible. The builder pattern (<code>with_*</code> methods) allows fluent configuration.</p>
<h3 id="content-widget"><a class="header" href="#content-widget">Content Widget</a></h3>
<pre><code class="language-rust ignore">window.set_content_widget(label.object_id());</code></pre>
<p>Each window has a content widget that fills its content area. You pass the widget’s <code>ObjectId</code> (obtained via <code>object_id()</code>). For more complex UIs, you’ll set a Container with a layout as the content widget.</p>
<h3 id="event-loop"><a class="header" href="#event-loop">Event Loop</a></h3>
<pre><code class="language-rust ignore">app.run()</code></pre>
<p>This starts the event loop, which:</p>
<ul>
<li>Processes user input (mouse, keyboard)</li>
<li>Dispatches signals</li>
<li>Redraws widgets as needed</li>
<li>Handles window management</li>
</ul>
<p>The function blocks until all windows are closed (or <code>app.quit()</code> is called).</p>
<h2 id="run-it-1"><a class="header" href="#run-it-1">Run It</a></h2>
<pre><code class="language-bash">cargo run
</code></pre>
<p>You should see a window with centered blue text saying “Hello, Horizon Lattice!”.</p>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<ul>
<li><a href="#tutorial-button-clicks">Button Clicks</a> - Add interactivity with buttons and signals</li>
<li><a href="#tutorial-forms-and-validation">Forms and Validation</a> - Build input forms with layouts</li>
<li><a href="#basic-concepts">Basic Concepts</a> - Learn about the widget system in depth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial-button-clicks"><a class="header" href="#tutorial-button-clicks">Tutorial: Button Clicks</a></h1>
<p>Learn how to add interactivity with buttons and the signal/slot pattern.</p>
<h2 id="what-youll-learn-1"><a class="header" href="#what-youll-learn-1">What You’ll Learn</a></h2>
<ul>
<li>Creating buttons with PushButton</li>
<li>Connecting to the <code>clicked</code> signal</li>
<li>Handling events with closures</li>
<li>Toggle buttons and state management</li>
<li>Updating UI in response to clicks</li>
</ul>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<ul>
<li>Completed the <a href="#tutorial-hello-world">Hello World</a> tutorial</li>
<li>Understanding of Rust closures</li>
</ul>
<h2 id="step-1-a-simple-clickable-button"><a class="header" href="#step-1-a-simple-clickable-button">Step 1: A Simple Clickable Button</a></h2>
<p>Let’s start with a button that prints a message when clicked:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{PushButton, Window};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Button Click")
        .with_size(400.0, 300.0);

    // Create a button
    let button = PushButton::new("Click me!");

    // Connect to the clicked signal
    button.clicked().connect(|&amp;checked| {
        println!("Button clicked! Checked: {}", checked);
    });

    window.set_content_widget(button.object_id());
    window.show();

    app.run()
}</code></pre>
<p>Run this and click the button - you’ll see “Button clicked! Checked: false” printed to the console.</p>
<h2 id="understanding-signals"><a class="header" href="#understanding-signals">Understanding Signals</a></h2>
<p>Signals are Horizon Lattice’s way of communicating events. They’re inspired by Qt’s signal/slot mechanism but are fully type-safe at compile time.</p>
<h3 id="the-clicked-signal"><a class="header" href="#the-clicked-signal">The <code>clicked</code> Signal</a></h3>
<pre><code class="language-rust ignore">// The clicked signal carries a bool indicating checked state
button.clicked().connect(|&amp;checked: &amp;bool| {
    // `checked` is false for normal buttons
    // `checked` is true/false for toggle buttons
});</code></pre>
<h3 id="available-button-signals"><a class="header" href="#available-button-signals">Available Button Signals</a></h3>
<p>PushButton provides four signals:</p>
<pre><code class="language-rust ignore">// Emitted when button is clicked (completed press + release)
button.clicked().connect(|&amp;checked| { /* ... */ });

// Emitted when mouse button is pressed down
button.pressed().connect(|&amp;()| { /* ... */ });

// Emitted when mouse button is released
button.released().connect(|&amp;()| { /* ... */ });

// Emitted when checked state changes (toggle buttons only)
button.toggled().connect(|&amp;checked| { /* ... */ });</code></pre>
<h2 id="step-2-toggle-buttons"><a class="header" href="#step-2-toggle-buttons">Step 2: Toggle Buttons</a></h2>
<p>Toggle buttons maintain a checked/unchecked state:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{PushButton, Window};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Toggle Button")
        .with_size(400.0, 300.0);

    // Create a toggle button
    let toggle = PushButton::new("Toggle me")
        .with_checkable(true);

    // React to toggle state changes
    toggle.toggled().connect(|&amp;checked| {
        if checked {
            println!("Toggle is ON");
        } else {
            println!("Toggle is OFF");
        }
    });

    window.set_content_widget(toggle.object_id());
    window.show();

    app.run()
}</code></pre>
<p>The button visually changes when toggled, and you can query its state with <code>is_checked()</code>.</p>
<h2 id="step-3-updating-a-label-from-a-button"><a class="header" href="#step-3-updating-a-label-from-a-button">Step 3: Updating a Label from a Button</a></h2>
<p>To update UI elements from a signal handler, you need to share state. Use <code>Arc</code> for thread-safe sharing:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{Label, PushButton, Container, Window};
use horizon_lattice::widget::layout::{VBoxLayout, LayoutKind};
use std::sync::Arc;
use std::sync::atomic::{AtomicU32, Ordering};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Counter")
        .with_size(300.0, 200.0);

    // Shared counter state
    let count = Arc::new(AtomicU32::new(0));

    // Create widgets
    let label = Label::new("Count: 0");
    let button = PushButton::new("Increment");

    // Connect button to update label
    let label_clone = label.clone();
    let count_clone = count.clone();
    button.clicked().connect(move |_| {
        let new_count = count_clone.fetch_add(1, Ordering::SeqCst) + 1;
        label_clone.set_text(&amp;format!("Count: {}", new_count));
    });

    // Layout the widgets vertically
    let mut layout = VBoxLayout::new();
    layout.add_widget(label.object_id());
    layout.add_widget(button.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h3 id="key-concepts"><a class="header" href="#key-concepts">Key Concepts</a></h3>
<ol>
<li><strong>Clone before <code>move</code></strong>: Clone <code>label</code> and <code>count</code> before using in the closure</li>
<li><strong><code>move</code> closure</strong>: Takes ownership of cloned values</li>
<li><strong>Thread-safe state</strong>: Use <code>AtomicU32</code> (or <code>Mutex</code> for complex state)</li>
</ol>
<h2 id="step-4-multiple-buttons"><a class="header" href="#step-4-multiple-buttons">Step 4: Multiple Buttons</a></h2>
<p>Handle multiple buttons with different actions:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{Label, PushButton, Container, Window};
use horizon_lattice::widget::layout::{HBoxLayout, LayoutKind};
use std::sync::Arc;
use std::sync::atomic::{AtomicI32, Ordering};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Counter")
        .with_size(300.0, 150.0);

    let count = Arc::new(AtomicI32::new(0));

    let label = Label::new("0");
    let decrement = PushButton::new("-");
    let increment = PushButton::new("+");

    // Decrement button
    let label_clone = label.clone();
    let count_clone = count.clone();
    decrement.clicked().connect(move |_| {
        let new_value = count_clone.fetch_sub(1, Ordering::SeqCst) - 1;
        label_clone.set_text(&amp;new_value.to_string());
    });

    // Increment button
    let label_clone = label.clone();
    let count_clone = count.clone();
    increment.clicked().connect(move |_| {
        let new_value = count_clone.fetch_add(1, Ordering::SeqCst) + 1;
        label_clone.set_text(&amp;new_value.to_string());
    });

    // Horizontal layout: [-] [0] [+]
    let mut layout = HBoxLayout::new();
    layout.add_widget(decrement.object_id());
    layout.add_widget(label.object_id());
    layout.add_widget(increment.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="step-5-button-variants"><a class="header" href="#step-5-button-variants">Step 5: Button Variants</a></h2>
<p>PushButton supports different visual styles:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{PushButton, ButtonVariant};

// Primary (default) - filled with primary color
let primary = PushButton::new("Primary");

// Secondary - outlined with primary color
let secondary = PushButton::new("Secondary")
    .with_variant(ButtonVariant::Secondary);

// Danger - filled with error/red color
let danger = PushButton::new("Delete")
    .with_variant(ButtonVariant::Danger);

// Flat - text only, no background
let flat = PushButton::new("Cancel")
    .with_variant(ButtonVariant::Flat);

// Outlined - outlined with neutral border
let outlined = PushButton::new("Options")
    .with_variant(ButtonVariant::Outlined);</code></pre>
<h2 id="step-6-default-button"><a class="header" href="#step-6-default-button">Step 6: Default Button</a></h2>
<p>Mark a button as the “default” to activate it with Enter key:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::PushButton;

let ok_button = PushButton::new("OK")
    .with_default(true);

let cancel_button = PushButton::new("Cancel");</code></pre>
<p>The default button:</p>
<ul>
<li>Has enhanced visual styling (prominent border)</li>
<li>Activates when Enter is pressed anywhere in the window</li>
</ul>
<h2 id="complete-example-interactive-counter"><a class="header" href="#complete-example-interactive-counter">Complete Example: Interactive Counter</a></h2>
<p>Here’s a polished counter application:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    Label, PushButton, Container, Window, ButtonVariant
};
use horizon_lattice::widget::layout::{HBoxLayout, VBoxLayout, ContentMargins, LayoutKind};
use horizon_lattice::render::{HorizontalAlign, VerticalAlign};
use std::sync::Arc;
use std::sync::atomic::{AtomicI32, Ordering};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Counter App")
        .with_size(300.0, 200.0);

    // Shared state
    let count = Arc::new(AtomicI32::new(0));

    // Title label
    let title = Label::new("Interactive Counter")
        .with_horizontal_align(HorizontalAlign::Center);

    // Count display
    let display = Label::new("0")
        .with_horizontal_align(HorizontalAlign::Center)
        .with_vertical_align(VerticalAlign::Center);

    // Buttons
    let decrement = PushButton::new("-5")
        .with_variant(ButtonVariant::Secondary);
    let increment = PushButton::new("+5");
    let reset = PushButton::new("Reset")
        .with_variant(ButtonVariant::Danger);

    // Connect decrement
    let display_clone = display.clone();
    let count_clone = count.clone();
    decrement.clicked().connect(move |_| {
        let new_value = count_clone.fetch_sub(5, Ordering::SeqCst) - 5;
        display_clone.set_text(&amp;new_value.to_string());
    });

    // Connect increment
    let display_clone = display.clone();
    let count_clone = count.clone();
    increment.clicked().connect(move |_| {
        let new_value = count_clone.fetch_add(5, Ordering::SeqCst) + 5;
        display_clone.set_text(&amp;new_value.to_string());
    });

    // Connect reset
    let display_clone = display.clone();
    let count_clone = count.clone();
    reset.clicked().connect(move |_| {
        count_clone.store(0, Ordering::SeqCst);
        display_clone.set_text("0");
    });

    // Button row layout
    let mut button_row = HBoxLayout::new();
    button_row.set_spacing(10.0);
    button_row.add_widget(decrement.object_id());
    button_row.add_widget(increment.object_id());

    let mut button_container = Container::new();
    button_container.set_layout(LayoutKind::from(button_row));

    // Main vertical layout
    let mut main_layout = VBoxLayout::new();
    main_layout.set_spacing(15.0);
    main_layout.set_content_margins(ContentMargins::uniform(20.0));
    main_layout.add_widget(title.object_id());
    main_layout.add_widget(display.object_id());
    main_layout.add_widget(button_container.object_id());
    main_layout.add_widget(reset.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(main_layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="signal-connection-types"><a class="header" href="#signal-connection-types">Signal Connection Types</a></h2>
<p>For advanced use cases, you can specify connection types:</p>
<pre><code class="language-rust ignore">use horizon_lattice::ConnectionType;

// Direct: immediate execution (default, same thread only)
button.clicked().connect_with_type(ConnectionType::Direct, |_| {
    // Runs immediately when signal emits
});

// Queued: deferred to event loop (thread-safe)
button.clicked().connect_with_type(ConnectionType::Queued, |_| {
    // Runs on the main thread via event loop
});

// Auto: automatically chooses based on context (recommended)
button.clicked().connect_with_type(ConnectionType::Auto, |_| {
    // Direct if same thread, Queued if cross-thread
});</code></pre>
<h2 id="disconnecting-signals"><a class="header" href="#disconnecting-signals">Disconnecting Signals</a></h2>
<p>Save the connection ID to disconnect later:</p>
<pre><code class="language-rust ignore">// Connect and save the ID
let connection_id = button.clicked().connect(|_| {
    println!("Connected!");
});

// Later, disconnect
button.clicked().disconnect(connection_id);</code></pre>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><a href="#tutorial-forms-and-validation">Forms and Validation</a> - Build input forms with multiple widgets</li>
<li><a href="#signals-and-slots-guide">Signals Guide</a> - Deep dive into the signal system</li>
<li><a href="#layouts-guide">Layouts Guide</a> - Learn about layout management</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial-forms-and-validation"><a class="header" href="#tutorial-forms-and-validation">Tutorial: Forms and Validation</a></h1>
<p>Learn to build input forms with validation and proper layout.</p>
<h2 id="what-youll-learn-2"><a class="header" href="#what-youll-learn-2">What You’ll Learn</a></h2>
<ul>
<li>Using input widgets (LineEdit, CheckBox, ComboBox, SpinBox)</li>
<li>Organizing forms with FormLayout</li>
<li>Input validation patterns</li>
<li>Collecting and processing form data</li>
</ul>
<h2 id="prerequisites-2"><a class="header" href="#prerequisites-2">Prerequisites</a></h2>
<ul>
<li>Completed the <a href="#tutorial-button-clicks">Button Clicks</a> tutorial</li>
<li>Understanding of layouts from <a href="#layouts-guide">Layouts Guide</a></li>
</ul>
<h2 id="step-1-text-input-with-lineedit"><a class="header" href="#step-1-text-input-with-lineedit">Step 1: Text Input with LineEdit</a></h2>
<p>LineEdit is for single-line text input:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{LineEdit, Label, Container, Window};
use horizon_lattice::widget::layout::{VBoxLayout, LayoutKind};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Text Input")
        .with_size(400.0, 200.0);

    // Create a text input
    let mut name_input = LineEdit::new();
    name_input.set_placeholder("Enter your name...");

    // React to text changes
    name_input.text_changed.connect(|text| {
        println!("Text changed: {}", text);
    });

    // React to Enter key
    name_input.return_pressed.connect(|| {
        println!("Enter pressed!");
    });

    let label = Label::new("Name:");

    let mut layout = VBoxLayout::new();
    layout.add_widget(label.object_id());
    layout.add_widget(name_input.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h3 id="lineedit-features"><a class="header" href="#lineedit-features">LineEdit Features</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{LineEdit, EchoMode};

// Password field
let mut password = LineEdit::new()
    .with_echo_mode(EchoMode::Password);

// With initial text
let mut edit = LineEdit::with_text("Initial value");

// Read-only field
let mut display = LineEdit::new();
display.set_read_only(true);
display.set_text("Cannot edit this");

// With maximum length
let mut short = LineEdit::new();
short.set_max_length(Some(10));

// With clear button
let mut searchbox = LineEdit::new();
searchbox.set_clear_button(true);
searchbox.set_placeholder("Search...");</code></pre>
<h3 id="lineedit-signals"><a class="header" href="#lineedit-signals">LineEdit Signals</a></h3>
<pre><code class="language-rust ignore">// Text changed (after validation passes)
edit.text_changed.connect(|text| { /* ... */ });

// Text edited (before validation, raw input)
edit.text_edited.connect(|text| { /* ... */ });

// Enter/Return key pressed
edit.return_pressed.connect(|| { /* ... */ });

// Focus lost or Enter pressed
edit.editing_finished.connect(|| { /* ... */ });

// Clear button clicked
edit.cleared.connect(|| { /* ... */ });

// Input rejected by validator
edit.input_rejected.connect(|| { /* ... */ });</code></pre>
<h2 id="step-2-checkboxes"><a class="header" href="#step-2-checkboxes">Step 2: Checkboxes</a></h2>
<p>CheckBox provides binary or tri-state selection:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{CheckBox, CheckState, Label, Container, Window};
use horizon_lattice::widget::layout::{VBoxLayout, LayoutKind};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Checkboxes")
        .with_size(300.0, 200.0);

    // Simple checkbox
    let terms = CheckBox::new("I accept the terms and conditions");

    // Pre-checked checkbox
    let newsletter = CheckBox::new("Subscribe to newsletter")
        .with_checked(true);

    // React to state changes
    terms.state_changed().connect(|&amp;state| {
        match state {
            CheckState::Checked =&gt; println!("Terms accepted"),
            CheckState::Unchecked =&gt; println!("Terms declined"),
            CheckState::PartiallyChecked =&gt; println!("Partial"),
        }
    });

    // Boolean signal (simpler)
    newsletter.toggled().connect(|&amp;checked| {
        println!("Newsletter: {}", if checked { "yes" } else { "no" });
    });

    let mut layout = VBoxLayout::new();
    layout.add_widget(terms.object_id());
    layout.add_widget(newsletter.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h3 id="tri-state-checkboxes"><a class="header" href="#tri-state-checkboxes">Tri-State Checkboxes</a></h3>
<p>For “select all” patterns:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{CheckBox, CheckState};

// Enable tri-state mode
let mut select_all = CheckBox::new("Select all")
    .with_tri_state(true);

// Set partial state (e.g., when some children are checked)
select_all.set_check_state(CheckState::PartiallyChecked);

// State cycles: Unchecked -&gt; Checked -&gt; PartiallyChecked -&gt; Unchecked
select_all.toggle();</code></pre>
<h2 id="step-3-dropdown-selection-with-combobox"><a class="header" href="#step-3-dropdown-selection-with-combobox">Step 3: Dropdown Selection with ComboBox</a></h2>
<p>ComboBox provides dropdown selection:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{ComboBox, Label, Container, Window};
use horizon_lattice::widget::layout::{VBoxLayout, LayoutKind};
use horizon_lattice::model::StringListComboModel;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Dropdown")
        .with_size(300.0, 200.0);

    // Create model with items
    let countries = vec!["United States", "Canada", "Mexico", "United Kingdom"];
    let model = StringListComboModel::from(countries);

    // Create combo box
    let mut combo = ComboBox::new()
        .with_model(Box::new(model));

    // Set default selection
    combo.set_current_index(0);

    // React to selection changes
    combo.current_index_changed.connect(|&amp;index| {
        println!("Selected index: {}", index);
    });

    combo.current_text_changed.connect(|text| {
        println!("Selected: {}", text);
    });

    let label = Label::new("Country:");

    let mut layout = VBoxLayout::new();
    layout.add_widget(label.object_id());
    layout.add_widget(combo.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h3 id="editable-combobox"><a class="header" href="#editable-combobox">Editable ComboBox</a></h3>
<p>Allow typing to filter or enter custom values:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::ComboBox;
use horizon_lattice::model::StringListComboModel;

let fruits = vec!["Apple", "Apricot", "Avocado", "Banana", "Blueberry"];
let model = StringListComboModel::from(fruits);

let mut combo = ComboBox::new()
    .with_model(Box::new(model))
    .with_editable(true)
    .with_placeholder("Type to filter...");

// Typing "Ap" filters to: Apple, Apricot
// User can also enter a custom value not in the list</code></pre>
<h3 id="combobox-methods"><a class="header" href="#combobox-methods">ComboBox Methods</a></h3>
<pre><code class="language-rust ignore">// Get current selection
let index = combo.current_index();  // -1 if nothing selected
let text = combo.current_text();

// Set selection
combo.set_current_index(2);
combo.set_current_text("Canada");

// Find item
if let Some(idx) = combo.find_text("Mexico") {
    combo.set_current_index(idx as i32);
}

// Item count
let count = combo.count();

// Popup control
combo.show_popup();
combo.hide_popup();</code></pre>
<h2 id="step-4-numeric-input-with-spinbox"><a class="header" href="#step-4-numeric-input-with-spinbox">Step 4: Numeric Input with SpinBox</a></h2>
<p>SpinBox is for integer input with increment/decrement:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{SpinBox, Label, Container, Window};
use horizon_lattice::widget::layout::{VBoxLayout, LayoutKind};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Numeric Input")
        .with_size(300.0, 200.0);

    // Create a spinbox with range
    let mut age = SpinBox::new()
        .with_range(0, 120)
        .with_value(25)
        .with_single_step(1);

    // React to value changes
    age.value_changed.connect(|&amp;value| {
        println!("Age: {}", value);
    });

    let label = Label::new("Age:");

    let mut layout = VBoxLayout::new();
    layout.add_widget(label.object_id());
    layout.add_widget(age.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h3 id="spinbox-features"><a class="header" href="#spinbox-features">SpinBox Features</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::SpinBox;

// With prefix and suffix
let mut price = SpinBox::new()
    .with_range(0, 9999)
    .with_prefix("$")
    .with_suffix(".00");

// With special value text (shown at minimum)
let mut quantity = SpinBox::new()
    .with_range(0, 100)
    .with_special_value_text("Auto");  // Shows "Auto" when value is 0

// Wrapping (loops from max to min)
let mut hour = SpinBox::new()
    .with_range(0, 23)
    .with_wrapping(true);  // 23 + 1 = 0

// Larger step size
let mut percent = SpinBox::new()
    .with_range(0, 100)
    .with_single_step(5)
    .with_suffix("%");

// With acceleration on hold
let mut fast = SpinBox::new()
    .with_range(0, 1000)
    .with_acceleration(true);</code></pre>
<h2 id="step-5-formlayout"><a class="header" href="#step-5-formlayout">Step 5: FormLayout</a></h2>
<p>FormLayout automatically aligns label-field pairs:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    Label, LineEdit, SpinBox, CheckBox, ComboBox, PushButton, Container, Window
};
use horizon_lattice::widget::layout::{FormLayout, FieldGrowthPolicy, Alignment, LayoutKind};
use horizon_lattice::model::StringListComboModel;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Registration Form")
        .with_size(400.0, 350.0);

    // Create labels
    let name_label = Label::new("Full Name:");
    let email_label = Label::new("Email:");
    let age_label = Label::new("Age:");
    let country_label = Label::new("Country:");
    let subscribe_label = Label::new("Newsletter:");

    // Create fields
    let mut name_field = LineEdit::new();
    name_field.set_placeholder("Enter your name");

    let mut email_field = LineEdit::new();
    email_field.set_placeholder("user@example.com");

    let age_field = SpinBox::new()
        .with_range(13, 120)
        .with_value(18);

    let countries = vec!["United States", "Canada", "Mexico", "Other"];
    let country_model = StringListComboModel::from(countries);
    let mut country_field = ComboBox::new()
        .with_model(Box::new(country_model));
    country_field.set_current_index(0);

    let subscribe_field = CheckBox::new("Yes, send me updates");

    // Create form layout
    let mut form = FormLayout::new();

    // Add label-field pairs
    form.add_row(name_label.object_id(), name_field.object_id());
    form.add_row(email_label.object_id(), email_field.object_id());
    form.add_row(age_label.object_id(), age_field.object_id());
    form.add_row(country_label.object_id(), country_field.object_id());
    form.add_row(subscribe_label.object_id(), subscribe_field.object_id());

    // Configure layout
    form.set_label_alignment(Alignment::End);  // Right-align labels
    form.set_field_growth_policy(FieldGrowthPolicy::AllNonFixedFieldsGrow);
    form.set_horizontal_spacing(12.0);
    form.set_vertical_spacing(10.0);

    // Add submit button spanning full width
    let submit = PushButton::new("Register");
    form.add_spanning_widget(submit.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(form));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h3 id="formlayout-configuration"><a class="header" href="#formlayout-configuration">FormLayout Configuration</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{FormLayout, FieldGrowthPolicy, RowWrapPolicy, Alignment};

let mut form = FormLayout::new();

// Label alignment
form.set_label_alignment(Alignment::Start);  // Left-align (Windows style)
form.set_label_alignment(Alignment::End);    // Right-align (macOS style)

// Field growth policy
form.set_field_growth_policy(FieldGrowthPolicy::FieldsStayAtSizeHint);  // Fixed width
form.set_field_growth_policy(FieldGrowthPolicy::ExpandingFieldsGrow);   // Only Expanding fields grow
form.set_field_growth_policy(FieldGrowthPolicy::AllNonFixedFieldsGrow); // All non-Fixed grow

// Row wrapping (for narrow windows)
form.set_row_wrap_policy(RowWrapPolicy::DontWrapRows);  // Label beside field
form.set_row_wrap_policy(RowWrapPolicy::WrapAllRows);   // Label above field

// Spacing
form.set_horizontal_spacing(12.0);  // Between label and field
form.set_vertical_spacing(8.0);     // Between rows</code></pre>
<h2 id="step-6-input-validation"><a class="header" href="#step-6-input-validation">Step 6: Input Validation</a></h2>
<p>Use validators to constrain input:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::LineEdit;
use horizon_lattice::widget::validator::{IntValidator, DoubleValidator, RegexValidator};
use std::sync::Arc;

// Integer validator (e.g., for age 0-150)
let mut age_input = LineEdit::new();
age_input.set_validator(Arc::new(IntValidator::new(0, 150)));

// Double validator (e.g., for price with 2 decimals)
let mut price_input = LineEdit::new();
price_input.set_validator(Arc::new(DoubleValidator::new(0.0, 9999.99, 2)));

// Regex validator (e.g., for email pattern)
let mut email_input = LineEdit::new();
email_input.set_validator(Arc::new(RegexValidator::new(
    r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
)));

// Handle rejected input
age_input.input_rejected.connect(|| {
    println!("Invalid age entered!");
});</code></pre>
<h3 id="validation-states"><a class="header" href="#validation-states">Validation States</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::widget::validator::ValidationState;

// ValidationState::Invalid      - Clearly wrong (e.g., "abc" for number)
// ValidationState::Intermediate - Could become valid (e.g., "" or "-")
// ValidationState::Acceptable   - Valid input</code></pre>
<h2 id="step-7-input-masks"><a class="header" href="#step-7-input-masks">Step 7: Input Masks</a></h2>
<p>For formatted input like phone numbers:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::LineEdit;

// Phone number: (999) 999-9999
let mut phone = LineEdit::new();
phone.set_input_mask("(999) 999-9999");

// Date: YYYY-MM-DD
let mut date = LineEdit::new();
date.set_input_mask("0000-00-00");

// Time: HH:MM:SS
let mut time = LineEdit::new();
time.set_input_mask("99:99:99");

// License key (uppercase)
let mut license = LineEdit::new();
license.set_input_mask("&gt;AAAAA-AAAAA-AAAAA");</code></pre>
<h3 id="mask-characters"><a class="header" href="#mask-characters">Mask Characters</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Character</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>9</code></td><td>Digit required (0-9)</td></tr>
<tr><td><code>0</code></td><td>Digit optional</td></tr>
<tr><td><code>A</code></td><td>Letter required (a-z, A-Z)</td></tr>
<tr><td><code>a</code></td><td>Letter optional</td></tr>
<tr><td><code>N</code></td><td>Alphanumeric required</td></tr>
<tr><td><code>n</code></td><td>Alphanumeric optional</td></tr>
<tr><td><code>X</code></td><td>Any character required</td></tr>
<tr><td><code>x</code></td><td>Any character optional</td></tr>
<tr><td><code>&gt;</code></td><td>Uppercase following</td></tr>
<tr><td><code>&lt;</code></td><td>Lowercase following</td></tr>
<tr><td><code>\</code></td><td>Escape next character</td></tr>
</tbody>
</table>
</div>
<h2 id="complete-example-contact-form"><a class="header" href="#complete-example-contact-form">Complete Example: Contact Form</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    Label, LineEdit, SpinBox, CheckBox, ComboBox, PushButton,
    Container, Window, ButtonVariant
};
use horizon_lattice::widget::layout::{
    FormLayout, VBoxLayout, HBoxLayout, ContentMargins,
    FieldGrowthPolicy, Alignment, LayoutKind
};
use horizon_lattice::widget::validator::RegexValidator;
use horizon_lattice::model::StringListComboModel;
use std::sync::Arc;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Contact Form")
        .with_size(450.0, 400.0);

    // --- Create form fields ---

    // Name (required)
    let name_label = Label::new("Name: *");
    let mut name_field = LineEdit::new();
    name_field.set_placeholder("Your full name");

    // Email (with validation)
    let email_label = Label::new("Email: *");
    let mut email_field = LineEdit::new();
    email_field.set_placeholder("user@example.com");
    email_field.set_validator(Arc::new(RegexValidator::new(
        r"^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$"
    )));

    // Phone (with mask)
    let phone_label = Label::new("Phone:");
    let mut phone_field = LineEdit::new();
    phone_field.set_input_mask("(999) 999-9999");

    // Age
    let age_label = Label::new("Age:");
    let age_field = SpinBox::new()
        .with_range(13, 120)
        .with_value(25);

    // Subject dropdown
    let subject_label = Label::new("Subject: *");
    let subjects = vec!["General Inquiry", "Support", "Feedback", "Other"];
    let subject_model = StringListComboModel::from(subjects);
    let mut subject_field = ComboBox::new()
        .with_model(Box::new(subject_model));
    subject_field.set_current_index(0);

    // Urgent checkbox
    let urgent_label = Label::new("Priority:");
    let urgent_field = CheckBox::new("Mark as urgent");

    // Newsletter checkbox
    let newsletter_label = Label::new("Updates:");
    let newsletter_field = CheckBox::new("Subscribe to newsletter")
        .with_checked(true);

    // --- Create form layout ---

    let mut form = FormLayout::new();
    form.set_label_alignment(Alignment::End);
    form.set_field_growth_policy(FieldGrowthPolicy::AllNonFixedFieldsGrow);
    form.set_horizontal_spacing(12.0);
    form.set_vertical_spacing(10.0);

    form.add_row(name_label.object_id(), name_field.object_id());
    form.add_row(email_label.object_id(), email_field.object_id());
    form.add_row(phone_label.object_id(), phone_field.object_id());
    form.add_row(age_label.object_id(), age_field.object_id());
    form.add_row(subject_label.object_id(), subject_field.object_id());
    form.add_row(urgent_label.object_id(), urgent_field.object_id());
    form.add_row(newsletter_label.object_id(), newsletter_field.object_id());

    // --- Create buttons ---

    let submit = PushButton::new("Submit")
        .with_default(true);
    let clear = PushButton::new("Clear")
        .with_variant(ButtonVariant::Secondary);
    let cancel = PushButton::new("Cancel")
        .with_variant(ButtonVariant::Flat);

    // --- Connect signals ---

    // Clone widgets for closures
    let name_clone = name_field.clone();
    let email_clone = email_field.clone();
    let phone_clone = phone_field.clone();
    let age_clone = age_field.clone();
    let subject_clone = subject_field.clone();
    let urgent_clone = urgent_field.clone();
    let newsletter_clone = newsletter_field.clone();

    submit.clicked().connect(move |_| {
        println!("=== Form Submitted ===");
        println!("Name: {}", name_clone.text());
        println!("Email: {}", email_clone.text());
        println!("Phone: {}", phone_clone.text());
        println!("Age: {}", age_clone.value());
        println!("Subject: {}", subject_clone.current_text());
        println!("Urgent: {}", urgent_clone.is_checked());
        println!("Newsletter: {}", newsletter_clone.is_checked());
    });

    // Clone for clear button
    let name_clear = name_field.clone();
    let email_clear = email_field.clone();
    let phone_clear = phone_field.clone();

    clear.clicked().connect(move |_| {
        name_clear.set_text("");
        email_clear.set_text("");
        phone_clear.set_text("");
    });

    cancel.clicked().connect(|_| {
        println!("Cancelled");
        Application::instance().quit();
    });

    // Email validation feedback
    email_field.input_rejected.connect(|| {
        println!("Invalid email format!");
    });

    // --- Button layout ---

    let mut button_row = HBoxLayout::new();
    button_row.set_spacing(10.0);
    button_row.add_stretch(1);  // Push buttons to right
    button_row.add_widget(cancel.object_id());
    button_row.add_widget(clear.object_id());
    button_row.add_widget(submit.object_id());

    let mut button_container = Container::new();
    button_container.set_layout(LayoutKind::from(button_row));

    // --- Main layout ---

    let mut main_layout = VBoxLayout::new();
    main_layout.set_content_margins(ContentMargins::uniform(20.0));
    main_layout.set_spacing(20.0);

    let mut form_container = Container::new();
    form_container.set_layout(LayoutKind::from(form));

    main_layout.add_widget(form_container.object_id());
    main_layout.add_widget(button_container.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(main_layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<ol>
<li><strong>Use FormLayout for forms</strong> - Automatically handles label alignment</li>
<li><strong>Add placeholders</strong> - Help users understand expected input</li>
<li><strong>Validate early</strong> - Use validators to prevent invalid data entry</li>
<li><strong>Provide feedback</strong> - Connect to <code>input_rejected</code> to show validation errors</li>
<li><strong>Mark required fields</strong> - Use asterisks or other visual indicators</li>
<li><strong>Group related fields</strong> - Use nested layouts or separators</li>
<li><strong>Default sensible values</strong> - Pre-fill spinboxes and comboboxes</li>
<li><strong>Use appropriate widgets</strong> - SpinBox for numbers, ComboBox for fixed choices</li>
</ol>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><a href="#tutorial-lists-and-models">Lists and Models</a> - Work with list views and data models</li>
<li><a href="#tutorial-custom-widgets">Custom Widgets</a> - Create your own widgets</li>
<li><a href="#widgets-guide">Widgets Guide</a> - Deep dive into the widget system</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial-lists-and-models"><a class="header" href="#tutorial-lists-and-models">Tutorial: Lists and Models</a></h1>
<p>Learn the Model/View architecture for displaying collections of data.</p>
<h2 id="what-youll-learn-3"><a class="header" href="#what-youll-learn-3">What You’ll Learn</a></h2>
<ul>
<li>Understanding the Model/View pattern</li>
<li>Creating list models</li>
<li>Displaying data in ListView</li>
<li>Handling item selection</li>
<li>Dynamic item operations (add, remove, modify)</li>
</ul>
<h2 id="prerequisites-3"><a class="header" href="#prerequisites-3">Prerequisites</a></h2>
<ul>
<li>Completed the <a href="#tutorial-forms-and-validation">Forms</a> tutorial</li>
<li>Understanding of Rust traits</li>
</ul>
<h2 id="the-modelview-architecture"><a class="header" href="#the-modelview-architecture">The Model/View Architecture</a></h2>
<p>Horizon Lattice separates data (Model) from presentation (View):</p>
<ul>
<li><strong>Model</strong>: Holds the data and emits change signals</li>
<li><strong>View</strong>: Displays the data and handles user interaction</li>
<li><strong>Selection Model</strong>: Tracks which items are selected</li>
</ul>
<p>This separation allows:</p>
<ul>
<li>Multiple views of the same data</li>
<li>Efficient updates (only changed items redraw)</li>
<li>Reusable views with different data sources</li>
</ul>
<h2 id="step-1-using-listwidget-simple-approach"><a class="header" href="#step-1-using-listwidget-simple-approach">Step 1: Using ListWidget (Simple Approach)</a></h2>
<p>For simple lists, <code>ListWidget</code> manages its own data:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{ListWidget, Window};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Simple List")
        .with_size(300.0, 400.0);

    // Create list widget with items
    let mut list = ListWidget::new();
    list.add_item("Apple");
    list.add_item("Banana");
    list.add_item("Cherry");
    list.add_item("Date");
    list.add_item("Elderberry");

    // Handle item clicks
    list.item_clicked.connect(|&amp;row| {
        println!("Clicked row: {}", row);
    });

    // Handle selection changes
    list.current_row_changed.connect(|(old, new)| {
        println!("Selection changed from {:?} to {:?}", old, new);
    });

    window.set_content_widget(list.object_id());
    window.show();

    app.run()
}</code></pre>
<h3 id="listwidget-operations"><a class="header" href="#listwidget-operations">ListWidget Operations</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::ListWidget;

let mut list = ListWidget::new();

// Add items
list.add_item("Item 1");
list.add_item("Item 2");

// Insert at specific position
list.insert_item(1, "Inserted Item");

// Remove item
let removed = list.take_item(0);

// Clear all items
list.clear();

// Get current selection
let current_row = list.current_row();

// Set selection programmatically
list.set_current_row(Some(2));

// Get item count
let count = list.count();</code></pre>
<h2 id="step-2-listview-with-listmodel"><a class="header" href="#step-2-listview-with-listmodel">Step 2: ListView with ListModel</a></h2>
<p>For more control, use <code>ListView</code> with a separate <code>ListModel</code>:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{ListView, Window};
use horizon_lattice::model::{ListModel, ListItem, ItemData};

// Define your data item
#[derive(Clone)]
struct Fruit {
    name: String,
    color: String,
}

// Implement ListItem to tell the model how to display it
impl ListItem for Fruit {
    fn display(&amp;self) -&gt; ItemData {
        ItemData::from(&amp;self.name)
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Fruit List")
        .with_size(300.0, 400.0);

    // Create model with data
    let model = ListModel::new(vec![
        Fruit { name: "Apple".into(), color: "Red".into() },
        Fruit { name: "Banana".into(), color: "Yellow".into() },
        Fruit { name: "Grape".into(), color: "Purple".into() },
    ]);

    // Create view with model
    let list_view = ListView::new()
        .with_model(model);

    // Handle clicks
    list_view.clicked.connect(|index| {
        println!("Clicked row: {}", index.row());
    });

    // Handle double-clicks
    list_view.double_clicked.connect(|index| {
        println!("Double-clicked row: {}", index.row());
    });

    window.set_content_widget(list_view.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="step-3-custom-data-display"><a class="header" href="#step-3-custom-data-display">Step 3: Custom Data Display</a></h2>
<p>Use a closure-based extractor for complex display logic:</p>
<pre><code class="language-rust ignore">use horizon_lattice::model::{ListModel, ItemData, ItemRole};

#[derive(Clone)]
struct Contact {
    name: String,
    email: String,
    phone: String,
}

// Create model with custom data extraction
let model = ListModel::with_extractor(
    vec![
        Contact {
            name: "Alice".into(),
            email: "alice@example.com".into(),
            phone: "555-1234".into(),
        },
        Contact {
            name: "Bob".into(),
            email: "bob@example.com".into(),
            phone: "555-5678".into(),
        },
    ],
    |contact, role| match role {
        ItemRole::Display =&gt; ItemData::from(&amp;contact.name),
        ItemRole::ToolTip =&gt; ItemData::from(format!("{}\n{}", contact.email, contact.phone)),
        _ =&gt; ItemData::None,
    },
);</code></pre>
<h3 id="item-roles"><a class="header" href="#item-roles">Item Roles</a></h3>
<p>Different roles provide different aspects of item data:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Role</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>Display</code></td><td>Main text to show</td></tr>
<tr><td><code>Decoration</code></td><td>Icon or image</td></tr>
<tr><td><code>ToolTip</code></td><td>Hover tooltip text</td></tr>
<tr><td><code>Edit</code></td><td>Value for editing</td></tr>
<tr><td><code>CheckState</code></td><td>Checkbox state</td></tr>
<tr><td><code>BackgroundColor</code></td><td>Background color</td></tr>
<tr><td><code>ForegroundColor</code></td><td>Text color</td></tr>
<tr><td><code>Font</code></td><td>Custom font</td></tr>
</tbody>
</table>
</div>
<h2 id="step-4-selection-handling"><a class="header" href="#step-4-selection-handling">Step 4: Selection Handling</a></h2>
<p>Control how users select items:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::ListView;
use horizon_lattice::model::{SelectionMode, SelectionFlags};

let mut list_view = ListView::new()
    .with_model(model)
    .with_selection_mode(SelectionMode::ExtendedSelection);

// Selection modes:
// - NoSelection: Nothing selectable
// - SingleSelection: One item at a time
// - MultiSelection: Ctrl+click for multiple
// - ExtendedSelection: Shift+click for ranges + Ctrl+click

// Get the selection model
let selection = list_view.selection_model();

// Listen for selection changes
selection.selection_changed.connect(|(selected, deselected)| {
    println!("Selection changed!");
    for idx in &amp;selected {
        println!("  Selected: row {}", idx.row());
    }
    for idx in &amp;deselected {
        println!("  Deselected: row {}", idx.row());
    }
});

// Listen for current item changes
selection.current_changed.connect(|(new_index, old_index)| {
    println!("Current changed from {:?} to {:?}",
        old_index.map(|i| i.row()),
        new_index.map(|i| i.row())
    );
});</code></pre>
<h3 id="programmatic-selection"><a class="header" href="#programmatic-selection">Programmatic Selection</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::model::{ModelIndex, SelectionFlags};

let selection = list_view.selection_model();

// Select a single item
let index = ModelIndex::new(2, 0);  // Row 2, Column 0
selection.select(index, SelectionFlags::CLEAR_SELECT_CURRENT);

// Select a range
selection.select_range(0, 4, SelectionFlags::CLEAR_AND_SELECT);

// Get selected items
let selected_indices = selection.selected_indices();
let selected_rows = selection.selected_rows();

// Clear selection
selection.clear_selection();

// Check if index is selected
let is_selected = selection.is_selected(index);</code></pre>
<h2 id="step-5-dynamic-list-operations"><a class="header" href="#step-5-dynamic-list-operations">Step 5: Dynamic List Operations</a></h2>
<p>Add, remove, and modify items dynamically:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    ListView, PushButton, LineEdit, Container, Window
};
use horizon_lattice::widget::layout::{VBoxLayout, HBoxLayout, LayoutKind};
use horizon_lattice::model::ListModel;
use std::sync::{Arc, Mutex};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Dynamic List")
        .with_size(400.0, 500.0);

    // Shared model (wrapped in Arc&lt;Mutex&gt; for thread-safe access)
    let model = Arc::new(Mutex::new(ListModel::new(vec![
        "Item 1".to_string(),
        "Item 2".to_string(),
        "Item 3".to_string(),
    ])));

    // Create view
    let list_view = ListView::new()
        .with_model(model.lock().unwrap().clone());

    // Input field for new items
    let mut input = LineEdit::new();
    input.set_placeholder("Enter new item...");

    // Buttons
    let add_btn = PushButton::new("Add");
    let remove_btn = PushButton::new("Remove Selected");
    let clear_btn = PushButton::new("Clear All");

    // Connect Add button
    let model_clone = model.clone();
    let input_clone = input.clone();
    add_btn.clicked().connect(move |_| {
        let text = input_clone.text();
        if !text.is_empty() {
            model_clone.lock().unwrap().push(text.clone());
            input_clone.set_text("");
        }
    });

    // Connect Remove button
    let model_clone = model.clone();
    let list_clone = list_view.clone();
    remove_btn.clicked().connect(move |_| {
        let selection = list_clone.selection_model();
        let mut rows: Vec&lt;usize&gt; = selection.selected_rows();
        // Remove from highest to lowest to avoid index shifting
        rows.sort_by(|a, b| b.cmp(a));
        for row in rows {
            model_clone.lock().unwrap().remove(row);
        }
    });

    // Connect Clear button
    let model_clone = model.clone();
    clear_btn.clicked().connect(move |_| {
        model_clone.lock().unwrap().clear();
    });

    // Layout
    let mut button_row = HBoxLayout::new();
    button_row.set_spacing(8.0);
    button_row.add_widget(add_btn.object_id());
    button_row.add_widget(remove_btn.object_id());
    button_row.add_widget(clear_btn.object_id());

    let mut button_container = Container::new();
    button_container.set_layout(LayoutKind::from(button_row));

    let mut main_layout = VBoxLayout::new();
    main_layout.set_spacing(10.0);
    main_layout.add_widget(input.object_id());
    main_layout.add_widget(button_container.object_id());
    main_layout.add_widget(list_view.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(main_layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h3 id="model-operations"><a class="header" href="#model-operations">Model Operations</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::model::ListModel;

let mut model = ListModel::new(vec!["A", "B", "C"]);

// Add items
model.push("D");                    // Append at end
model.insert(1, "Inserted");        // Insert at position

// Remove items
let item = model.remove(0);         // Remove and return item
model.clear();                      // Remove all

// Replace all items
model.set_items(vec!["X", "Y", "Z"]);

// Modify an item in place
model.modify(0, |item| {
    *item = "Modified".to_string();
});

// Sort items
model.sort_by(|a, b| a.cmp(b));

// Query
let count = model.len();
let is_empty = model.is_empty();</code></pre>
<h2 id="step-6-view-modes"><a class="header" href="#step-6-view-modes">Step 6: View Modes</a></h2>
<p>ListView supports different display modes:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{ListView, ListViewMode};

// List mode (vertical list, one item per row)
let list = ListView::new()
    .with_view_mode(ListViewMode::ListMode)
    .with_model(model.clone());

// Icon mode (grid of items)
let grid = ListView::new()
    .with_view_mode(ListViewMode::IconMode)
    .with_model(model);</code></pre>
<h2 id="complete-example-task-manager"><a class="header" href="#complete-example-task-manager">Complete Example: Task Manager</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    ListView, PushButton, LineEdit, CheckBox, Label,
    Container, Window, ButtonVariant
};
use horizon_lattice::widget::layout::{
    VBoxLayout, HBoxLayout, ContentMargins, LayoutKind
};
use horizon_lattice::model::{
    ListModel, ListItem, ItemData, ItemRole, SelectionMode
};
use std::sync::{Arc, Mutex};

#[derive(Clone)]
struct Task {
    title: String,
    completed: bool,
}

impl ListItem for Task {
    fn display(&amp;self) -&gt; ItemData {
        let prefix = if self.completed { "[x]" } else { "[ ]" };
        ItemData::from(format!("{} {}", prefix, self.title))
    }

    fn data(&amp;self, role: ItemRole) -&gt; ItemData {
        match role {
            ItemRole::Display =&gt; self.display(),
            ItemRole::CheckState =&gt; {
                if self.completed {
                    ItemData::from(true)
                } else {
                    ItemData::from(false)
                }
            }
            _ =&gt; ItemData::None,
        }
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Task Manager")
        .with_size(400.0, 500.0);

    // Model with initial tasks
    let model = Arc::new(Mutex::new(ListModel::new(vec![
        Task { title: "Buy groceries".into(), completed: false },
        Task { title: "Walk the dog".into(), completed: true },
        Task { title: "Read a book".into(), completed: false },
    ])));

    // Views and controls
    let list_view = ListView::new()
        .with_model(model.lock().unwrap().clone())
        .with_selection_mode(SelectionMode::SingleSelection);

    let mut task_input = LineEdit::new();
    task_input.set_placeholder("New task...");

    let add_btn = PushButton::new("Add Task");
    let toggle_btn = PushButton::new("Toggle Done")
        .with_variant(ButtonVariant::Secondary);
    let delete_btn = PushButton::new("Delete")
        .with_variant(ButtonVariant::Danger);

    let title = Label::new("My Tasks");

    // Add task
    let model_clone = model.clone();
    let input_clone = task_input.clone();
    add_btn.clicked().connect(move |_| {
        let text = input_clone.text();
        if !text.is_empty() {
            model_clone.lock().unwrap().push(Task {
                title: text.clone(),
                completed: false,
            });
            input_clone.set_text("");
        }
    });

    // Toggle completion
    let model_clone = model.clone();
    let list_clone = list_view.clone();
    toggle_btn.clicked().connect(move |_| {
        let selection = list_clone.selection_model();
        if let Some(index) = selection.current_index() {
            let row = index.row() as usize;
            model_clone.lock().unwrap().modify(row, |task| {
                task.completed = !task.completed;
            });
        }
    });

    // Delete task
    let model_clone = model.clone();
    let list_clone = list_view.clone();
    delete_btn.clicked().connect(move |_| {
        let selection = list_clone.selection_model();
        if let Some(index) = selection.current_index() {
            model_clone.lock().unwrap().remove(index.row() as usize);
        }
    });

    // Enter key adds task
    let model_clone = model.clone();
    let input_clone = task_input.clone();
    task_input.return_pressed.connect(move || {
        let text = input_clone.text();
        if !text.is_empty() {
            model_clone.lock().unwrap().push(Task {
                title: text.clone(),
                completed: false,
            });
            input_clone.set_text("");
        }
    });

    // Layout
    let mut input_row = HBoxLayout::new();
    input_row.set_spacing(8.0);
    input_row.add_widget(task_input.object_id());
    input_row.add_widget(add_btn.object_id());

    let mut input_container = Container::new();
    input_container.set_layout(LayoutKind::from(input_row));

    let mut action_row = HBoxLayout::new();
    action_row.set_spacing(8.0);
    action_row.add_stretch(1);
    action_row.add_widget(toggle_btn.object_id());
    action_row.add_widget(delete_btn.object_id());

    let mut action_container = Container::new();
    action_container.set_layout(LayoutKind::from(action_row));

    let mut main_layout = VBoxLayout::new();
    main_layout.set_content_margins(ContentMargins::uniform(16.0));
    main_layout.set_spacing(12.0);
    main_layout.add_widget(title.object_id());
    main_layout.add_widget(input_container.object_id());
    main_layout.add_widget(list_view.object_id());
    main_layout.add_widget(action_container.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(main_layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<ol>
<li><strong>Use ListWidget for simple cases</strong> - When you don’t need complex data binding</li>
<li><strong>Use ListView + ListModel for structured data</strong> - Better separation of concerns</li>
<li><strong>Implement ListItem for custom types</strong> - Clean data display logic</li>
<li><strong>Handle selection appropriately</strong> - Use the right SelectionMode for your use case</li>
<li><strong>Remove from highest to lowest index</strong> - Prevents index shifting issues</li>
<li><strong>Use Arc&lt;Mutex&lt;&gt;&gt; for shared model access</strong> - Thread-safe model updates</li>
</ol>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li><a href="#tutorial-custom-widgets">Custom Widgets</a> - Create your own widgets</li>
<li><a href="#tutorial-theming">Theming</a> - Style your lists</li>
<li><a href="#architecture-overview">Architecture Guide</a> - Understand the Model/View pattern in depth</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial-custom-widgets"><a class="header" href="#tutorial-custom-widgets">Tutorial: Custom Widgets</a></h1>
<p>Learn to create your own widgets with custom painting and event handling.</p>
<h2 id="what-youll-learn-4"><a class="header" href="#what-youll-learn-4">What You’ll Learn</a></h2>
<ul>
<li>Implementing the Widget trait</li>
<li>Creating custom painting with PaintContext</li>
<li>Handling mouse and keyboard events</li>
<li>Managing widget state and focus</li>
<li>Emitting custom signals</li>
</ul>
<h2 id="prerequisites-4"><a class="header" href="#prerequisites-4">Prerequisites</a></h2>
<ul>
<li>Completed the <a href="#tutorial-lists-and-models">Lists</a> tutorial</li>
<li>Understanding of Rust traits and structs</li>
<li>Basic familiarity with the Widget system from the <a href="#widgets-guide">Widget Guide</a></li>
</ul>
<h2 id="the-widget-architecture"><a class="header" href="#the-widget-architecture">The Widget Architecture</a></h2>
<p>Custom widgets in Horizon Lattice require implementing two traits:</p>
<ol>
<li><strong>Object</strong> - Provides unique identification via <code>object_id()</code></li>
<li><strong>Widget</strong> - Provides UI behavior: size hints, painting, event handling</li>
</ol>
<p>Every widget contains a <code>WidgetBase</code> that handles common functionality like geometry, visibility, focus, and state tracking.</p>
<h2 id="step-1-a-minimal-custom-widget"><a class="header" href="#step-1-a-minimal-custom-widget">Step 1: A Minimal Custom Widget</a></h2>
<p>Let’s create a simple <code>ColorBox</code> widget that displays a solid color:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::{Widget, WidgetBase, SizeHint, PaintContext};
use horizon_lattice::render::Color;
use horizon_lattice_core::{Object, ObjectId};

/// A simple widget that displays a solid color.
pub struct ColorBox {
    base: WidgetBase,
    color: Color,
}

impl ColorBox {
    /// Create a new ColorBox with the specified color.
    pub fn new(color: Color) -&gt; Self {
        Self {
            base: WidgetBase::new::&lt;Self&gt;(),
            color,
        }
    }

    /// Get the current color.
    pub fn color(&amp;self) -&gt; Color {
        self.color
    }

    /// Set the color and trigger a repaint.
    pub fn set_color(&amp;mut self, color: Color) {
        if self.color != color {
            self.color = color;
            self.base.update(); // Schedule repaint
        }
    }
}

// Implement Object trait for identification
impl Object for ColorBox {
    fn object_id(&amp;self) -&gt; ObjectId {
        self.base.object_id()
    }
}

// Implement Widget trait for UI behavior
impl Widget for ColorBox {
    fn widget_base(&amp;self) -&gt; &amp;WidgetBase {
        &amp;self.base
    }

    fn widget_base_mut(&amp;mut self) -&gt; &amp;mut WidgetBase {
        &amp;mut self.base
    }

    fn size_hint(&amp;self) -&gt; SizeHint {
        // Preferred 100x100, minimum 20x20
        SizeHint::from_dimensions(100.0, 100.0)
            .with_minimum_dimensions(20.0, 20.0)
    }

    fn paint(&amp;self, ctx: &amp;mut PaintContext&lt;'_&gt;) {
        // Fill the entire widget with our color
        ctx.renderer().fill_rect(ctx.rect(), self.color);
    }
}</code></pre>
<h3 id="using-colorbox"><a class="header" href="#using-colorbox">Using ColorBox</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::Window;
use horizon_lattice::render::Color;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Color Box")
        .with_size(300.0, 200.0);

    let color_box = ColorBox::new(Color::from_rgb8(65, 105, 225)); // Royal Blue

    window.set_content_widget(color_box.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="step-2-understanding-widgetbase"><a class="header" href="#step-2-understanding-widgetbase">Step 2: Understanding WidgetBase</a></h2>
<p><code>WidgetBase</code> provides essential functionality that all widgets need:</p>
<h3 id="geometry"><a class="header" href="#geometry">Geometry</a></h3>
<pre><code class="language-rust ignore">// Get widget bounds
let rect = self.base.geometry();      // Position + size in parent coordinates
let size = self.base.size();
let pos = self.base.pos();

// Set geometry (usually done by layout)
self.base.set_geometry(Rect::new(Point::new(10.0, 10.0), Size::new(100.0, 50.0)));</code></pre>
<h3 id="visibility"><a class="header" href="#visibility">Visibility</a></h3>
<pre><code class="language-rust ignore">// Show/hide
self.base.show();
self.base.hide();
self.base.set_visible(true);

// Check visibility
let visible = self.base.is_visible();
let effective = self.base.is_effectively_visible(); // Considers ancestors</code></pre>
<h3 id="enabled-state"><a class="header" href="#enabled-state">Enabled State</a></h3>
<pre><code class="language-rust ignore">// Enable/disable
self.base.enable();
self.base.disable();
self.base.set_enabled(false);

// Check state
let enabled = self.base.is_enabled();
let effective = self.base.is_effectively_enabled(); // Considers ancestors</code></pre>
<h3 id="repaint-scheduling"><a class="header" href="#repaint-scheduling">Repaint Scheduling</a></h3>
<pre><code class="language-rust ignore">// Schedule repaint for next frame
self.base.update();

// Schedule partial repaint
self.base.update_rect(Rect::new(Point::new(0.0, 0.0), Size::new(50.0, 50.0)));</code></pre>
<h2 id="step-3-custom-painting"><a class="header" href="#step-3-custom-painting">Step 3: Custom Painting</a></h2>
<p>The <code>paint()</code> method receives a <code>PaintContext</code> that provides access to the renderer:</p>
<pre><code class="language-rust ignore">fn paint(&amp;self, ctx: &amp;mut PaintContext&lt;'_&gt;) {
    let renderer = ctx.renderer();
    let rect = ctx.rect(); // Widget bounds (0,0 to width,height)

    // Fill background
    renderer.fill_rect(rect, self.background_color);

    // Draw border
    let stroke = Stroke::new(self.border_color, 2.0);
    renderer.stroke_rect(rect, &amp;stroke);

    // Draw text
    renderer.draw_text(
        Point::new(10.0, 10.0),
        &amp;self.text,
        &amp;self.font,
        self.text_color,
    );

    // Draw focus indicator if focused
    if ctx.should_show_focus() {
        ctx.draw_focus_indicator(2.0);
    }
}</code></pre>
<h3 id="coordinate-system"><a class="header" href="#coordinate-system">Coordinate System</a></h3>
<ul>
<li>The renderer is pre-translated so <code>(0, 0)</code> is the widget’s top-left corner</li>
<li>Use <code>ctx.rect()</code> to get the full widget bounds in local coordinates</li>
<li><code>ctx.width()</code> and <code>ctx.height()</code> provide dimensions directly</li>
</ul>
<h3 id="paintcontext-methods"><a class="header" href="#paintcontext-methods">PaintContext Methods</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Method</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><code>renderer()</code></td><td>Get the GpuRenderer for drawing</td></tr>
<tr><td><code>rect()</code></td><td>Widget bounds (local coordinates)</td></tr>
<tr><td><code>width()</code> / <code>height()</code></td><td>Widget dimensions</td></tr>
<tr><td><code>size()</code></td><td>Widget size as Size struct</td></tr>
<tr><td><code>is_alt_held()</code></td><td>Check if Alt key is pressed (for mnemonics)</td></tr>
<tr><td><code>should_show_focus()</code></td><td>Check if focus indicator should be drawn</td></tr>
<tr><td><code>draw_focus_indicator(inset)</code></td><td>Draw standard focus ring</td></tr>
</tbody>
</table>
</div>
<h2 id="step-4-event-handling"><a class="header" href="#step-4-event-handling">Step 4: Event Handling</a></h2>
<p>Override the <code>event()</code> method to handle user input:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::{
    Widget, WidgetBase, SizeHint, PaintContext,
    WidgetEvent, MousePressEvent, MouseReleaseEvent, MouseButton
};

impl Widget for MyWidget {
    // ... other methods ...

    fn event(&amp;mut self, event: &amp;mut WidgetEvent) -&gt; bool {
        match event {
            WidgetEvent::MousePress(e) =&gt; {
                if e.button == MouseButton::Left {
                    // Handle left click
                    e.base.accept(); // Mark event as handled
                    return true;
                }
            }
            WidgetEvent::MouseRelease(e) =&gt; {
                if e.button == MouseButton::Left {
                    // Handle release
                    e.base.accept();
                    return true;
                }
            }
            _ =&gt; {}
        }
        false // Event not handled
    }
}</code></pre>
<h3 id="event-types"><a class="header" href="#event-types">Event Types</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Event</th><th>When Triggered</th></tr>
</thead>
<tbody>
<tr><td><code>MousePress</code></td><td>Mouse button pressed</td></tr>
<tr><td><code>MouseRelease</code></td><td>Mouse button released</td></tr>
<tr><td><code>MouseMove</code></td><td>Mouse moved over widget</td></tr>
<tr><td><code>MouseDoubleClick</code></td><td>Double-click detected</td></tr>
<tr><td><code>Enter</code></td><td>Mouse enters widget bounds</td></tr>
<tr><td><code>Leave</code></td><td>Mouse leaves widget bounds</td></tr>
<tr><td><code>Wheel</code></td><td>Scroll wheel moved</td></tr>
<tr><td><code>KeyPress</code></td><td>Key pressed while focused</td></tr>
<tr><td><code>KeyRelease</code></td><td>Key released while focused</td></tr>
<tr><td><code>FocusIn</code></td><td>Widget gained focus</td></tr>
<tr><td><code>FocusOut</code></td><td>Widget lost focus</td></tr>
<tr><td><code>Resize</code></td><td>Widget size changed</td></tr>
<tr><td><code>Move</code></td><td>Widget position changed</td></tr>
</tbody>
</table>
</div>
<h3 id="mouse-event-data"><a class="header" href="#mouse-event-data">Mouse Event Data</a></h3>
<pre><code class="language-rust ignore">WidgetEvent::MousePress(e) =&gt; {
    let button = e.button;        // MouseButton::Left, Right, Middle
    let local = e.local_pos;      // Position in widget coordinates
    let window = e.window_pos;    // Position in window coordinates
    let global = e.global_pos;    // Position in screen coordinates
    let mods = e.modifiers;       // KeyboardModifiers { shift, control, alt, meta }
}</code></pre>
<h3 id="keyboard-event-data"><a class="header" href="#keyboard-event-data">Keyboard Event Data</a></h3>
<pre><code class="language-rust ignore">WidgetEvent::KeyPress(e) =&gt; {
    let key = e.key;              // Key enum (Key::A, Key::Space, etc.)
    let text = &amp;e.text;           // Character(s) typed (for text input)
    let mods = e.modifiers;       // Modifier keys held
    let repeat = e.repeat;        // Is this an auto-repeat?
}</code></pre>
<h2 id="step-5-focus-management"><a class="header" href="#step-5-focus-management">Step 5: Focus Management</a></h2>
<p>To receive keyboard events, widgets must accept focus:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::FocusPolicy;

impl MyWidget {
    pub fn new() -&gt; Self {
        let mut base = WidgetBase::new::&lt;Self&gt;();
        // Accept focus from both Tab and mouse click
        base.set_focus_policy(FocusPolicy::StrongFocus);
        Self { base, /* ... */ }
    }
}</code></pre>
<h3 id="focus-policies"><a class="header" href="#focus-policies">Focus Policies</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Policy</th><th>Tab Focus</th><th>Click Focus</th></tr>
</thead>
<tbody>
<tr><td><code>NoFocus</code></td><td>No</td><td>No</td></tr>
<tr><td><code>TabFocus</code></td><td>Yes</td><td>No</td></tr>
<tr><td><code>ClickFocus</code></td><td>No</td><td>Yes</td></tr>
<tr><td><code>StrongFocus</code></td><td>Yes</td><td>Yes</td></tr>
</tbody>
</table>
</div>
<h3 id="focus-in-paint"><a class="header" href="#focus-in-paint">Focus in Paint</a></h3>
<pre><code class="language-rust ignore">fn paint(&amp;self, ctx: &amp;mut PaintContext&lt;'_&gt;) {
    // Paint normal content...

    // Show focus indicator when focused
    if ctx.should_show_focus() &amp;&amp; self.base.has_focus() {
        ctx.draw_focus_indicator(2.0); // 2px inset from edge
    }
}</code></pre>
<h2 id="step-6-widget-state"><a class="header" href="#step-6-widget-state">Step 6: Widget State</a></h2>
<p>WidgetBase tracks common state automatically:</p>
<pre><code class="language-rust ignore">// In paint or event handlers:
let is_pressed = self.base.is_pressed();   // Mouse button held down
let is_hovered = self.base.is_hovered();   // Mouse over widget
let has_focus = self.base.has_focus();     // Widget has keyboard focus</code></pre>
<p>Use this state for visual feedback:</p>
<pre><code class="language-rust ignore">fn paint(&amp;self, ctx: &amp;mut PaintContext&lt;'_&gt;) {
    // Choose color based on state
    let bg_color = if self.base.is_pressed() {
        Color::from_rgb8(45, 85, 205)  // Darker when pressed
    } else if self.base.is_hovered() {
        Color::from_rgb8(85, 145, 255)  // Lighter when hovered
    } else {
        Color::from_rgb8(65, 105, 225)  // Normal
    };

    ctx.renderer().fill_rect(ctx.rect(), bg_color);
}</code></pre>
<h2 id="step-7-custom-signals"><a class="header" href="#step-7-custom-signals">Step 7: Custom Signals</a></h2>
<p>Use signals to notify external code of events:</p>
<pre><code class="language-rust ignore">use horizon_lattice_core::Signal;

pub struct ClickCounter {
    base: WidgetBase,
    count: u32,

    // Custom signals
    pub clicked: Signal&lt;()&gt;,
    pub count_changed: Signal&lt;u32&gt;,
}

impl ClickCounter {
    pub fn new() -&gt; Self {
        Self {
            base: WidgetBase::new::&lt;Self&gt;(),
            count: 0,
            clicked: Signal::new(),
            count_changed: Signal::new(),
        }
    }

    fn increment(&amp;mut self) {
        self.count += 1;
        self.clicked.emit(());
        self.count_changed.emit(self.count);
        self.base.update(); // Repaint to show new count
    }
}

impl Widget for ClickCounter {
    // ... base methods ...

    fn event(&amp;mut self, event: &amp;mut WidgetEvent) -&gt; bool {
        match event {
            WidgetEvent::MouseRelease(e) =&gt; {
                if e.button == MouseButton::Left &amp;&amp; self.base.is_pressed() {
                    self.increment();
                    e.base.accept();
                    return true;
                }
            }
            _ =&gt; {}
        }
        false
    }
}</code></pre>
<h3 id="connecting-to-signals"><a class="header" href="#connecting-to-signals">Connecting to Signals</a></h3>
<pre><code class="language-rust ignore">let counter = ClickCounter::new();

counter.clicked.connect(|_| {
    println!("Counter was clicked!");
});

counter.count_changed.connect(|&amp;count| {
    println!("Count is now: {}", count);
});</code></pre>
<h2 id="complete-example-interactive-slider"><a class="header" href="#complete-example-interactive-slider">Complete Example: Interactive Slider</a></h2>
<p>Here’s a complete custom slider widget:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::{
    Widget, WidgetBase, SizeHint, PaintContext, FocusPolicy,
    WidgetEvent, MouseButton
};
use horizon_lattice::widget::widgets::{Window, Label, Container};
use horizon_lattice::widget::layout::{VBoxLayout, LayoutKind};
use horizon_lattice::render::{Color, Point, Rect, Size, Stroke};
use horizon_lattice_core::{Object, ObjectId, Signal};
use std::sync::Arc;

/// A custom horizontal slider widget.
pub struct Slider {
    base: WidgetBase,
    value: f32,          // 0.0 to 1.0
    dragging: bool,
    track_color: Color,
    thumb_color: Color,
    thumb_hover_color: Color,

    /// Emitted when the value changes.
    pub value_changed: Signal&lt;f32&gt;,
}

impl Slider {
    const THUMB_WIDTH: f32 = 16.0;
    const THUMB_HEIGHT: f32 = 24.0;
    const TRACK_HEIGHT: f32 = 4.0;

    pub fn new() -&gt; Self {
        let mut base = WidgetBase::new::&lt;Self&gt;();
        base.set_focus_policy(FocusPolicy::StrongFocus);

        Self {
            base,
            value: 0.0,
            dragging: false,
            track_color: Color::from_rgb8(200, 200, 200),
            thumb_color: Color::from_rgb8(65, 105, 225),
            thumb_hover_color: Color::from_rgb8(85, 125, 245),
            value_changed: Signal::new(),
        }
    }

    pub fn value(&amp;self) -&gt; f32 {
        self.value
    }

    pub fn set_value(&amp;mut self, value: f32) {
        let clamped = value.clamp(0.0, 1.0);
        if (self.value - clamped).abs() &gt; f32::EPSILON {
            self.value = clamped;
            self.value_changed.emit(self.value);
            self.base.update();
        }
    }

    fn value_from_x(&amp;self, x: f32) -&gt; f32 {
        let usable_width = self.base.width() - Self::THUMB_WIDTH;
        if usable_width &lt;= 0.0 {
            return 0.0;
        }
        let thumb_center_x = x - Self::THUMB_WIDTH / 2.0;
        (thumb_center_x / usable_width).clamp(0.0, 1.0)
    }

    fn thumb_rect(&amp;self) -&gt; Rect {
        let usable_width = self.base.width() - Self::THUMB_WIDTH;
        let thumb_x = self.value * usable_width;
        let thumb_y = (self.base.height() - Self::THUMB_HEIGHT) / 2.0;
        Rect::new(
            Point::new(thumb_x, thumb_y),
            Size::new(Self::THUMB_WIDTH, Self::THUMB_HEIGHT),
        )
    }
}

impl Object for Slider {
    fn object_id(&amp;self) -&gt; ObjectId {
        self.base.object_id()
    }
}

impl Widget for Slider {
    fn widget_base(&amp;self) -&gt; &amp;WidgetBase {
        &amp;self.base
    }

    fn widget_base_mut(&amp;mut self) -&gt; &amp;mut WidgetBase {
        &amp;mut self.base
    }

    fn size_hint(&amp;self) -&gt; SizeHint {
        SizeHint::from_dimensions(200.0, 30.0)
            .with_minimum_dimensions(50.0, 24.0)
    }

    fn paint(&amp;self, ctx: &amp;mut PaintContext&lt;'_&gt;) {
        let width = ctx.width();
        let height = ctx.height();

        // Draw track
        let track_y = (height - Self::TRACK_HEIGHT) / 2.0;
        let track_rect = Rect::new(
            Point::new(Self::THUMB_WIDTH / 2.0, track_y),
            Size::new(width - Self::THUMB_WIDTH, Self::TRACK_HEIGHT),
        );
        ctx.renderer().fill_rect(track_rect, self.track_color);

        // Draw filled portion of track
        let filled_width = self.value * (width - Self::THUMB_WIDTH);
        let filled_rect = Rect::new(
            Point::new(Self::THUMB_WIDTH / 2.0, track_y),
            Size::new(filled_width, Self::TRACK_HEIGHT),
        );
        ctx.renderer().fill_rect(filled_rect, self.thumb_color);

        // Draw thumb
        let thumb_rect = self.thumb_rect();
        let thumb_color = if self.dragging || self.base.is_hovered() {
            self.thumb_hover_color
        } else {
            self.thumb_color
        };
        ctx.renderer().fill_rounded_rect(thumb_rect, 4.0, thumb_color);

        // Draw focus indicator around thumb
        if ctx.should_show_focus() {
            let focus_rect = thumb_rect.inflate(2.0, 2.0);
            let stroke = Stroke::new(Color::from_rgb8(0, 120, 212), 2.0);
            ctx.renderer().stroke_rounded_rect(focus_rect, 6.0, &amp;stroke);
        }
    }

    fn event(&amp;mut self, event: &amp;mut WidgetEvent) -&gt; bool {
        match event {
            WidgetEvent::MousePress(e) =&gt; {
                if e.button == MouseButton::Left {
                    self.dragging = true;
                    self.set_value(self.value_from_x(e.local_pos.x));
                    e.base.accept();
                    return true;
                }
            }
            WidgetEvent::MouseRelease(e) =&gt; {
                if e.button == MouseButton::Left &amp;&amp; self.dragging {
                    self.dragging = false;
                    self.base.update();
                    e.base.accept();
                    return true;
                }
            }
            WidgetEvent::MouseMove(e) =&gt; {
                if self.dragging {
                    self.set_value(self.value_from_x(e.local_pos.x));
                    e.base.accept();
                    return true;
                }
            }
            WidgetEvent::KeyPress(e) =&gt; {
                use horizon_lattice::widget::Key;
                match e.key {
                    Key::ArrowLeft =&gt; {
                        self.set_value(self.value - 0.05);
                        e.base.accept();
                        return true;
                    }
                    Key::ArrowRight =&gt; {
                        self.set_value(self.value + 0.05);
                        e.base.accept();
                        return true;
                    }
                    Key::Home =&gt; {
                        self.set_value(0.0);
                        e.base.accept();
                        return true;
                    }
                    Key::End =&gt; {
                        self.set_value(1.0);
                        e.base.accept();
                        return true;
                    }
                    _ =&gt; {}
                }
            }
            _ =&gt; {}
        }
        false
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Custom Slider")
        .with_size(400.0, 150.0);

    // Create our custom slider
    let slider = Arc::new(std::sync::Mutex::new(Slider::new()));

    // Create label to show value
    let label = Label::new("Value: 0%");

    // Connect slider to label
    let label_clone = label.clone();
    slider.lock().unwrap().value_changed.connect(move |&amp;value| {
        label_clone.set_text(&amp;format!("Value: {:.0}%", value * 100.0));
    });

    // Layout
    let mut layout = VBoxLayout::new();
    layout.set_spacing(20.0);
    layout.add_widget(slider.lock().unwrap().object_id());
    layout.add_widget(label.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="1-always-use-widgetbase"><a class="header" href="#1-always-use-widgetbase">1. Always Use WidgetBase</a></h3>
<p>Never create widget state that duplicates what <code>WidgetBase</code> already provides:</p>
<pre><code class="language-rust ignore">// Bad - duplicating state
struct MyWidget {
    base: WidgetBase,
    visible: bool,  // Already in WidgetBase!
    position: Point, // Already in WidgetBase!
}

// Good - use WidgetBase
struct MyWidget {
    base: WidgetBase,
    custom_state: String, // Only add unique state
}</code></pre>
<h3 id="2-call-update-when-state-changes"><a class="header" href="#2-call-update-when-state-changes">2. Call update() When State Changes</a></h3>
<p>Always schedule a repaint when visual state changes:</p>
<pre><code class="language-rust ignore">pub fn set_color(&amp;mut self, color: Color) {
    if self.color != color {
        self.color = color;
        self.base.update(); // Don't forget this!
    }
}</code></pre>
<h3 id="3-accept-events-you-handle"><a class="header" href="#3-accept-events-you-handle">3. Accept Events You Handle</a></h3>
<p>Mark events as accepted to prevent propagation:</p>
<pre><code class="language-rust ignore">fn event(&amp;mut self, event: &amp;mut WidgetEvent) -&gt; bool {
    match event {
        WidgetEvent::MousePress(e) =&gt; {
            e.base.accept(); // Important!
            return true;
        }
        _ =&gt; {}
    }
    false
}</code></pre>
<h3 id="4-set-appropriate-focus-policy"><a class="header" href="#4-set-appropriate-focus-policy">4. Set Appropriate Focus Policy</a></h3>
<p>Choose the right policy for your widget type:</p>
<ul>
<li><strong>NoFocus</strong>: Decorative widgets (labels, separators)</li>
<li><strong>ClickFocus</strong>: Mouse-primary widgets (list items)</li>
<li><strong>TabFocus</strong>: Keyboard-primary widgets (rare)</li>
<li><strong>StrongFocus</strong>: Interactive widgets (buttons, sliders, inputs)</li>
</ul>
<h3 id="5-provide-meaningful-size-hints"><a class="header" href="#5-provide-meaningful-size-hints">5. Provide Meaningful Size Hints</a></h3>
<p>Help layouts by providing accurate size information:</p>
<pre><code class="language-rust ignore">fn size_hint(&amp;self) -&gt; SizeHint {
    SizeHint::from_dimensions(200.0, 40.0)  // Preferred
        .with_minimum_dimensions(100.0, 30.0)  // Minimum usable
        .with_maximum_dimensions(500.0, 40.0)  // Maximum reasonable
}</code></pre>
<h3 id="6-handle-both-mouse-and-keyboard"><a class="header" href="#6-handle-both-mouse-and-keyboard">6. Handle Both Mouse and Keyboard</a></h3>
<p>Make widgets accessible by supporting keyboard navigation:</p>
<pre><code class="language-rust ignore">fn event(&amp;mut self, event: &amp;mut WidgetEvent) -&gt; bool {
    match event {
        // Mouse activation
        WidgetEvent::MouseRelease(e) if e.button == MouseButton::Left =&gt; {
            self.activate();
            e.base.accept();
            true
        }
        // Keyboard activation (Space or Enter)
        WidgetEvent::KeyPress(e) if e.key == Key::Space || e.key == Key::Enter =&gt; {
            self.activate();
            e.base.accept();
            true
        }
        _ =&gt; false,
    }
}</code></pre>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<ul>
<li><a href="#tutorial-theming">Theming</a> - Style your custom widgets consistently</li>
<li><a href="#widgets-guide">Widget Guide</a> - Deep dive into the widget system</li>
<li><a href="#signals-and-slots-guide">Signals Guide</a> - Advanced signal/slot patterns</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial-theming"><a class="header" href="#tutorial-theming">Tutorial: Theming</a></h1>
<p>Learn to style your application with themes and switch between light and dark modes.</p>
<h2 id="what-youll-learn-5"><a class="header" href="#what-youll-learn-5">What You’ll Learn</a></h2>
<ul>
<li>Understanding the theme system</li>
<li>Applying built-in themes</li>
<li>Creating custom themes</li>
<li>Switching themes at runtime</li>
<li>Detecting and following system dark mode</li>
<li>Styling individual widgets</li>
</ul>
<h2 id="prerequisites-5"><a class="header" href="#prerequisites-5">Prerequisites</a></h2>
<ul>
<li>Completed the <a href="#tutorial-custom-widgets">Custom Widgets</a> tutorial</li>
<li>Understanding of the Widget system</li>
<li>Familiarity with the <a href="#styling-guide">Styling Guide</a></li>
</ul>
<h2 id="the-theme-system"><a class="header" href="#the-theme-system">The Theme System</a></h2>
<p>Horizon Lattice uses a comprehensive theming system inspired by Material Design:</p>
<ul>
<li><strong>Theme</strong> - Defines colors, typography, and widget defaults</li>
<li><strong>ColorPalette</strong> - The color scheme (primary, secondary, background, etc.)</li>
<li><strong>StyleEngine</strong> - Resolves and applies styles to widgets</li>
<li><strong>ThemeMode</strong> - Light, Dark, or High Contrast</li>
</ul>
<h2 id="step-1-built-in-themes"><a class="header" href="#step-1-built-in-themes">Step 1: Built-in Themes</a></h2>
<p>Horizon Lattice provides three built-in themes:</p>
<pre><code class="language-rust ignore">use horizon_lattice_style::{Theme, ThemeMode};

// Light theme (default)
let light = Theme::light();

// Dark theme
let dark = Theme::dark();

// High contrast theme (accessibility)
let high_contrast = Theme::high_contrast();</code></pre>
<h3 id="using-a-theme-with-styleengine"><a class="header" href="#using-a-theme-with-styleengine">Using a Theme with StyleEngine</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{Label, PushButton, Container, Window};
use horizon_lattice::widget::layout::{VBoxLayout, LayoutKind};
use horizon_lattice_style::{StyleEngine, Theme};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    // Create style engine with dark theme
    let style_engine = StyleEngine::dark();
    app.set_style_engine(style_engine);

    let mut window = Window::new("Dark Theme App")
        .with_size(400.0, 300.0);

    let label = Label::new("Welcome to the dark side!");
    let button = PushButton::new("Click me");

    let mut layout = VBoxLayout::new();
    layout.add_widget(label.object_id());
    layout.add_widget(button.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="step-2-understanding-colorpalette"><a class="header" href="#step-2-understanding-colorpalette">Step 2: Understanding ColorPalette</a></h2>
<p>The <code>ColorPalette</code> defines all colors used throughout the theme:</p>
<pre><code class="language-rust ignore">use horizon_lattice_style::ColorPalette;
use horizon_lattice::render::Color;

// Get the light palette
let palette = ColorPalette::light();

// Access specific colors
let primary = palette.primary;           // Main brand color
let background = palette.background;     // App background
let text = palette.text_primary;         // Primary text color
let error = palette.error;               // Error/danger color</code></pre>
<h3 id="color-categories"><a class="header" href="#color-categories">Color Categories</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Colors</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><strong>Primary</strong></td><td><code>primary</code>, <code>primary_light</code>, <code>primary_dark</code>, <code>on_primary</code></td><td>Brand/accent colors</td></tr>
<tr><td><strong>Secondary</strong></td><td><code>secondary</code>, <code>secondary_light</code>, <code>secondary_dark</code>, <code>on_secondary</code></td><td>Complementary accent</td></tr>
<tr><td><strong>Background</strong></td><td><code>background</code>, <code>surface</code>, <code>surface_variant</code></td><td>Container backgrounds</td></tr>
<tr><td><strong>Text</strong></td><td><code>text_primary</code>, <code>text_secondary</code>, <code>text_disabled</code></td><td>Text colors</td></tr>
<tr><td><strong>Semantic</strong></td><td><code>error</code>, <code>warning</code>, <code>success</code>, <code>info</code></td><td>Status indicators</td></tr>
<tr><td><strong>Borders</strong></td><td><code>border</code>, <code>border_light</code>, <code>divider</code></td><td>Lines and separators</td></tr>
</tbody>
</table>
</div>
<h3 id="light-vs-dark-palette-colors"><a class="header" href="#light-vs-dark-palette-colors">Light vs Dark Palette Colors</a></h3>
<pre><code class="language-rust ignore">// Light palette
let light = ColorPalette::light();
assert_eq!(light.background, Color::from_rgb8(255, 255, 255)); // White
assert_eq!(light.text_primary, Color::from_rgb8(33, 33, 33));  // Near black

// Dark palette
let dark = ColorPalette::dark();
assert_eq!(dark.background, Color::from_rgb8(18, 18, 18));     // Near black
assert_eq!(dark.text_primary, Color::from_rgb8(255, 255, 255)); // White</code></pre>
<h2 id="step-3-creating-custom-themes"><a class="header" href="#step-3-creating-custom-themes">Step 3: Creating Custom Themes</a></h2>
<p>Create a custom theme with your own color palette:</p>
<pre><code class="language-rust ignore">use horizon_lattice_style::{Theme, ThemeMode, ColorPalette};
use horizon_lattice::render::Color;

// Start with a base palette and customize
fn create_brand_theme() -&gt; Theme {
    let mut palette = ColorPalette::light();

    // Set brand colors
    palette.primary = Color::from_hex("#6200EE").unwrap();       // Purple
    palette.primary_light = Color::from_hex("#9D46FF").unwrap();
    palette.primary_dark = Color::from_hex("#3700B3").unwrap();
    palette.on_primary = Color::WHITE;

    palette.secondary = Color::from_hex("#03DAC6").unwrap();     // Teal
    palette.secondary_light = Color::from_hex("#66FFF8").unwrap();
    palette.secondary_dark = Color::from_hex("#00A896").unwrap();
    palette.on_secondary = Color::BLACK;

    // Create theme from custom palette
    Theme::custom(ThemeMode::Light, palette)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let brand_theme = create_brand_theme();
    let style_engine = StyleEngine::new(brand_theme);
    app.set_style_engine(style_engine);

    // ... rest of app setup
    Ok(())
}</code></pre>
<h3 id="creating-a-complete-dark-brand-theme"><a class="header" href="#creating-a-complete-dark-brand-theme">Creating a Complete Dark Brand Theme</a></h3>
<pre><code class="language-rust ignore">fn create_dark_brand_theme() -&gt; Theme {
    let mut palette = ColorPalette::dark();

    // Adjust primary for dark backgrounds
    palette.primary = Color::from_hex("#BB86FC").unwrap();       // Light purple
    palette.primary_light = Color::from_hex("#E4B8FF").unwrap();
    palette.primary_dark = Color::from_hex("#8858C8").unwrap();
    palette.on_primary = Color::BLACK;

    palette.secondary = Color::from_hex("#03DAC6").unwrap();     // Teal
    palette.on_secondary = Color::BLACK;

    // Adjust backgrounds for OLED-friendly dark
    palette.background = Color::from_rgb8(0, 0, 0);              // Pure black
    palette.surface = Color::from_rgb8(30, 30, 30);
    palette.surface_variant = Color::from_rgb8(45, 45, 45);

    Theme::custom(ThemeMode::Dark, palette)
}</code></pre>
<h2 id="step-4-switching-themes-at-runtime"><a class="header" href="#step-4-switching-themes-at-runtime">Step 4: Switching Themes at Runtime</a></h2>
<p>Switch between themes dynamically:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    PushButton, Label, Container, Window, ButtonVariant
};
use horizon_lattice::widget::layout::{VBoxLayout, HBoxLayout, LayoutKind};
use horizon_lattice_style::{StyleEngine, Theme};
use std::sync::{Arc, RwLock};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    // Wrap style engine for shared access
    let style_engine = Arc::new(RwLock::new(StyleEngine::light()));
    app.set_shared_style_engine(style_engine.clone());

    let mut window = Window::new("Theme Switcher")
        .with_size(400.0, 300.0);

    let label = Label::new("Current theme: Light");

    // Theme buttons
    let light_btn = PushButton::new("Light Theme");
    let dark_btn = PushButton::new("Dark Theme")
        .with_variant(ButtonVariant::Secondary);
    let contrast_btn = PushButton::new("High Contrast")
        .with_variant(ButtonVariant::Outlined);

    // Light theme button
    let engine = style_engine.clone();
    let label_clone = label.clone();
    light_btn.clicked().connect(move |_| {
        let mut eng = engine.write().unwrap();
        eng.set_theme(Theme::light());
        eng.invalidate_all(); // Refresh all widget styles
        label_clone.set_text("Current theme: Light");
    });

    // Dark theme button
    let engine = style_engine.clone();
    let label_clone = label.clone();
    dark_btn.clicked().connect(move |_| {
        let mut eng = engine.write().unwrap();
        eng.set_theme(Theme::dark());
        eng.invalidate_all();
        label_clone.set_text("Current theme: Dark");
    });

    // High contrast button
    let engine = style_engine.clone();
    let label_clone = label.clone();
    contrast_btn.clicked().connect(move |_| {
        let mut eng = engine.write().unwrap();
        eng.set_theme(Theme::high_contrast());
        eng.invalidate_all();
        label_clone.set_text("Current theme: High Contrast");
    });

    // Button row
    let mut button_row = HBoxLayout::new();
    button_row.set_spacing(8.0);
    button_row.add_widget(light_btn.object_id());
    button_row.add_widget(dark_btn.object_id());
    button_row.add_widget(contrast_btn.object_id());

    let mut button_container = Container::new();
    button_container.set_layout(LayoutKind::from(button_row));

    // Main layout
    let mut layout = VBoxLayout::new();
    layout.set_spacing(20.0);
    layout.add_widget(label.object_id());
    layout.add_widget(button_container.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="step-5-following-system-dark-mode"><a class="header" href="#step-5-following-system-dark-mode">Step 5: Following System Dark Mode</a></h2>
<p>Automatically follow the system’s dark mode setting:</p>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::platform::{SystemTheme, ColorScheme, ThemeWatcher, ThemeAutoUpdater};
use horizon_lattice_style::{StyleEngine, Theme};
use std::sync::{Arc, RwLock};

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    // Detect initial system theme
    let initial_theme = match SystemTheme::color_scheme() {
        ColorScheme::Dark =&gt; Theme::dark(),
        _ =&gt; Theme::light(),
    };

    let style_engine = Arc::new(RwLock::new(StyleEngine::new(initial_theme)));
    app.set_shared_style_engine(style_engine.clone());

    // Set up automatic theme updates
    let watcher = ThemeWatcher::new()?;
    let auto_updater = ThemeAutoUpdater::new(watcher, style_engine.clone());
    auto_updater.start()?;

    // ... rest of app setup

    app.run()
}</code></pre>
<h3 id="manual-theme-watching"><a class="header" href="#manual-theme-watching">Manual Theme Watching</a></h3>
<p>For more control, handle theme changes manually:</p>
<pre><code class="language-rust ignore">use horizon_lattice::platform::{ThemeWatcher, ColorScheme};
use horizon_lattice_style::{StyleEngine, Theme};
use std::sync::{Arc, RwLock};

fn setup_theme_watcher(
    style_engine: Arc&lt;RwLock&lt;StyleEngine&gt;&gt;,
) -&gt; Result&lt;ThemeWatcher, Box&lt;dyn std::error::Error&gt;&gt; {
    let watcher = ThemeWatcher::new()?;

    // Connect to color scheme changes
    let engine = style_engine.clone();
    watcher.color_scheme_changed().connect(move |&amp;scheme| {
        let mut eng = engine.write().unwrap();
        match scheme {
            ColorScheme::Dark =&gt; {
                eng.set_theme(Theme::dark());
                println!("Switched to dark theme");
            }
            ColorScheme::Light | ColorScheme::Unknown =&gt; {
                eng.set_theme(Theme::light());
                println!("Switched to light theme");
            }
        }
        eng.invalidate_all();
    });

    // Connect to high contrast changes
    let engine = style_engine.clone();
    watcher.high_contrast_changed().connect(move |&amp;enabled| {
        if enabled {
            let mut eng = engine.write().unwrap();
            eng.set_theme(Theme::high_contrast());
            eng.invalidate_all();
            println!("Switched to high contrast theme");
        }
    });

    watcher.start()?;
    Ok(watcher)
}</code></pre>
<h3 id="checking-system-settings"><a class="header" href="#checking-system-settings">Checking System Settings</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::platform::{SystemTheme, ColorScheme};

fn check_system_theme() {
    // Get current color scheme
    let scheme = SystemTheme::color_scheme();
    match scheme {
        ColorScheme::Light =&gt; println!("System is in light mode"),
        ColorScheme::Dark =&gt; println!("System is in dark mode"),
        ColorScheme::Unknown =&gt; println!("Could not detect system theme"),
    }

    // Check high contrast
    if SystemTheme::is_high_contrast() {
        println!("High contrast is enabled");
    }

    // Get system accent color (if available)
    if let Some(accent) = SystemTheme::accent_color() {
        println!("System accent color: {:?}", accent.color);
    }
}</code></pre>
<h2 id="step-6-styling-individual-widgets"><a class="header" href="#step-6-styling-individual-widgets">Step 6: Styling Individual Widgets</a></h2>
<p>Apply custom styles to specific widgets:</p>
<h3 id="inline-styles"><a class="header" href="#inline-styles">Inline Styles</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{Label, PushButton};
use horizon_lattice_style::{Style, LengthValue};
use horizon_lattice::render::Color;

// Style a label
let mut label = Label::new("Styled Label");
label.set_style(
    Style::new()
        .color(Color::from_hex("#6200EE").unwrap())
        .font_size(LengthValue::Px(24.0))
        .font_weight(horizon_lattice_style::FontWeight::Bold)
        .build()
);

// Style a button
let mut button = PushButton::new("Custom Button");
button.set_style(
    Style::new()
        .background_color(Color::from_hex("#03DAC6").unwrap())
        .color(Color::BLACK)
        .padding_all(LengthValue::Px(16.0))
        .border_radius_all(8.0)
        .build()
);</code></pre>
<h3 id="widget-classes"><a class="header" href="#widget-classes">Widget Classes</a></h3>
<p>Use CSS-like classes for reusable styles:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{Label, PushButton, Container};
use horizon_lattice_style::{StyleSheet, StylePriority, Selector, Style};
use horizon_lattice::render::Color;

// Create a stylesheet with class rules
let mut stylesheet = StyleSheet::application();

// Add a "highlight" class
stylesheet.add_rule(
    Selector::class("highlight"),
    Style::new()
        .background_color(Color::from_rgba(255, 235, 59, 0.3)) // Yellow tint
        .border_width_all(LengthValue::Px(2.0))
        .border_color(Color::from_rgb8(255, 235, 59))
        .border_radius_all(4.0)
        .build()
);

// Add a "large-text" class
stylesheet.add_rule(
    Selector::class("large-text"),
    Style::new()
        .font_size(LengthValue::Px(20.0))
        .line_height(1.6)
        .build()
);

// Register stylesheet with engine
style_engine.add_stylesheet(stylesheet);

// Apply classes to widgets
let mut label = Label::new("Highlighted text");
label.add_class("highlight");
label.add_class("large-text");</code></pre>
<h3 id="state-based-styling"><a class="header" href="#state-based-styling">State-based Styling</a></h3>
<p>Style widgets differently based on state:</p>
<pre><code class="language-rust ignore">use horizon_lattice_style::{Selector, SelectorState};

// Style for hovered buttons
stylesheet.add_rule(
    Selector::widget("Button").with_state(SelectorState::Hovered),
    Style::new()
        .background_color(Color::from_hex("#7C4DFF").unwrap())
        .build()
);

// Style for pressed buttons
stylesheet.add_rule(
    Selector::widget("Button").with_state(SelectorState::Pressed),
    Style::new()
        .background_color(Color::from_hex("#5E35B1").unwrap())
        .build()
);

// Style for focused inputs
stylesheet.add_rule(
    Selector::widget("LineEdit").with_state(SelectorState::Focused),
    Style::new()
        .border_color(Color::from_hex("#6200EE").unwrap())
        .border_width_all(LengthValue::Px(2.0))
        .build()
);

// Style for disabled widgets
stylesheet.add_rule(
    Selector::any().with_state(SelectorState::Disabled),
    Style::new()
        .opacity(0.5)
        .build()
);</code></pre>
<h2 id="complete-example-theme-aware-app"><a class="header" href="#complete-example-theme-aware-app">Complete Example: Theme-Aware App</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    Label, PushButton, CheckBox, LineEdit, Container, Window, ButtonVariant
};
use horizon_lattice::widget::layout::{VBoxLayout, HBoxLayout, ContentMargins, LayoutKind};
use horizon_lattice::platform::{SystemTheme, ColorScheme, ThemeWatcher};
use horizon_lattice_style::{StyleEngine, Theme, ColorPalette, ThemeMode, Style, LengthValue};
use horizon_lattice::render::Color;
use std::sync::{Arc, RwLock};

fn create_custom_light_theme() -&gt; Theme {
    let mut palette = ColorPalette::light();
    palette.primary = Color::from_hex("#1976D2").unwrap();     // Blue
    palette.secondary = Color::from_hex("#FF5722").unwrap();   // Orange
    Theme::custom(ThemeMode::Light, palette)
}

fn create_custom_dark_theme() -&gt; Theme {
    let mut palette = ColorPalette::dark();
    palette.primary = Color::from_hex("#90CAF9").unwrap();     // Light blue
    palette.secondary = Color::from_hex("#FFAB91").unwrap();   // Light orange
    palette.background = Color::from_rgb8(18, 18, 18);
    Theme::custom(ThemeMode::Dark, palette)
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    // Initialize with system theme preference
    let initial_theme = match SystemTheme::color_scheme() {
        ColorScheme::Dark =&gt; create_custom_dark_theme(),
        _ =&gt; create_custom_light_theme(),
    };

    let style_engine = Arc::new(RwLock::new(StyleEngine::new(initial_theme)));
    app.set_shared_style_engine(style_engine.clone());

    let mut window = Window::new("Theme-Aware App")
        .with_size(500.0, 400.0);

    // Title
    let mut title = Label::new("Settings");
    title.set_style(
        Style::new()
            .font_size(LengthValue::Px(24.0))
            .font_weight(horizon_lattice_style::FontWeight::Bold)
            .build()
    );

    // Theme selection
    let theme_label = Label::new("Theme:");

    let follow_system = CheckBox::new("Follow system theme");
    follow_system.set_checked(true);

    let light_btn = PushButton::new("Light");
    let dark_btn = PushButton::new("Dark")
        .with_variant(ButtonVariant::Secondary);

    // Name input
    let name_label = Label::new("Display name:");
    let name_input = LineEdit::new();
    name_input.set_placeholder("Enter your name...");

    // Save button
    let save_btn = PushButton::new("Save Settings")
        .with_default(true);

    // Track if following system
    let following_system = Arc::new(std::sync::atomic::AtomicBool::new(true));

    // Follow system checkbox
    let following = following_system.clone();
    let engine = style_engine.clone();
    follow_system.toggled().connect(move |&amp;checked| {
        following.store(checked, std::sync::atomic::Ordering::SeqCst);
        if checked {
            // Switch to current system theme
            let mut eng = engine.write().unwrap();
            match SystemTheme::color_scheme() {
                ColorScheme::Dark =&gt; eng.set_theme(create_custom_dark_theme()),
                _ =&gt; eng.set_theme(create_custom_light_theme()),
            }
            eng.invalidate_all();
        }
    });

    // Light button
    let following = following_system.clone();
    let engine = style_engine.clone();
    let checkbox = follow_system.clone();
    light_btn.clicked().connect(move |_| {
        checkbox.set_checked(false);
        following.store(false, std::sync::atomic::Ordering::SeqCst);
        let mut eng = engine.write().unwrap();
        eng.set_theme(create_custom_light_theme());
        eng.invalidate_all();
    });

    // Dark button
    let following = following_system.clone();
    let engine = style_engine.clone();
    let checkbox = follow_system.clone();
    dark_btn.clicked().connect(move |_| {
        checkbox.set_checked(false);
        following.store(false, std::sync::atomic::Ordering::SeqCst);
        let mut eng = engine.write().unwrap();
        eng.set_theme(create_custom_dark_theme());
        eng.invalidate_all();
    });

    // Set up system theme watcher
    let watcher = ThemeWatcher::new()?;
    let engine = style_engine.clone();
    let following = following_system.clone();
    watcher.color_scheme_changed().connect(move |&amp;scheme| {
        if following.load(std::sync::atomic::Ordering::SeqCst) {
            let mut eng = engine.write().unwrap();
            match scheme {
                ColorScheme::Dark =&gt; eng.set_theme(create_custom_dark_theme()),
                _ =&gt; eng.set_theme(create_custom_light_theme()),
            }
            eng.invalidate_all();
        }
    });
    watcher.start()?;

    // Save button action
    let input = name_input.clone();
    save_btn.clicked().connect(move |_| {
        let name = input.text();
        println!("Saved settings for: {}", name);
    });

    // Theme buttons row
    let mut theme_buttons = HBoxLayout::new();
    theme_buttons.set_spacing(8.0);
    theme_buttons.add_widget(light_btn.object_id());
    theme_buttons.add_widget(dark_btn.object_id());

    let mut theme_btn_container = Container::new();
    theme_btn_container.set_layout(LayoutKind::from(theme_buttons));

    // Main layout
    let mut layout = VBoxLayout::new();
    layout.set_content_margins(ContentMargins::uniform(24.0));
    layout.set_spacing(16.0);
    layout.add_widget(title.object_id());
    layout.add_widget(theme_label.object_id());
    layout.add_widget(follow_system.object_id());
    layout.add_widget(theme_btn_container.object_id());
    layout.add_stretch(1);
    layout.add_widget(name_label.object_id());
    layout.add_widget(name_input.object_id());
    layout.add_stretch(1);
    layout.add_widget(save_btn.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="theme-variables"><a class="header" href="#theme-variables">Theme Variables</a></h2>
<p>Themes expose CSS-like variables for consistent styling:</p>
<pre><code class="language-rust ignore">use horizon_lattice_style::ThemeVariables;

// Variables automatically created from palette
// --primary-color, --primary-light, --primary-dark
// --secondary-color, --secondary-light, --secondary-dark
// --background, --surface, --surface-variant
// --text-primary, --text-secondary, --text-disabled
// --error, --warning, --success, --info
// --border, --border-light, --divider

// Spacing variables
// --spacing-xs (4px), --spacing-sm (8px), --spacing-md (16px)
// --spacing-lg (24px), --spacing-xl (32px)

// Border radius variables
// --radius-sm, --radius-md, --radius-lg, --radius-full

// Font size variables
// --font-size-xs through --font-size-2xl</code></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<h3 id="1-always-support-both-light-and-dark"><a class="header" href="#1-always-support-both-light-and-dark">1. Always Support Both Light and Dark</a></h3>
<p>Design your custom themes in pairs:</p>
<pre><code class="language-rust ignore">fn get_theme(dark: bool) -&gt; Theme {
    if dark {
        create_custom_dark_theme()
    } else {
        create_custom_light_theme()
    }
}</code></pre>
<h3 id="2-use-semantic-colors"><a class="header" href="#2-use-semantic-colors">2. Use Semantic Colors</a></h3>
<p>Use palette colors by meaning, not by value:</p>
<pre><code class="language-rust ignore">// Good - uses semantic meaning
let bg = palette.surface;
let text = palette.text_primary;
let accent = palette.primary;

// Bad - hardcoded colors that won't adapt
let bg = Color::WHITE;
let text = Color::BLACK;</code></pre>
<h3 id="3-invalidate-after-theme-changes"><a class="header" href="#3-invalidate-after-theme-changes">3. Invalidate After Theme Changes</a></h3>
<p>Always call <code>invalidate_all()</code> after changing themes:</p>
<pre><code class="language-rust ignore">engine.set_theme(new_theme);
engine.invalidate_all(); // Don't forget this!</code></pre>
<h3 id="4-respect-system-preferences"><a class="header" href="#4-respect-system-preferences">4. Respect System Preferences</a></h3>
<p>Default to following system theme, with manual override option:</p>
<pre><code class="language-rust ignore">// Good UX: follow system by default
let initial = match SystemTheme::color_scheme() {
    ColorScheme::Dark =&gt; Theme::dark(),
    _ =&gt; Theme::light(),
};

// Let users override manually if they want</code></pre>
<h3 id="5-test-high-contrast-mode"><a class="header" href="#5-test-high-contrast-mode">5. Test High Contrast Mode</a></h3>
<p>Always test your app with high contrast theme for accessibility:</p>
<pre><code class="language-rust ignore">// Ensure text is readable in high contrast
let hc_theme = Theme::high_contrast();
// Minimum 4.5:1 contrast ratio for text</code></pre>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li><a href="#tutorial-file-operations">File Operations</a> - Save and load theme preferences</li>
<li><a href="#styling-guide">Styling Guide</a> - Deep dive into the style system</li>
<li><a href="#architecture-overview">Architecture Guide</a> - How theming integrates with the framework</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="tutorial-file-operations"><a class="header" href="#tutorial-file-operations">Tutorial: File Operations</a></h1>
<p>Learn to work with files, dialogs, and application settings.</p>
<h2 id="what-youll-learn-6"><a class="header" href="#what-youll-learn-6">What You’ll Learn</a></h2>
<ul>
<li>Using native file dialogs</li>
<li>Reading and writing files</li>
<li>Managing application settings</li>
<li>Working with application directories</li>
</ul>
<h2 id="prerequisites-6"><a class="header" href="#prerequisites-6">Prerequisites</a></h2>
<ul>
<li>Completed the <a href="#tutorial-theming">Theming</a> tutorial</li>
<li>Understanding of Rust’s <code>std::fs</code> module</li>
</ul>
<h2 id="step-1-native-file-dialogs"><a class="header" href="#step-1-native-file-dialogs">Step 1: Native File Dialogs</a></h2>
<p>Horizon Lattice provides native file dialogs that integrate with the operating system:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::native_dialogs::{
    NativeFileDialogOptions, NativeFileFilter,
    open_file, open_files, save_file, select_directory
};

fn main() {
    // Open a single file
    let options = NativeFileDialogOptions::with_title("Open Document")
        .filter(NativeFileFilter::new("Text Files", &amp;["txt", "md"]))
        .filter(NativeFileFilter::new("All Files", &amp;["*"]));

    if let Some(path) = open_file(options) {
        println!("Selected: {:?}", path);
    }
}</code></pre>
<h3 id="open-multiple-files"><a class="header" href="#open-multiple-files">Open Multiple Files</a></h3>
<pre><code class="language-rust ignore">let options = NativeFileDialogOptions::with_title("Select Images")
    .filter(NativeFileFilter::new("Images", &amp;["png", "jpg", "jpeg", "gif"]))
    .multiple(true);

if let Some(paths) = open_files(options) {
    for path in paths {
        println!("Selected: {:?}", path);
    }
}</code></pre>
<h3 id="save-file-dialog"><a class="header" href="#save-file-dialog">Save File Dialog</a></h3>
<pre><code class="language-rust ignore">let options = NativeFileDialogOptions::with_title("Save Document")
    .default_name("untitled.txt")
    .filter(NativeFileFilter::new("Text Files", &amp;["txt"]));

if let Some(path) = save_file(options) {
    println!("Save to: {:?}", path);
}</code></pre>
<h3 id="select-directory"><a class="header" href="#select-directory">Select Directory</a></h3>
<pre><code class="language-rust ignore">let options = NativeFileDialogOptions::with_title("Choose Folder")
    .directory("/home/user/Documents");

if let Some(path) = select_directory(options) {
    println!("Selected directory: {:?}", path);
}</code></pre>
<h2 id="step-2-the-filedialog-widget"><a class="header" href="#step-2-the-filedialog-widget">Step 2: The FileDialog Widget</a></h2>
<p>For more control, use the <code>FileDialog</code> widget:</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{FileDialog, FileDialogMode, FileFilter};
use std::path::PathBuf;

// Create dialog for opening files
let dialog = FileDialog::for_open()
    .with_title("Open Project")
    .with_directory("/home/user/projects")
    .with_filter(FileFilter::new("Rust Files", &amp;["*.rs", "*.toml"]));

// Connect to selection signal
dialog.file_selected.connect(|path: &amp;PathBuf| {
    println!("Selected: {:?}", path);
});

// Show the dialog
dialog.open();</code></pre>
<h3 id="static-helper-methods"><a class="header" href="#static-helper-methods">Static Helper Methods</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{FileDialog, FileFilter};

// Quick open file dialog
let filters = vec![
    FileFilter::text_files(),
    FileFilter::all_files(),
];

if let Some(path) = FileDialog::get_open_file_name("Open", "/home", &amp;filters) {
    println!("Opening: {:?}", path);
}

// Quick save file dialog
if let Some(path) = FileDialog::get_save_file_name("Save As", "/home", &amp;filters) {
    println!("Saving to: {:?}", path);
}

// Quick directory selection
if let Some(path) = FileDialog::get_existing_directory("Select Folder", "/home") {
    println!("Directory: {:?}", path);
}</code></pre>
<h2 id="step-3-reading-and-writing-files"><a class="header" href="#step-3-reading-and-writing-files">Step 3: Reading and Writing Files</a></h2>
<p>Horizon Lattice provides convenient file operations:</p>
<h3 id="quick-operations"><a class="header" href="#quick-operations">Quick Operations</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::file::operations::{
    read_text, read_bytes, read_lines,
    write_text, write_bytes, append_text
};

// Read entire file as string
let content = read_text("config.txt")?;

// Read file as bytes
let data = read_bytes("image.png")?;

// Read file line by line
let lines = read_lines("data.csv")?;
for line in lines {
    println!("{}", line);
}

// Write string to file
write_text("output.txt", "Hello, World!")?;

// Write bytes to file
write_bytes("data.bin", &amp;[0x00, 0x01, 0x02])?;

// Append to file
append_text("log.txt", "New log entry\n")?;</code></pre>
<h3 id="file-reader"><a class="header" href="#file-reader">File Reader</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::file::File;

let mut file = File::open("document.txt")?;

// Read entire content
let content = file.read_to_string()?;

// Or iterate over lines
let file = File::open("document.txt")?;
for line in file.lines() {
    let line = line?;
    println!("{}", line);
}</code></pre>
<h3 id="file-writer"><a class="header" href="#file-writer">File Writer</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::file::FileWriter;

// Create new file (overwrites existing)
let mut writer = FileWriter::create("output.txt")?;
writer.write_str("Line 1\n")?;
writer.write_line("Line 2")?;
writer.flush()?;

// Append to existing file
let mut writer = FileWriter::append("log.txt")?;
writer.write_line("New entry")?;</code></pre>
<h3 id="atomic-writes-safe-for-config-files"><a class="header" href="#atomic-writes-safe-for-config-files">Atomic Writes (Safe for Config Files)</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::file::operations::atomic_write;
use horizon_lattice::file::AtomicWriter;

// Atomic write ensures file is complete or unchanged
atomic_write("config.json", |writer: &amp;mut AtomicWriter| {
    writer.write_str("{\n")?;
    writer.write_str("  \"version\": 1\n")?;
    writer.write_str("}\n")?;
    Ok(())
})?;
// File is atomically renamed only if write succeeds</code></pre>
<h2 id="step-4-application-settings"><a class="header" href="#step-4-application-settings">Step 4: Application Settings</a></h2>
<p>The <code>Settings</code> API provides a hierarchical key-value store:</p>
<pre><code class="language-rust ignore">use horizon_lattice::file::Settings;

// Create settings
let settings = Settings::new();

// Store values (hierarchical keys with . or / separator)
settings.set("app.window.width", 1024);
settings.set("app.window.height", 768);
settings.set("app/theme/name", "dark");
settings.set("app.recent_files", vec!["file1.txt", "file2.txt"]);

// Retrieve values with type safety
let width: i32 = settings.get("app.window.width").unwrap_or(800);
let theme: String = settings.get_or("app.theme.name", "light".to_string());

// Check if key exists
if settings.contains("app.window.width") {
    println!("Width is configured");
}

// List keys in a group
let window_keys = settings.group_keys("app.window");
// Returns: ["width", "height"]</code></pre>
<h3 id="persisting-settings"><a class="header" href="#persisting-settings">Persisting Settings</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::file::{Settings, SettingsFormat};

// Save to JSON
settings.save_json("config.json")?;

// Save to TOML
settings.save_toml("config.toml")?;

// Save to INI (flat structure)
settings.save_ini("config.ini")?;

// Load from file
let settings = Settings::load_json("config.json")?;
let settings = Settings::load_toml("config.toml")?;</code></pre>
<h3 id="auto-save-settings"><a class="header" href="#auto-save-settings">Auto-Save Settings</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::file::{Settings, SettingsFormat};

let settings = Settings::new();

// Enable auto-save (writes on every change)
settings.set_auto_save("config.json", SettingsFormat::Json);

// Changes are automatically persisted
settings.set("app.volume", 75);  // Saved automatically

// Force immediate write
settings.sync()?;

// Disable auto-save
settings.disable_auto_save();</code></pre>
<h3 id="listening-to-changes"><a class="header" href="#listening-to-changes">Listening to Changes</a></h3>
<pre><code class="language-rust ignore">let settings = Settings::new();

// Connect to change signal
settings.changed().connect(|key: &amp;String| {
    println!("Setting changed: {}", key);
});

settings.set("app.theme", "dark");
// Prints: "Setting changed: app.theme"</code></pre>
<h2 id="step-5-application-directories"><a class="header" href="#step-5-application-directories">Step 5: Application Directories</a></h2>
<p>Get standard directories for your application:</p>
<pre><code class="language-rust ignore">use horizon_lattice::file::path::{
    home_dir, config_dir, data_dir, cache_dir,
    documents_dir, downloads_dir, AppPaths
};

// Standard user directories
let home = home_dir()?;           // /home/user
let config = config_dir()?;       // /home/user/.config
let data = data_dir()?;           // /home/user/.local/share
let cache = cache_dir()?;         // /home/user/.cache
let docs = documents_dir()?;      // /home/user/Documents
let downloads = downloads_dir()?; // /home/user/Downloads

// Application-specific directories
let app_paths = AppPaths::new("com", "example", "myapp")?;
let app_config = app_paths.config();     // ~/.config/myapp
let app_data = app_paths.data();         // ~/.local/share/myapp
let app_cache = app_paths.cache();       // ~/.cache/myapp
let app_logs = app_paths.logs();         // ~/.local/share/myapp/logs</code></pre>
<h2 id="step-6-file-information"><a class="header" href="#step-6-file-information">Step 6: File Information</a></h2>
<p>Query file metadata:</p>
<pre><code class="language-rust ignore">use horizon_lattice::file::{FileInfo, exists, is_file, is_dir, file_size};

// Quick checks
if exists("config.json") {
    println!("Config exists");
}

if is_file("document.txt") {
    let size = file_size("document.txt")?;
    println!("Size: {} bytes", size);
}

if is_dir("projects") {
    println!("Projects directory exists");
}

// Detailed file information
let info = FileInfo::new("document.txt")?;
println!("Size: {} bytes", info.size());
println!("Is readable: {}", info.is_readable());
println!("Is writable: {}", info.is_writable());

if let Some(modified) = info.modified() {
    println!("Modified: {:?}", modified);
}</code></pre>
<h2 id="complete-example-note-taking-app"><a class="header" href="#complete-example-note-taking-app">Complete Example: Note Taking App</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    Window, Container, TextEdit, PushButton, Label,
    FileDialog, FileFilter, ButtonVariant
};
use horizon_lattice::widget::layout::{VBoxLayout, HBoxLayout, ContentMargins, LayoutKind};
use horizon_lattice::file::{Settings, operations::{read_text, atomic_write}, path::AppPaths};
use std::sync::{Arc, Mutex};
use std::path::PathBuf;

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    // Setup app directories and settings
    let app_paths = AppPaths::new("com", "example", "notes")?;
    let settings_path = app_paths.config().join("settings.json");

    let settings = if settings_path.exists() {
        Settings::load_json(&amp;settings_path)?
    } else {
        Settings::new()
    };
    settings.set_auto_save(&amp;settings_path, horizon_lattice::file::SettingsFormat::Json);

    // Track current file
    let current_file: Arc&lt;Mutex&lt;Option&lt;PathBuf&gt;&gt;&gt; = Arc::new(Mutex::new(None));

    // Window setup
    let mut window = Window::new("Notes")
        .with_size(
            settings.get_or("window.width", 600),
            settings.get_or("window.height", 400),
        );

    // Title showing current file
    let title_label = Label::new("Untitled");

    // Text editor
    let text_edit = TextEdit::new();
    text_edit.set_placeholder("Start typing...");

    // Buttons
    let new_btn = PushButton::new("New");
    let open_btn = PushButton::new("Open");
    let save_btn = PushButton::new("Save")
        .with_variant(ButtonVariant::Primary);
    let save_as_btn = PushButton::new("Save As");

    // New button - clear editor
    let editor = text_edit.clone();
    let title = title_label.clone();
    let file = current_file.clone();
    new_btn.clicked().connect(move |_| {
        editor.set_text("");
        title.set_text("Untitled");
        *file.lock().unwrap() = None;
    });

    // Open button
    let editor = text_edit.clone();
    let title = title_label.clone();
    let file = current_file.clone();
    open_btn.clicked().connect(move |_| {
        let filters = vec![
            FileFilter::text_files(),
            FileFilter::all_files(),
        ];

        if let Some(path) = FileDialog::get_open_file_name("Open Note", "", &amp;filters) {
            match read_text(&amp;path) {
                Ok(content) =&gt; {
                    editor.set_text(&amp;content);
                    title.set_text(path.file_name().unwrap().to_str().unwrap());
                    *file.lock().unwrap() = Some(path);
                }
                Err(e) =&gt; {
                    eprintln!("Failed to open file: {}", e);
                }
            }
        }
    });

    // Save button
    let editor = text_edit.clone();
    let file = current_file.clone();
    save_btn.clicked().connect(move |_| {
        let file_lock = file.lock().unwrap();
        if let Some(ref path) = *file_lock {
            let content = editor.text();
            if let Err(e) = atomic_write(path, |w| {
                w.write_str(&amp;content)
            }) {
                eprintln!("Failed to save: {}", e);
            }
        } else {
            // No file set, trigger Save As
            drop(file_lock);
            // Would trigger save_as here
        }
    });

    // Save As button
    let editor = text_edit.clone();
    let title = title_label.clone();
    let file = current_file.clone();
    save_as_btn.clicked().connect(move |_| {
        let filters = vec![
            FileFilter::text_files(),
            FileFilter::all_files(),
        ];

        if let Some(path) = FileDialog::get_save_file_name("Save Note", "", &amp;filters) {
            let content = editor.text();
            match atomic_write(&amp;path, |w| w.write_str(&amp;content)) {
                Ok(()) =&gt; {
                    title.set_text(path.file_name().unwrap().to_str().unwrap());
                    *file.lock().unwrap() = Some(path);
                }
                Err(e) =&gt; {
                    eprintln!("Failed to save: {}", e);
                }
            }
        }
    });

    // Button row
    let mut button_row = HBoxLayout::new();
    button_row.set_spacing(8.0);
    button_row.add_widget(new_btn.object_id());
    button_row.add_widget(open_btn.object_id());
    button_row.add_widget(save_btn.object_id());
    button_row.add_widget(save_as_btn.object_id());
    button_row.add_stretch(1);

    let mut button_container = Container::new();
    button_container.set_layout(LayoutKind::from(button_row));

    // Main layout
    let mut layout = VBoxLayout::new();
    layout.set_content_margins(ContentMargins::uniform(12.0));
    layout.set_spacing(8.0);
    layout.add_widget(title_label.object_id());
    layout.add_widget(button_container.object_id());
    layout.add_widget(text_edit.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h2>
<p>File operations use <code>FileResult&lt;T&gt;</code> which is <code>Result&lt;T, FileError&gt;</code>:</p>
<pre><code class="language-rust ignore">use horizon_lattice::file::{FileResult, FileError, operations::read_text};

fn load_config() -&gt; FileResult&lt;String&gt; {
    read_text("config.json")
}

fn main() {
    match load_config() {
        Ok(content) =&gt; println!("Loaded: {}", content),
        Err(e) if e.is_not_found() =&gt; {
            println!("Config not found, using defaults");
        }
        Err(e) if e.is_permission_denied() =&gt; {
            eprintln!("Permission denied: {}", e);
        }
        Err(e) =&gt; {
            eprintln!("Error: {}", e);
        }
    }
}</code></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<h3 id="1-use-atomic-writes-for-config-files"><a class="header" href="#1-use-atomic-writes-for-config-files">1. Use Atomic Writes for Config Files</a></h3>
<pre><code class="language-rust ignore">// Bad - can leave corrupted file on crash
write_text("config.json", &amp;content)?;

// Good - atomic operation
atomic_write("config.json", |w| w.write_str(&amp;content))?;</code></pre>
<h3 id="2-use-apppaths-for-application-files"><a class="header" href="#2-use-apppaths-for-application-files">2. Use AppPaths for Application Files</a></h3>
<pre><code class="language-rust ignore">// Bad - hardcoded paths
let config_path = "/home/user/.myapp/config.json";

// Good - platform-appropriate paths
let app = AppPaths::new("com", "company", "myapp")?;
let config_path = app.config().join("config.json");</code></pre>
<h3 id="3-validate-file-paths-before-use"><a class="header" href="#3-validate-file-paths-before-use">3. Validate File Paths Before Use</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::file::{exists, is_file, is_readable};

if exists(&amp;path) &amp;&amp; is_file(&amp;path) &amp;&amp; is_readable(&amp;path) {
    let content = read_text(&amp;path)?;
}</code></pre>
<h3 id="4-save-window-state-in-settings"><a class="header" href="#4-save-window-state-in-settings">4. Save Window State in Settings</a></h3>
<pre><code class="language-rust ignore">// On window resize
settings.set("window.width", window.width());
settings.set("window.height", window.height());

// On startup
let width = settings.get_or("window.width", 800);
let height = settings.get_or("window.height", 600);</code></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<ul>
<li><a href="#example-text-editor">Examples: Text Editor</a> - Full-featured editor example</li>
<li><a href="#example-file-browser">Examples: File Browser</a> - Directory navigation example</li>
<li><a href="#architecture-overview">Architecture Guide</a> - Understanding the file system integration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="example-calculator"><a class="header" href="#example-calculator">Example: Calculator</a></h1>
<p>A functional calculator demonstrating button grids, state management, and signal handling.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This example builds a basic calculator with:</p>
<ul>
<li>4x5 button grid for digits and operations</li>
<li>Display label showing current value</li>
<li>Keyboard input support</li>
<li>Basic arithmetic operations (+, -, *, /)</li>
</ul>
<h2 id="key-concepts-1"><a class="header" href="#key-concepts-1">Key Concepts</a></h2>
<ul>
<li><strong>GridLayout</strong>: Arranging buttons in a 2D grid</li>
<li><strong>Signal connections</strong>: Handling button clicks</li>
<li><strong>State management</strong>: Tracking calculator state with Arc/Mutex</li>
<li><strong>Keyboard events</strong>: Accepting keyboard input</li>
</ul>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<h3 id="calculator-state"><a class="header" href="#calculator-state">Calculator State</a></h3>
<pre><code class="language-rust ignore">use std::sync::{Arc, Mutex};

#[derive(Clone)]
struct CalculatorState {
    display: String,
    operand: Option&lt;f64&gt;,
    operator: Option&lt;char&gt;,
    clear_on_next: bool,
}

impl CalculatorState {
    fn new() -&gt; Self {
        Self {
            display: "0".to_string(),
            operand: None,
            operator: None,
            clear_on_next: false,
        }
    }

    fn input_digit(&amp;mut self, digit: char) {
        if self.clear_on_next {
            self.display = String::new();
            self.clear_on_next = false;
        }
        if self.display == "0" &amp;&amp; digit != '.' {
            self.display = digit.to_string();
        } else if digit == '.' &amp;&amp; self.display.contains('.') {
            // Ignore duplicate decimal
        } else {
            self.display.push(digit);
        }
    }

    fn input_operator(&amp;mut self, op: char) {
        let current = self.display.parse::&lt;f64&gt;().unwrap_or(0.0);

        if let (Some(operand), Some(prev_op)) = (self.operand, self.operator) {
            let result = Self::calculate(operand, current, prev_op);
            self.display = Self::format_result(result);
            self.operand = Some(result);
        } else {
            self.operand = Some(current);
        }

        self.operator = Some(op);
        self.clear_on_next = true;
    }

    fn calculate(a: f64, b: f64, op: char) -&gt; f64 {
        match op {
            '+' =&gt; a + b,
            '-' =&gt; a - b,
            '*' =&gt; a * b,
            '/' =&gt; if b != 0.0 { a / b } else { f64::NAN },
            _ =&gt; b,
        }
    }

    fn equals(&amp;mut self) {
        if let (Some(operand), Some(op)) = (self.operand, self.operator) {
            let current = self.display.parse::&lt;f64&gt;().unwrap_or(0.0);
            let result = Self::calculate(operand, current, op);
            self.display = Self::format_result(result);
            self.operand = None;
            self.operator = None;
            self.clear_on_next = true;
        }
    }

    fn clear(&amp;mut self) {
        self.display = "0".to_string();
        self.operand = None;
        self.operator = None;
        self.clear_on_next = false;
    }

    fn format_result(value: f64) -&gt; String {
        if value.is_nan() {
            "Error".to_string()
        } else if value.fract() == 0.0 &amp;&amp; value.abs() &lt; 1e10 {
            format!("{:.0}", value)
        } else {
            format!("{:.8}", value).trim_end_matches('0').trim_end_matches('.').to_string()
        }
    }
}</code></pre>
<h3 id="button-factory"><a class="header" href="#button-factory">Button Factory</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{PushButton, ButtonVariant};
use horizon_lattice::render::Color;

fn create_digit_button(digit: &amp;str) -&gt; PushButton {
    PushButton::new(digit)
        .with_variant(ButtonVariant::Secondary)
}

fn create_operator_button(op: &amp;str) -&gt; PushButton {
    PushButton::new(op)
        .with_variant(ButtonVariant::Primary)
}

fn create_special_button(text: &amp;str) -&gt; PushButton {
    PushButton::new(text)
        .with_variant(ButtonVariant::Outlined)
}</code></pre>
<h2 id="full-source"><a class="header" href="#full-source">Full Source</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    Window, Container, Label, PushButton, ButtonVariant
};
use horizon_lattice::widget::layout::{GridLayout, VBoxLayout, ContentMargins, LayoutKind};
use horizon_lattice::widget::{Widget, WidgetEvent, Key};
use horizon_lattice::render::Color;
use horizon_lattice_style::{Style, LengthValue};
use std::sync::{Arc, Mutex};

// Calculator state (from above)
#[derive(Clone)]
struct CalculatorState {
    display: String,
    operand: Option&lt;f64&gt;,
    operator: Option&lt;char&gt;,
    clear_on_next: bool,
}

impl CalculatorState {
    fn new() -&gt; Self {
        Self {
            display: "0".to_string(),
            operand: None,
            operator: None,
            clear_on_next: false,
        }
    }

    fn input_digit(&amp;mut self, digit: char) {
        if self.clear_on_next {
            self.display = String::new();
            self.clear_on_next = false;
        }
        if self.display == "0" &amp;&amp; digit != '.' {
            self.display = digit.to_string();
        } else if digit == '.' &amp;&amp; self.display.contains('.') {
            // Ignore duplicate decimal
        } else {
            self.display.push(digit);
        }
    }

    fn input_operator(&amp;mut self, op: char) {
        let current = self.display.parse::&lt;f64&gt;().unwrap_or(0.0);
        if let (Some(operand), Some(prev_op)) = (self.operand, self.operator) {
            let result = Self::calculate(operand, current, prev_op);
            self.display = Self::format_result(result);
            self.operand = Some(result);
        } else {
            self.operand = Some(current);
        }
        self.operator = Some(op);
        self.clear_on_next = true;
    }

    fn calculate(a: f64, b: f64, op: char) -&gt; f64 {
        match op {
            '+' =&gt; a + b,
            '-' =&gt; a - b,
            '*' =&gt; a * b,
            '/' =&gt; if b != 0.0 { a / b } else { f64::NAN },
            _ =&gt; b,
        }
    }

    fn equals(&amp;mut self) {
        if let (Some(operand), Some(op)) = (self.operand, self.operator) {
            let current = self.display.parse::&lt;f64&gt;().unwrap_or(0.0);
            let result = Self::calculate(operand, current, op);
            self.display = Self::format_result(result);
            self.operand = None;
            self.operator = None;
            self.clear_on_next = true;
        }
    }

    fn clear(&amp;mut self) {
        self.display = "0".to_string();
        self.operand = None;
        self.operator = None;
        self.clear_on_next = false;
    }

    fn format_result(value: f64) -&gt; String {
        if value.is_nan() {
            "Error".to_string()
        } else if value.fract() == 0.0 &amp;&amp; value.abs() &lt; 1e10 {
            format!("{:.0}", value)
        } else {
            format!("{:.8}", value)
                .trim_end_matches('0')
                .trim_end_matches('.')
                .to_string()
        }
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Calculator")
        .with_size(280.0, 400.0);

    // Shared state
    let state = Arc::new(Mutex::new(CalculatorState::new()));

    // Display label
    let mut display = Label::new("0");
    display.set_style(
        Style::new()
            .font_size(LengthValue::Px(32.0))
            .padding_all(LengthValue::Px(16.0))
            .background_color(Color::from_rgb8(40, 40, 40))
            .color(Color::WHITE)
            .build()
    );

    // Create buttons
    let buttons = [
        ("C", 0, 0, ButtonVariant::Outlined),
        ("+/-", 0, 1, ButtonVariant::Outlined),
        ("%", 0, 2, ButtonVariant::Outlined),
        ("/", 0, 3, ButtonVariant::Primary),
        ("7", 1, 0, ButtonVariant::Secondary),
        ("8", 1, 1, ButtonVariant::Secondary),
        ("9", 1, 2, ButtonVariant::Secondary),
        ("*", 1, 3, ButtonVariant::Primary),
        ("4", 2, 0, ButtonVariant::Secondary),
        ("5", 2, 1, ButtonVariant::Secondary),
        ("6", 2, 2, ButtonVariant::Secondary),
        ("-", 2, 3, ButtonVariant::Primary),
        ("1", 3, 0, ButtonVariant::Secondary),
        ("2", 3, 1, ButtonVariant::Secondary),
        ("3", 3, 2, ButtonVariant::Secondary),
        ("+", 3, 3, ButtonVariant::Primary),
        ("0", 4, 0, ButtonVariant::Secondary), // Will span 2 columns
        (".", 4, 2, ButtonVariant::Secondary),
        ("=", 4, 3, ButtonVariant::Primary),
    ];

    // Build grid layout
    let mut grid = GridLayout::new();
    grid.set_horizontal_spacing(4.0);
    grid.set_vertical_spacing(4.0);

    for (text, row, col, variant) in buttons {
        let button = PushButton::new(text).with_variant(variant);

        // Connect button to calculator logic
        let state_clone = state.clone();
        let display_clone = display.clone();
        let text_owned = text.to_string();

        button.clicked().connect(move |_| {
            let mut calc = state_clone.lock().unwrap();
            let ch = text_owned.chars().next().unwrap();

            match text_owned.as_str() {
                "C" =&gt; calc.clear(),
                "=" =&gt; calc.equals(),
                "+/-" =&gt; {
                    if let Ok(val) = calc.display.parse::&lt;f64&gt;() {
                        calc.display = CalculatorState::format_result(-val);
                    }
                }
                "%" =&gt; {
                    if let Ok(val) = calc.display.parse::&lt;f64&gt;() {
                        calc.display = CalculatorState::format_result(val / 100.0);
                    }
                }
                "+" | "-" | "*" | "/" =&gt; calc.input_operator(ch),
                _ =&gt; calc.input_digit(ch),
            }

            display_clone.set_text(&amp;calc.display);
        });

        // Special case: "0" spans 2 columns
        if text == "0" {
            grid.add_widget_spanning(button.object_id(), row, col, 1, 2);
        } else {
            grid.add_widget_at(button.object_id(), row, col);
        }
    }

    let mut grid_container = Container::new();
    grid_container.set_layout(LayoutKind::from(grid));

    // Main layout
    let mut layout = VBoxLayout::new();
    layout.set_content_margins(ContentMargins::uniform(8.0));
    layout.set_spacing(8.0);
    layout.add_widget(display.object_id());
    layout.add_widget(grid_container.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="features-demonstrated"><a class="header" href="#features-demonstrated">Features Demonstrated</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>GridLayout</strong></td><td>4-column button grid with cell spanning</td></tr>
<tr><td><strong>State Management</strong></td><td>Arc/Mutex for shared calculator state</td></tr>
<tr><td><strong>Signal Connections</strong></td><td>Button clicks update display</td></tr>
<tr><td><strong>Button Variants</strong></td><td>Visual distinction between button types</td></tr>
<tr><td><strong>Inline Styling</strong></td><td>Custom display label styling</td></tr>
<tr><td><strong>Builder Pattern</strong></td><td>Fluent widget configuration</td></tr>
</tbody>
</table>
</div>
<h2 id="exercises"><a class="header" href="#exercises">Exercises</a></h2>
<ol>
<li><strong>Add keyboard support</strong>: Handle number keys, operators, Enter for equals, Escape for clear</li>
<li><strong>Add memory functions</strong>: M+, M-, MR, MC buttons</li>
<li><strong>Add scientific functions</strong>: sin, cos, tan, sqrt, power</li>
<li><strong>Add history</strong>: Show previous calculations</li>
<li><strong>Add parentheses</strong>: Support expression grouping</li>
</ol>
<h2 id="related-examples"><a class="header" href="#related-examples">Related Examples</a></h2>
<ul>
<li><a href="#example-settings-dialog">Settings Dialog</a> - More complex layout patterns</li>
<li><a href="#example-text-editor">Text Editor</a> - Keyboard input handling</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="example-text-editor"><a class="header" href="#example-text-editor">Example: Text Editor</a></h1>
<p>A functional text editor demonstrating file operations, menus, and text editing.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>This example builds a text editor with:</p>
<ul>
<li>Multi-line text editing with TextEdit widget</li>
<li>File menu with New, Open, Save, Save As</li>
<li>Edit menu with Undo, Redo, Cut, Copy, Paste</li>
<li>Status bar showing cursor position</li>
<li>Dirty file tracking with save prompts</li>
</ul>
<h2 id="key-concepts-2"><a class="header" href="#key-concepts-2">Key Concepts</a></h2>
<ul>
<li><strong>MainWindow</strong>: Application window with menu bar and status bar</li>
<li><strong>MenuBar and Menu</strong>: Standard application menus with keyboard shortcuts</li>
<li><strong>TextEdit</strong>: Multi-line text editing widget</li>
<li><strong>File dialogs</strong>: Open and save file dialogs</li>
<li><strong>Action</strong>: Reusable menu/toolbar commands</li>
</ul>
<h2 id="full-source-1"><a class="header" href="#full-source-1">Full Source</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    MainWindow, TextEdit, StatusBar, Menu, MenuBar, Action,
    FileDialog, FileFilter, MessageBox
};
use horizon_lattice::file::operations::{read_text, atomic_write};
use std::path::PathBuf;
use std::sync::{Arc, Mutex};

struct EditorState {
    current_file: Option&lt;PathBuf&gt;,
    is_modified: bool,
}

impl EditorState {
    fn new() -&gt; Self {
        Self { current_file: None, is_modified: false }
    }

    fn window_title(&amp;self) -&gt; String {
        let name = self.current_file
            .as_ref()
            .and_then(|p| p.file_name())
            .and_then(|n| n.to_str())
            .unwrap_or("Untitled");
        if self.is_modified {
            format!("*{} - Text Editor", name)
        } else {
            format!("{} - Text Editor", name)
        }
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;
    let state = Arc::new(Mutex::new(EditorState::new()));

    let mut window = MainWindow::new("Text Editor")
        .with_size(800.0, 600.0);

    // Text editor widget
    let text_edit = TextEdit::new();

    // Status bar
    let status_bar = StatusBar::new();
    status_bar.show_message("Ready");

    // Track modifications
    let state_clone = state.clone();
    let window_clone = window.clone();
    text_edit.text_changed.connect(move || {
        let mut s = state_clone.lock().unwrap();
        s.is_modified = true;
        window_clone.set_title(&amp;s.window_title());
    });

    // === File Menu ===
    let mut file_menu = Menu::new("File");

    let new_action = Action::new("New").with_shortcut("Ctrl+N");
    let open_action = Action::new("Open...").with_shortcut("Ctrl+O");
    let save_action = Action::new("Save").with_shortcut("Ctrl+S");
    let save_as_action = Action::new("Save As...");
    let quit_action = Action::new("Quit").with_shortcut("Ctrl+Q");

    // New file handler
    let editor = text_edit.clone();
    let state_clone = state.clone();
    let window_clone = window.clone();
    new_action.triggered.connect(move || {
        editor.set_text("");
        let mut s = state_clone.lock().unwrap();
        s.current_file = None;
        s.is_modified = false;
        window_clone.set_title(&amp;s.window_title());
    });

    // Open file handler
    let editor = text_edit.clone();
    let state_clone = state.clone();
    let window_clone = window.clone();
    open_action.triggered.connect(move || {
        let filters = vec![FileFilter::text_files(), FileFilter::all_files()];
        if let Some(path) = FileDialog::get_open_file_name("Open", "", &amp;filters) {
            if let Ok(content) = read_text(&amp;path) {
                editor.set_text(&amp;content);
                let mut s = state_clone.lock().unwrap();
                s.current_file = Some(path);
                s.is_modified = false;
                window_clone.set_title(&amp;s.window_title());
            }
        }
    });

    // Save file handler
    let editor = text_edit.clone();
    let state_clone = state.clone();
    let window_clone = window.clone();
    save_action.triggered.connect(move || {
        let s = state_clone.lock().unwrap();
        if let Some(ref path) = s.current_file {
            let content = editor.text();
            drop(s);
            if atomic_write(path, |w| w.write_str(&amp;content)).is_ok() {
                let mut s = state_clone.lock().unwrap();
                s.is_modified = false;
                window_clone.set_title(&amp;s.window_title());
            }
        }
    });

    // Save As handler
    let editor = text_edit.clone();
    let state_clone = state.clone();
    let window_clone = window.clone();
    save_as_action.triggered.connect(move || {
        let filters = vec![FileFilter::text_files(), FileFilter::all_files()];
        if let Some(path) = FileDialog::get_save_file_name("Save As", "", &amp;filters) {
            let content = editor.text();
            if atomic_write(&amp;path, |w| w.write_str(&amp;content)).is_ok() {
                let mut s = state_clone.lock().unwrap();
                s.current_file = Some(path);
                s.is_modified = false;
                window_clone.set_title(&amp;s.window_title());
            }
        }
    });

    // Quit handler
    let app_clone = app.clone();
    quit_action.triggered.connect(move || {
        app_clone.quit();
    });

    file_menu.add_action(new_action);
    file_menu.add_action(open_action);
    file_menu.add_separator();
    file_menu.add_action(save_action);
    file_menu.add_action(save_as_action);
    file_menu.add_separator();
    file_menu.add_action(quit_action);

    // === Edit Menu ===
    let mut edit_menu = Menu::new("Edit");

    let undo_action = Action::new("Undo").with_shortcut("Ctrl+Z");
    let redo_action = Action::new("Redo").with_shortcut("Ctrl+Y");
    let cut_action = Action::new("Cut").with_shortcut("Ctrl+X");
    let copy_action = Action::new("Copy").with_shortcut("Ctrl+C");
    let paste_action = Action::new("Paste").with_shortcut("Ctrl+V");
    let select_all_action = Action::new("Select All").with_shortcut("Ctrl+A");

    let editor = text_edit.clone();
    undo_action.triggered.connect(move || editor.undo());

    let editor = text_edit.clone();
    redo_action.triggered.connect(move || editor.redo());

    let editor = text_edit.clone();
    cut_action.triggered.connect(move || editor.cut());

    let editor = text_edit.clone();
    copy_action.triggered.connect(move || editor.copy());

    let editor = text_edit.clone();
    paste_action.triggered.connect(move || editor.paste());

    let editor = text_edit.clone();
    select_all_action.triggered.connect(move || editor.select_all());

    edit_menu.add_action(undo_action);
    edit_menu.add_action(redo_action);
    edit_menu.add_separator();
    edit_menu.add_action(cut_action);
    edit_menu.add_action(copy_action);
    edit_menu.add_action(paste_action);
    edit_menu.add_separator();
    edit_menu.add_action(select_all_action);

    // === View Menu ===
    let mut view_menu = Menu::new("View");
    let word_wrap_action = Action::new("Word Wrap").with_checkable(true);
    word_wrap_action.set_checked(true);

    let editor = text_edit.clone();
    word_wrap_action.toggled.connect(move |&amp;checked| {
        editor.set_word_wrap(checked);
    });

    view_menu.add_action(word_wrap_action);

    // Build menu bar
    let mut menu_bar = MenuBar::new();
    menu_bar.add_menu(file_menu);
    menu_bar.add_menu(edit_menu);
    menu_bar.add_menu(view_menu);

    // Assemble window
    window.set_menu_bar(menu_bar);
    window.set_central_widget(text_edit.object_id());
    window.set_status_bar(status_bar);
    window.show();

    app.run()
}</code></pre>
<h2 id="features-demonstrated-1"><a class="header" href="#features-demonstrated-1">Features Demonstrated</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>MainWindow</strong></td><td>Window with menu bar, central widget, status bar</td></tr>
<tr><td><strong>MenuBar/Menu</strong></td><td>Hierarchical menu structure with separators</td></tr>
<tr><td><strong>Action</strong></td><td>Commands with keyboard shortcuts</td></tr>
<tr><td><strong>TextEdit</strong></td><td>Multi-line text editing with undo/redo</td></tr>
<tr><td><strong>FileDialog</strong></td><td>Native file dialogs</td></tr>
<tr><td><strong>State Tracking</strong></td><td>Modified flag and dynamic window title</td></tr>
</tbody>
</table>
</div>
<h2 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h2>
<ol>
<li><strong>Add Find/Replace</strong>: Implement search with Ctrl+F</li>
<li><strong>Add recent files</strong>: Show recently opened files in menu</li>
<li><strong>Add line numbers</strong>: Display line numbers in margin</li>
<li><strong>Add syntax highlighting</strong>: Use PlainTextEdit with highlighter</li>
<li><strong>Add multiple tabs</strong>: Support multiple documents</li>
</ol>
<h2 id="related-examples-1"><a class="header" href="#related-examples-1">Related Examples</a></h2>
<ul>
<li><a href="#example-file-browser">File Browser</a> - File navigation</li>
<li><a href="#example-settings-dialog">Settings Dialog</a> - Preferences</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="example-file-browser"><a class="header" href="#example-file-browser">Example: File Browser</a></h1>
<p>A file browser demonstrating TreeView, ListView, and file operations.</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<p>This example builds a file browser with:</p>
<ul>
<li>TreeView for directory hierarchy</li>
<li>ListView for file listing</li>
<li>Splitter for resizable panes</li>
<li>Toolbar with navigation buttons</li>
<li>Address bar for direct path entry</li>
</ul>
<h2 id="key-concepts-3"><a class="header" href="#key-concepts-3">Key Concepts</a></h2>
<ul>
<li><strong>TreeView</strong>: Hierarchical directory display</li>
<li><strong>ListView</strong>: File listing with icons</li>
<li><strong>Splitter</strong>: Resizable split view</li>
<li><strong>Models</strong>: Custom data models for files</li>
<li><strong>File operations</strong>: Reading directory contents</li>
</ul>
<h2 id="full-source-2"><a class="header" href="#full-source-2">Full Source</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    Window, Container, TreeView, ListView, Splitter, ToolBar, LineEdit,
    PushButton, Label, Action
};
use horizon_lattice::widget::layout::{VBoxLayout, HBoxLayout, LayoutKind};
use horizon_lattice::model::{TreeModel, ListModel, ModelIndex};
use horizon_lattice::file::{FileInfo, path::{home_dir, parent}};
use std::path::PathBuf;
use std::sync::{Arc, Mutex};
use std::fs;

#[derive(Clone)]
struct FileEntry {
    name: String,
    path: PathBuf,
    is_dir: bool,
    size: u64,
}

impl FileEntry {
    fn from_path(path: PathBuf) -&gt; Option&lt;Self&gt; {
        let info = FileInfo::new(&amp;path).ok()?;
        Some(Self {
            name: path.file_name()?.to_str()?.to_string(),
            path,
            is_dir: info.is_dir(),
            size: info.size(),
        })
    }

    fn size_string(&amp;self) -&gt; String {
        if self.is_dir {
            String::new()
        } else if self.size &lt; 1024 {
            format!("{} B", self.size)
        } else if self.size &lt; 1024 * 1024 {
            format!("{:.1} KB", self.size as f64 / 1024.0)
        } else {
            format!("{:.1} MB", self.size as f64 / (1024.0 * 1024.0))
        }
    }
}

fn list_directory(path: &amp;PathBuf) -&gt; Vec&lt;FileEntry&gt; {
    let mut entries = Vec::new();
    if let Ok(read_dir) = fs::read_dir(path) {
        for entry in read_dir.filter_map(|e| e.ok()) {
            if let Some(file_entry) = FileEntry::from_path(entry.path()) {
                entries.push(file_entry);
            }
        }
    }
    // Sort: directories first, then alphabetically
    entries.sort_by(|a, b| {
        match (a.is_dir, b.is_dir) {
            (true, false) =&gt; std::cmp::Ordering::Less,
            (false, true) =&gt; std::cmp::Ordering::Greater,
            _ =&gt; a.name.to_lowercase().cmp(&amp;b.name.to_lowercase()),
        }
    });
    entries
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("File Browser")
        .with_size(900.0, 600.0);

    // Current path state
    let current_path = Arc::new(Mutex::new(home_dir()?));

    // Address bar
    let address_bar = LineEdit::new();
    address_bar.set_text(current_path.lock().unwrap().to_str().unwrap());

    // Navigation buttons
    let back_btn = PushButton::new("Back");
    let up_btn = PushButton::new("Up");
    let home_btn = PushButton::new("Home");
    let refresh_btn = PushButton::new("Refresh");

    // Directory tree (left pane)
    let tree_view = TreeView::new();

    // File list (right pane)
    let list_model = Arc::new(Mutex::new(ListModel::new(Vec::&lt;FileEntry&gt;::new())));
    let list_view = ListView::new()
        .with_model(list_model.lock().unwrap().clone());

    // Function to update file list
    let update_list = {
        let model = list_model.clone();
        let address = address_bar.clone();
        move |path: &amp;PathBuf| {
            let entries = list_directory(path);
            model.lock().unwrap().set_items(entries);
            address.set_text(path.to_str().unwrap_or(""));
        }
    };

    // Initial load
    update_list(&amp;current_path.lock().unwrap().clone());

    // Back button (history would be implemented)
    back_btn.clicked().connect(|_| {
        // Would implement navigation history
    });

    // Up button
    let path = current_path.clone();
    let update = update_list.clone();
    up_btn.clicked().connect(move |_| {
        let mut p = path.lock().unwrap();
        if let Some(parent_path) = parent(&amp;*p) {
            *p = parent_path.clone();
            update(&amp;parent_path);
        }
    });

    // Home button
    let path = current_path.clone();
    let update = update_list.clone();
    home_btn.clicked().connect(move |_| {
        if let Ok(home) = home_dir() {
            *path.lock().unwrap() = home.clone();
            update(&amp;home);
        }
    });

    // Refresh button
    let path = current_path.clone();
    let update = update_list.clone();
    refresh_btn.clicked().connect(move |_| {
        let p = path.lock().unwrap().clone();
        update(&amp;p);
    });

    // Address bar enter key
    let path = current_path.clone();
    let update = update_list.clone();
    address_bar.return_pressed.connect(move || {
        let text = address_bar.text();
        let new_path = PathBuf::from(&amp;text);
        if new_path.is_dir() {
            *path.lock().unwrap() = new_path.clone();
            update(&amp;new_path);
        }
    });

    // Double-click on list item
    let path = current_path.clone();
    let model = list_model.clone();
    let update = update_list.clone();
    list_view.double_clicked.connect(move |index: &amp;ModelIndex| {
        let m = model.lock().unwrap();
        if let Some(entry) = m.get(index.row() as usize) {
            if entry.is_dir {
                let new_path = entry.path.clone();
                drop(m);
                *path.lock().unwrap() = new_path.clone();
                update(&amp;new_path);
            }
        }
    });

    // Toolbar layout
    let mut toolbar = HBoxLayout::new();
    toolbar.set_spacing(4.0);
    toolbar.add_widget(back_btn.object_id());
    toolbar.add_widget(up_btn.object_id());
    toolbar.add_widget(home_btn.object_id());
    toolbar.add_widget(refresh_btn.object_id());
    toolbar.add_widget(address_bar.object_id());

    let mut toolbar_container = Container::new();
    toolbar_container.set_layout(LayoutKind::from(toolbar));

    // Splitter with tree and list
    let mut splitter = Splitter::new();
    splitter.add_widget(tree_view.object_id());
    splitter.add_widget(list_view.object_id());
    splitter.set_sizes(&amp;[200, 600]);

    // Main layout
    let mut layout = VBoxLayout::new();
    layout.add_widget(toolbar_container.object_id());
    layout.add_widget(splitter.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="features-demonstrated-2"><a class="header" href="#features-demonstrated-2">Features Demonstrated</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>TreeView</strong></td><td>Hierarchical directory tree</td></tr>
<tr><td><strong>ListView</strong></td><td>File list with model</td></tr>
<tr><td><strong>Splitter</strong></td><td>Resizable split panes</td></tr>
<tr><td><strong>ListModel</strong></td><td>Dynamic file list model</td></tr>
<tr><td><strong>File operations</strong></td><td>Reading directories</td></tr>
<tr><td><strong>Navigation</strong></td><td>Up, Home, address bar</td></tr>
</tbody>
</table>
</div>
<h2 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h2>
<ol>
<li><strong>Add file icons</strong>: Show different icons for file types</li>
<li><strong>Add context menu</strong>: Right-click options (Open, Delete, Rename)</li>
<li><strong>Add file details</strong>: Show columns for size, date, type</li>
<li><strong>Add search</strong>: Filter files by name</li>
<li><strong>Add bookmarks</strong>: Quick access sidebar</li>
</ol>
<h2 id="related-examples-2"><a class="header" href="#related-examples-2">Related Examples</a></h2>
<ul>
<li><a href="#example-text-editor">Text Editor</a> - File opening</li>
<li><a href="#example-image-viewer">Image Viewer</a> - Image browsing</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="example-image-viewer"><a class="header" href="#example-image-viewer">Example: Image Viewer</a></h1>
<p>An image viewer demonstrating image loading, zoom/pan, and thumbnail lists.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>This example builds an image viewer with:</p>
<ul>
<li>ImageWidget for displaying images</li>
<li>Zoom and pan controls</li>
<li>Thumbnail strip for navigation</li>
<li>File open dialog for images</li>
<li>Fit-to-window and actual-size modes</li>
</ul>
<h2 id="key-concepts-4"><a class="header" href="#key-concepts-4">Key Concepts</a></h2>
<ul>
<li><strong>ImageWidget</strong>: Image display with scaling modes</li>
<li><strong>ScrollArea</strong>: Panning larger images</li>
<li><strong>ListView</strong>: Thumbnail strip</li>
<li><strong>File dialogs</strong>: Opening image files</li>
<li><strong>Keyboard shortcuts</strong>: Navigation controls</li>
</ul>
<h2 id="full-source-3"><a class="header" href="#full-source-3">Full Source</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    Window, Container, ImageWidget, ScrollArea, ListView, Splitter,
    PushButton, Label, Slider, FileDialog, FileFilter,
    ImageScaleMode
};
use horizon_lattice::widget::layout::{VBoxLayout, HBoxLayout, LayoutKind, ContentMargins};
use horizon_lattice::model::ListModel;
use horizon_lattice::widget::{Widget, WidgetEvent, Key};
use std::path::PathBuf;
use std::sync::{Arc, Mutex};

#[derive(Clone)]
struct ImageEntry {
    path: PathBuf,
    name: String,
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("Image Viewer")
        .with_size(1000.0, 700.0);

    // Current state
    let current_index = Arc::new(Mutex::new(0usize));
    let images: Arc&lt;Mutex&lt;Vec&lt;ImageEntry&gt;&gt;&gt; = Arc::new(Mutex::new(Vec::new()));

    // Main image display
    let image_widget = ImageWidget::new();
    image_widget.set_scale_mode(ImageScaleMode::Fit);

    // Wrap in scroll area for panning
    let mut scroll_area = ScrollArea::new();
    scroll_area.set_widget(image_widget.object_id());

    // Zoom controls
    let zoom_slider = Slider::new();
    zoom_slider.set_range(10, 400);  // 10% to 400%
    zoom_slider.set_value(100);

    let zoom_label = Label::new("100%");

    let fit_btn = PushButton::new("Fit");
    let actual_btn = PushButton::new("1:1");

    // Zoom slider updates scale
    let image = image_widget.clone();
    let label = zoom_label.clone();
    zoom_slider.value_changed.connect(move |&amp;value| {
        let scale = value as f32 / 100.0;
        image.set_scale(scale);
        label.set_text(&amp;format!("{}%", value));
    });

    // Fit button
    let image = image_widget.clone();
    let slider = zoom_slider.clone();
    let label = zoom_label.clone();
    fit_btn.clicked().connect(move |_| {
        image.set_scale_mode(ImageScaleMode::Fit);
        slider.set_value(100);
        label.set_text("Fit");
    });

    // Actual size button
    let image = image_widget.clone();
    let slider = zoom_slider.clone();
    let label = zoom_label.clone();
    actual_btn.clicked().connect(move |_| {
        image.set_scale_mode(ImageScaleMode::None);
        image.set_scale(1.0);
        slider.set_value(100);
        label.set_text("100%");
    });

    // Navigation buttons
    let prev_btn = PushButton::new("Previous");
    let next_btn = PushButton::new("Next");
    let open_btn = PushButton::new("Open...");

    // Thumbnail list
    let thumbnail_model = Arc::new(Mutex::new(ListModel::new(Vec::&lt;String&gt;::new())));
    let thumbnail_list = ListView::new()
        .with_model(thumbnail_model.lock().unwrap().clone());

    // Open button - load images
    let image = image_widget.clone();
    let imgs = images.clone();
    let idx = current_index.clone();
    let thumbs = thumbnail_model.clone();
    open_btn.clicked().connect(move |_| {
        let filters = vec![
            FileFilter::image_files(),
            FileFilter::all_files(),
        ];

        if let Some(paths) = FileDialog::get_open_file_names("Open Images", "", &amp;filters) {
            let entries: Vec&lt;ImageEntry&gt; = paths.into_iter().map(|p| {
                let name = p.file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("Unknown")
                    .to_string();
                ImageEntry { path: p, name }
            }).collect();

            if !entries.is_empty() {
                // Update thumbnail list
                let names: Vec&lt;String&gt; = entries.iter().map(|e| e.name.clone()).collect();
                thumbs.lock().unwrap().set_items(names);

                // Load first image
                image.set_source_file(&amp;entries[0].path);

                *imgs.lock().unwrap() = entries;
                *idx.lock().unwrap() = 0;
            }
        }
    });

    // Previous button
    let image = image_widget.clone();
    let imgs = images.clone();
    let idx = current_index.clone();
    prev_btn.clicked().connect(move |_| {
        let entries = imgs.lock().unwrap();
        let mut i = idx.lock().unwrap();
        if !entries.is_empty() &amp;&amp; *i &gt; 0 {
            *i -= 1;
            image.set_source_file(&amp;entries[*i].path);
        }
    });

    // Next button
    let image = image_widget.clone();
    let imgs = images.clone();
    let idx = current_index.clone();
    next_btn.clicked().connect(move |_| {
        let entries = imgs.lock().unwrap();
        let mut i = idx.lock().unwrap();
        if !entries.is_empty() &amp;&amp; *i &lt; entries.len() - 1 {
            *i += 1;
            image.set_source_file(&amp;entries[*i].path);
        }
    });

    // Thumbnail click
    let image = image_widget.clone();
    let imgs = images.clone();
    let idx = current_index.clone();
    thumbnail_list.clicked.connect(move |index| {
        let entries = imgs.lock().unwrap();
        let row = index.row() as usize;
        if row &lt; entries.len() {
            image.set_source_file(&amp;entries[row].path);
            *idx.lock().unwrap() = row;
        }
    });

    // Toolbar
    let mut toolbar = HBoxLayout::new();
    toolbar.set_spacing(8.0);
    toolbar.add_widget(open_btn.object_id());
    toolbar.add_widget(prev_btn.object_id());
    toolbar.add_widget(next_btn.object_id());
    toolbar.add_stretch(1);
    toolbar.add_widget(fit_btn.object_id());
    toolbar.add_widget(actual_btn.object_id());
    toolbar.add_widget(zoom_slider.object_id());
    toolbar.add_widget(zoom_label.object_id());

    let mut toolbar_container = Container::new();
    toolbar_container.set_layout(LayoutKind::from(toolbar));

    // Main content with splitter
    let mut splitter = Splitter::new();
    splitter.add_widget(scroll_area.object_id());
    splitter.add_widget(thumbnail_list.object_id());
    splitter.set_sizes(&amp;[700, 200]);

    // Main layout
    let mut layout = VBoxLayout::new();
    layout.set_content_margins(ContentMargins::uniform(8.0));
    layout.set_spacing(8.0);
    layout.add_widget(toolbar_container.object_id());
    layout.add_widget(splitter.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="features-demonstrated-3"><a class="header" href="#features-demonstrated-3">Features Demonstrated</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>ImageWidget</strong></td><td>Image display with scaling</td></tr>
<tr><td><strong>ScrollArea</strong></td><td>Pan large images</td></tr>
<tr><td><strong>Slider</strong></td><td>Zoom control</td></tr>
<tr><td><strong>ListView</strong></td><td>Thumbnail strip</td></tr>
<tr><td><strong>Splitter</strong></td><td>Resizable panels</td></tr>
<tr><td><strong>FileDialog</strong></td><td>Multi-file selection</td></tr>
</tbody>
</table>
</div>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<ol>
<li><strong>Add keyboard navigation</strong>: Arrow keys for prev/next</li>
<li><strong>Add mouse wheel zoom</strong>: Zoom centered on cursor</li>
<li><strong>Add drag-to-pan</strong>: Click and drag to pan</li>
<li><strong>Add slideshow mode</strong>: Auto-advance with timer</li>
<li><strong>Add image info</strong>: Show dimensions, file size, date</li>
</ol>
<h2 id="related-examples-3"><a class="header" href="#related-examples-3">Related Examples</a></h2>
<ul>
<li><a href="#example-file-browser">File Browser</a> - File navigation</li>
<li><a href="#example-text-editor">Text Editor</a> - File operations</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="example-settings-dialog"><a class="header" href="#example-settings-dialog">Example: Settings Dialog</a></h1>
<p>A settings dialog demonstrating TabWidget, form inputs, and preferences management.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>This example builds a settings dialog with:</p>
<ul>
<li>TabWidget for organized settings categories</li>
<li>Various input widgets (CheckBox, ComboBox, SpinBox, etc.)</li>
<li>Apply/OK/Cancel buttons with standard behavior</li>
<li>Settings persistence with auto-save</li>
</ul>
<h2 id="key-concepts-5"><a class="header" href="#key-concepts-5">Key Concepts</a></h2>
<ul>
<li><strong>TabWidget</strong>: Organize settings into categories</li>
<li><strong>FormLayout</strong>: Label-field arrangement</li>
<li><strong>Dialog</strong>: Modal dialog with accept/reject</li>
<li><strong>Settings</strong>: Persistent preferences storage</li>
<li><strong>Validation</strong>: Input validation before saving</li>
</ul>
<h2 id="full-source-4"><a class="header" href="#full-source-4">Full Source</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    Dialog, TabWidget, Container, Label, CheckBox, ComboBox, SpinBox,
    LineEdit, PushButton, GroupBox, ColorButton, FontComboBox,
    ButtonVariant
};
use horizon_lattice::widget::layout::{
    VBoxLayout, HBoxLayout, FormLayout, ContentMargins, LayoutKind
};
use horizon_lattice::file::{Settings, SettingsFormat, path::AppPaths};
use horizon_lattice::render::Color;
use std::sync::{Arc, Mutex};

fn create_general_tab(settings: &amp;Settings) -&gt; Container {
    let mut form = FormLayout::new();

    // Language selection
    let language = ComboBox::new();
    language.add_items(&amp;["English", "Spanish", "French", "German", "Japanese"]);
    language.set_current_index(settings.get_or("general.language", 0));
    form.add_row(Label::new("Language:"), language);

    // Startup behavior
    let restore_session = CheckBox::new("Restore previous session on startup");
    restore_session.set_checked(settings.get_or("general.restore_session", true));
    form.add_spanning_widget(restore_session);

    let check_updates = CheckBox::new("Check for updates automatically");
    check_updates.set_checked(settings.get_or("general.check_updates", true));
    form.add_spanning_widget(check_updates);

    // Recent files limit
    let recent_limit = SpinBox::new();
    recent_limit.set_range(0, 50);
    recent_limit.set_value(settings.get_or("general.recent_limit", 10));
    form.add_row(Label::new("Recent files limit:"), recent_limit);

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(form));
    container
}

fn create_appearance_tab(settings: &amp;Settings) -&gt; Container {
    let mut layout = VBoxLayout::new();
    layout.set_spacing(16.0);

    // Theme group
    let mut theme_form = FormLayout::new();

    let theme = ComboBox::new();
    theme.add_items(&amp;["System", "Light", "Dark", "High Contrast"]);
    theme.set_current_index(settings.get_or("appearance.theme", 0));
    theme_form.add_row(Label::new("Theme:"), theme);

    let accent_color = ColorButton::new();
    accent_color.set_color(Color::from_hex(
        &amp;settings.get_or("appearance.accent", "#0078D4".to_string())
    ).unwrap_or(Color::from_rgb8(0, 120, 212)));
    theme_form.add_row(Label::new("Accent color:"), accent_color);

    let mut theme_group = GroupBox::new("Theme");
    theme_group.set_layout(LayoutKind::from(theme_form));
    layout.add_widget(theme_group.object_id());

    // Font group
    let mut font_form = FormLayout::new();

    let font_family = FontComboBox::new();
    // font_family.set_current_font(settings.get_or("appearance.font", "System".to_string()));
    font_form.add_row(Label::new("Font:"), font_family);

    let font_size = SpinBox::new();
    font_size.set_range(8, 72);
    font_size.set_value(settings.get_or("appearance.font_size", 12));
    font_form.add_row(Label::new("Size:"), font_size);

    let mut font_group = GroupBox::new("Font");
    font_group.set_layout(LayoutKind::from(font_form));
    layout.add_widget(font_group.object_id());

    layout.add_stretch(1);

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));
    container
}

fn create_editor_tab(settings: &amp;Settings) -&gt; Container {
    let mut layout = VBoxLayout::new();
    layout.set_spacing(12.0);

    // Editor options
    let word_wrap = CheckBox::new("Enable word wrap");
    word_wrap.set_checked(settings.get_or("editor.word_wrap", true));
    layout.add_widget(word_wrap.object_id());

    let line_numbers = CheckBox::new("Show line numbers");
    line_numbers.set_checked(settings.get_or("editor.line_numbers", true));
    layout.add_widget(line_numbers.object_id());

    let highlight_line = CheckBox::new("Highlight current line");
    highlight_line.set_checked(settings.get_or("editor.highlight_line", true));
    layout.add_widget(highlight_line.object_id());

    let auto_indent = CheckBox::new("Auto-indent");
    auto_indent.set_checked(settings.get_or("editor.auto_indent", true));
    layout.add_widget(auto_indent.object_id());

    // Tab settings
    let mut tab_form = FormLayout::new();

    let tab_size = SpinBox::new();
    tab_size.set_range(1, 8);
    tab_size.set_value(settings.get_or("editor.tab_size", 4));
    tab_form.add_row(Label::new("Tab size:"), tab_size);

    let use_spaces = CheckBox::new("Insert spaces instead of tabs");
    use_spaces.set_checked(settings.get_or("editor.use_spaces", true));
    tab_form.add_spanning_widget(use_spaces);

    let mut tab_group = GroupBox::new("Indentation");
    tab_group.set_layout(LayoutKind::from(tab_form));
    layout.add_widget(tab_group.object_id());

    layout.add_stretch(1);

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));
    container
}

fn create_advanced_tab(settings: &amp;Settings) -&gt; Container {
    let mut layout = VBoxLayout::new();
    layout.set_spacing(12.0);

    // Performance
    let mut perf_form = FormLayout::new();

    let max_recent = SpinBox::new();
    max_recent.set_range(100, 10000);
    max_recent.set_value(settings.get_or("advanced.max_undo", 1000));
    perf_form.add_row(Label::new("Max undo history:"), max_recent);

    let auto_save = CheckBox::new("Auto-save files");
    auto_save.set_checked(settings.get_or("advanced.auto_save", false));
    perf_form.add_spanning_widget(auto_save);

    let auto_save_interval = SpinBox::new();
    auto_save_interval.set_range(1, 60);
    auto_save_interval.set_value(settings.get_or("advanced.auto_save_interval", 5));
    auto_save_interval.set_suffix(" min");
    perf_form.add_row(Label::new("Auto-save interval:"), auto_save_interval);

    let mut perf_group = GroupBox::new("Performance");
    perf_group.set_layout(LayoutKind::from(perf_form));
    layout.add_widget(perf_group.object_id());

    // Reset button
    let reset_btn = PushButton::new("Reset to Defaults")
        .with_variant(ButtonVariant::Danger);
    layout.add_widget(reset_btn.object_id());

    layout.add_stretch(1);

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));
    container
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    // Load settings
    let app_paths = AppPaths::new("com", "example", "settings-demo")?;
    let settings_path = app_paths.config().join("settings.json");

    let settings = if settings_path.exists() {
        Settings::load_json(&amp;settings_path).unwrap_or_else(|_| Settings::new())
    } else {
        Settings::new()
    };

    let settings = Arc::new(settings);

    // Create dialog
    let mut dialog = Dialog::new("Settings")
        .with_size(500.0, 450.0);

    // Tab widget
    let mut tabs = TabWidget::new();

    tabs.add_tab("General", create_general_tab(&amp;settings));
    tabs.add_tab("Appearance", create_appearance_tab(&amp;settings));
    tabs.add_tab("Editor", create_editor_tab(&amp;settings));
    tabs.add_tab("Advanced", create_advanced_tab(&amp;settings));

    // Button row
    let ok_btn = PushButton::new("OK")
        .with_variant(ButtonVariant::Primary)
        .with_default(true);
    let cancel_btn = PushButton::new("Cancel");
    let apply_btn = PushButton::new("Apply");

    // OK button - save and close
    let dlg = dialog.clone();
    let s = settings.clone();
    let path = settings_path.clone();
    ok_btn.clicked().connect(move |_| {
        // Would collect values from all widgets and save
        let _ = s.save_json(&amp;path);
        dlg.accept();
    });

    // Cancel button - close without saving
    let dlg = dialog.clone();
    cancel_btn.clicked().connect(move |_| {
        dlg.reject();
    });

    // Apply button - save without closing
    let s = settings.clone();
    let path = settings_path.clone();
    apply_btn.clicked().connect(move |_| {
        // Would collect values from all widgets and save
        let _ = s.save_json(&amp;path);
    });

    let mut button_row = HBoxLayout::new();
    button_row.set_spacing(8.0);
    button_row.add_stretch(1);
    button_row.add_widget(ok_btn.object_id());
    button_row.add_widget(cancel_btn.object_id());
    button_row.add_widget(apply_btn.object_id());

    let mut button_container = Container::new();
    button_container.set_layout(LayoutKind::from(button_row));

    // Main layout
    let mut layout = VBoxLayout::new();
    layout.set_content_margins(ContentMargins::uniform(16.0));
    layout.set_spacing(16.0);
    layout.add_widget(tabs.object_id());
    layout.add_widget(button_container.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    dialog.set_content_widget(container.object_id());
    dialog.open();

    app.run()
}</code></pre>
<h2 id="features-demonstrated-4"><a class="header" href="#features-demonstrated-4">Features Demonstrated</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>TabWidget</strong></td><td>Organize settings into tabs</td></tr>
<tr><td><strong>FormLayout</strong></td><td>Label-field arrangements</td></tr>
<tr><td><strong>GroupBox</strong></td><td>Titled setting groups</td></tr>
<tr><td><strong>Dialog</strong></td><td>Modal dialog with OK/Cancel</td></tr>
<tr><td><strong>Various inputs</strong></td><td>CheckBox, ComboBox, SpinBox, etc.</td></tr>
<tr><td><strong>Settings</strong></td><td>Persistent preferences</td></tr>
</tbody>
</table>
</div>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ol>
<li><strong>Add validation</strong>: Validate settings before saving</li>
<li><strong>Add import/export</strong>: Import/export settings to file</li>
<li><strong>Add search</strong>: Search for settings by name</li>
<li><strong>Add keyboard shortcuts tab</strong>: Configure shortcuts</li>
<li><strong>Add preview</strong>: Live preview of appearance changes</li>
</ol>
<h2 id="related-examples-4"><a class="header" href="#related-examples-4">Related Examples</a></h2>
<ul>
<li><a href="#example-text-editor">Text Editor</a> - Using settings</li>
<li><a href="#tutorial-theming">Theming Tutorial</a> - Theme settings</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="example-network-client"><a class="header" href="#example-network-client">Example: Network Client</a></h1>
<p>A network client demonstrating async HTTP requests, threading, and live updates.</p>
<h2 id="overview-5"><a class="header" href="#overview-5">Overview</a></h2>
<p>This example builds a REST API client with:</p>
<ul>
<li>Async HTTP requests using the thread pool</li>
<li>Live response display with syntax highlighting</li>
<li>Request history with caching</li>
<li>Progress indication for long requests</li>
</ul>
<h2 id="key-concepts-6"><a class="header" href="#key-concepts-6">Key Concepts</a></h2>
<ul>
<li><strong>ThreadPool</strong>: Background HTTP requests</li>
<li><strong>Worker</strong>: Long-running network operations</li>
<li><strong>Signals</strong>: Progress and completion updates</li>
<li><strong>TreeView</strong>: Request history</li>
</ul>
<h2 id="full-source-5"><a class="header" href="#full-source-5">Full Source</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::Application;
use horizon_lattice::widget::widgets::{
    Window, Container, Label, TextEdit, PushButton, ComboBox,
    LineEdit, TreeView, Splitter, ProgressBar, TabWidget,
    ButtonVariant, GroupBox
};
use horizon_lattice::widget::layout::{
    VBoxLayout, HBoxLayout, FormLayout, LayoutKind, ContentMargins
};
use horizon_lattice::concurrent::{ThreadPool, Worker, CancellationToken};
use horizon_lattice::model::{TreeModel, TreeNode};
use std::sync::{Arc, Mutex};
use std::collections::HashMap;
use std::time::{Duration, Instant};

#[derive(Clone)]
struct RequestEntry {
    method: String,
    url: String,
    status: Option&lt;u16&gt;,
    duration_ms: u64,
    response: String,
    timestamp: String,
}

struct HttpClient {
    timeout: Duration,
}

impl HttpClient {
    fn new() -&gt; Self {
        Self {
            timeout: Duration::from_secs(30),
        }
    }

    fn request(&amp;self, method: &amp;str, url: &amp;str, body: Option&lt;&amp;str&gt;)
        -&gt; Result&lt;(u16, String, Duration), String&gt;
    {
        let start = Instant::now();

        // Simulated HTTP request - in real implementation, use reqwest or ureq
        // This is a placeholder for demonstration
        std::thread::sleep(Duration::from_millis(500));

        let response = match method {
            "GET" =&gt; format!(r#"{{"message": "GET response from {}"}}"#, url),
            "POST" =&gt; format!(r#"{{"message": "Created", "data": {}}}"#, body.unwrap_or("{}")),
            "PUT" =&gt; format!(r#"{{"message": "Updated"}}"#),
            "DELETE" =&gt; format!(r#"{{"message": "Deleted"}}"#),
            _ =&gt; r#"{"error": "Unknown method"}"#.to_string(),
        };

        Ok((200, response, start.elapsed()))
    }
}

fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
    let app = Application::new()?;

    let mut window = Window::new("HTTP Client")
        .with_size(1000.0, 700.0);

    let pool = ThreadPool::new(4);
    let history: Arc&lt;Mutex&lt;Vec&lt;RequestEntry&gt;&gt;&gt; = Arc::new(Mutex::new(Vec::new()));
    let current_cancel: Arc&lt;Mutex&lt;Option&lt;CancellationToken&gt;&gt;&gt; = Arc::new(Mutex::new(None));

    // Request builder section
    let method_combo = ComboBox::new();
    method_combo.add_items(&amp;["GET", "POST", "PUT", "DELETE", "PATCH"]);

    let url_input = LineEdit::new();
    url_input.set_placeholder("https://api.example.com/endpoint");

    let send_btn = PushButton::new("Send")
        .with_variant(ButtonVariant::Primary);
    let cancel_btn = PushButton::new("Cancel");
    cancel_btn.set_enabled(false);

    // Headers
    let mut headers_form = FormLayout::new();
    let content_type = ComboBox::new();
    content_type.add_items(&amp;["application/json", "text/plain", "application/xml"]);
    headers_form.add_row(Label::new("Content-Type:"), content_type.clone());

    let auth_header = LineEdit::new();
    auth_header.set_placeholder("Bearer token...");
    headers_form.add_row(Label::new("Authorization:"), auth_header);

    let mut headers_group = GroupBox::new("Headers");
    headers_group.set_layout(LayoutKind::from(headers_form));

    // Request body
    let body_edit = TextEdit::new();
    body_edit.set_placeholder("Request body (JSON)...");

    // Response display
    let response_edit = TextEdit::new();
    response_edit.set_read_only(true);

    let status_label = Label::new("Ready");
    let progress = ProgressBar::new();
    progress.set_range(0, 100);
    progress.set_value(0);

    // History tree
    let history_model: Arc&lt;Mutex&lt;TreeModel&lt;String&gt;&gt;&gt; =
        Arc::new(Mutex::new(TreeModel::new()));
    let history_tree = TreeView::new()
        .with_model(history_model.lock().unwrap().clone());

    // URL bar layout
    let mut url_row = HBoxLayout::new();
    url_row.set_spacing(4.0);
    url_row.add_widget(method_combo.object_id());
    url_row.add_widget(url_input.object_id());
    url_row.add_widget(send_btn.object_id());
    url_row.add_widget(cancel_btn.object_id());

    let mut url_container = Container::new();
    url_container.set_layout(LayoutKind::from(url_row));

    // Tabs for body/headers
    let mut tabs = TabWidget::new();

    let mut body_container = Container::new();
    let mut body_layout = VBoxLayout::new();
    body_layout.add_widget(body_edit.object_id());
    body_container.set_layout(LayoutKind::from(body_layout));

    tabs.add_tab("Body", body_container);
    tabs.add_tab("Headers", headers_group);

    // Request panel
    let mut request_layout = VBoxLayout::new();
    request_layout.set_spacing(8.0);
    request_layout.add_widget(url_container.object_id());
    request_layout.add_widget(tabs.object_id());

    let mut request_panel = Container::new();
    request_panel.set_layout(LayoutKind::from(request_layout));

    // Response panel
    let mut response_layout = VBoxLayout::new();
    response_layout.set_spacing(8.0);
    response_layout.add_widget(status_label.object_id());
    response_layout.add_widget(progress.object_id());
    response_layout.add_widget(response_edit.object_id());

    let mut response_panel = Container::new();
    response_panel.set_layout(LayoutKind::from(response_layout));

    // Send button handler
    let url = url_input.clone();
    let method = method_combo.clone();
    let body = body_edit.clone();
    let response = response_edit.clone();
    let status = status_label.clone();
    let prog = progress.clone();
    let send = send_btn.clone();
    let cancel = cancel_btn.clone();
    let cancel_token = current_cancel.clone();
    let hist = history.clone();
    let hist_model = history_model.clone();
    let pool_clone = pool.clone();

    send_btn.clicked().connect(move |_| {
        let url_text = url.text();
        let method_text = method.current_text();
        let body_text = body.text();

        if url_text.is_empty() {
            status.set_text("Please enter a URL");
            return;
        }

        // Disable send, enable cancel
        send.set_enabled(false);
        cancel.set_enabled(true);
        status.set_text("Sending request...");
        prog.set_value(0);

        // Create cancellation token
        let token = CancellationToken::new();
        *cancel_token.lock().unwrap() = Some(token.clone());

        // Clone for closure
        let response_clone = response.clone();
        let status_clone = status.clone();
        let prog_clone = prog.clone();
        let send_clone = send.clone();
        let cancel_clone = cancel.clone();
        let hist_clone = hist.clone();
        let hist_model_clone = hist_model.clone();
        let method_for_history = method_text.clone();
        let url_for_history = url_text.clone();

        pool_clone.spawn(move || {
            let client = HttpClient::new();

            // Simulate progress
            for i in 0..5 {
                if token.is_cancelled() {
                    return;
                }
                std::thread::sleep(Duration::from_millis(100));
                prog_clone.set_value((i + 1) * 20);
            }

            let body_opt = if body_text.is_empty() {
                None
            } else {
                Some(body_text.as_str())
            };

            match client.request(&amp;method_for_history, &amp;url_for_history, body_opt) {
                Ok((code, body, duration)) =&gt; {
                    // Format JSON for display
                    let formatted = body; // Could use serde_json for pretty printing

                    response_clone.set_text(&amp;formatted);
                    status_clone.set_text(&amp;format!(
                        "Status: {} | Time: {}ms",
                        code,
                        duration.as_millis()
                    ));

                    // Add to history
                    let entry = RequestEntry {
                        method: method_for_history.clone(),
                        url: url_for_history.clone(),
                        status: Some(code),
                        duration_ms: duration.as_millis() as u64,
                        response: formatted,
                        timestamp: "now".to_string(), // Would use actual timestamp
                    };
                    hist_clone.lock().unwrap().push(entry);

                    // Update tree model
                    let label = format!("{} {} - {}ms",
                        method_for_history, url_for_history, duration.as_millis());
                    hist_model_clone.lock().unwrap().add_root(label);
                }
                Err(e) =&gt; {
                    response_clone.set_text(&amp;format!("Error: {}", e));
                    status_clone.set_text("Request failed");
                }
            }

            prog_clone.set_value(100);
            send_clone.set_enabled(true);
            cancel_clone.set_enabled(false);
        });
    });

    // Cancel button handler
    let cancel_token = current_cancel.clone();
    let send = send_btn.clone();
    let cancel = cancel_btn.clone();
    let status = status_label.clone();

    cancel_btn.clicked().connect(move |_| {
        if let Some(token) = cancel_token.lock().unwrap().take() {
            token.cancel();
            status.set_text("Request cancelled");
            send.set_enabled(true);
            cancel.set_enabled(false);
        }
    });

    // History item click - load previous request
    let response = response_edit.clone();
    let hist = history.clone();

    history_tree.clicked.connect(move |index| {
        let entries = hist.lock().unwrap();
        if let Some(entry) = entries.get(index.row() as usize) {
            response.set_text(&amp;entry.response);
        }
    });

    // Main splitter: request/response on top, history on bottom
    let mut top_splitter = Splitter::horizontal();
    top_splitter.add_widget(request_panel.object_id());
    top_splitter.add_widget(response_panel.object_id());
    top_splitter.set_sizes(&amp;[500, 500]);

    let mut main_splitter = Splitter::vertical();
    main_splitter.add_widget(top_splitter.object_id());
    main_splitter.add_widget(history_tree.object_id());
    main_splitter.set_sizes(&amp;[500, 200]);

    // Main layout
    let mut layout = VBoxLayout::new();
    layout.set_content_margins(ContentMargins::uniform(8.0));
    layout.add_widget(main_splitter.object_id());

    let mut container = Container::new();
    container.set_layout(LayoutKind::from(layout));

    window.set_content_widget(container.object_id());
    window.show();

    app.run()
}</code></pre>
<h2 id="features-demonstrated-5"><a class="header" href="#features-demonstrated-5">Features Demonstrated</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>ThreadPool</strong></td><td>Background HTTP requests</td></tr>
<tr><td><strong>CancellationToken</strong></td><td>Cancel in-flight requests</td></tr>
<tr><td><strong>ComboBox</strong></td><td>HTTP method selection</td></tr>
<tr><td><strong>TextEdit</strong></td><td>Request body and response display</td></tr>
<tr><td><strong>ProgressBar</strong></td><td>Request progress indication</td></tr>
<tr><td><strong>TreeView</strong></td><td>Request history</td></tr>
<tr><td><strong>Splitter</strong></td><td>Resizable panels</td></tr>
<tr><td><strong>TabWidget</strong></td><td>Body/Headers tabs</td></tr>
</tbody>
</table>
</div>
<h2 id="http-client-patterns"><a class="header" href="#http-client-patterns">HTTP Client Patterns</a></h2>
<h3 id="async-request-pattern"><a class="header" href="#async-request-pattern">Async Request Pattern</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::concurrent::{ThreadPool, CancellationToken};

let pool = ThreadPool::new(4);
let token = CancellationToken::new();

// Store token for cancellation
let token_for_cancel = token.clone();

pool.spawn(move || {
    // Check cancellation periodically
    for _ in 0..10 {
        if token.is_cancelled() {
            return;
        }
        // Do work...
    }
});

// Later, cancel if needed
token_for_cancel.cancel();</code></pre>
<h3 id="progress-reporting-1"><a class="header" href="#progress-reporting-1">Progress Reporting</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::concurrent::{ThreadPool, ProgressReporter};

let pool = ThreadPool::new(4);
let (reporter, receiver) = ProgressReporter::new();

pool.spawn(move || {
    for i in 0..100 {
        reporter.set_progress(i as f32 / 100.0);
        // Do work...
    }
});

// In UI thread
receiver.progress_changed.connect(|&amp;progress| {
    progress_bar.set_value((progress * 100.0) as i32);
});</code></pre>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<ol>
<li><strong>Add request persistence</strong>: Save/load request collections</li>
<li><strong>Add response formatting</strong>: Pretty-print JSON/XML</li>
<li><strong>Add authentication presets</strong>: OAuth, Basic Auth, API Key</li>
<li><strong>Add environment variables</strong>: Variable substitution in URLs</li>
<li><strong>Add response testing</strong>: Assertions on response data</li>
</ol>
<h2 id="related-examples-5"><a class="header" href="#related-examples-5">Related Examples</a></h2>
<ul>
<li><a href="#example-text-editor">Text Editor</a> - File operations</li>
<li><a href="#example-settings-dialog">Settings Dialog</a> - Configuration</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="widget-catalog"><a class="header" href="#widget-catalog">Widget Catalog</a></h1>
<p>A comprehensive reference of all built-in widgets in Horizon Lattice.</p>
<h2 id="basic-widgets"><a class="header" href="#basic-widgets">Basic Widgets</a></h2>
<h3 id="label"><a class="header" href="#label">Label</a></h3>
<p>Displays read-only text with optional rich text formatting.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::Label;

let label = Label::new("Hello, World!");
label.set_alignment(TextAlign::Center);
label.set_word_wrap(true);
label.set_selectable(true);  // Allow text selection</code></pre>
<p><strong>Key Properties:</strong></p>
<ul>
<li><code>text</code> - The displayed text</li>
<li><code>alignment</code> - Text alignment (Left, Center, Right)</li>
<li><code>word_wrap</code> - Enable word wrapping</li>
<li><code>selectable</code> - Allow text selection</li>
<li><code>elide_mode</code> - How to elide overflow (None, Left, Middle, Right)</li>
</ul>
<h3 id="pushbutton"><a class="header" href="#pushbutton">PushButton</a></h3>
<p>A clickable push button with optional icon.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{PushButton, ButtonVariant};

let button = PushButton::new("Click Me")
    .with_variant(ButtonVariant::Primary)
    .with_icon(Icon::from_name("check"))
    .with_default(true);  // Responds to Enter key

button.clicked().connect(|_| println!("Clicked!"));</code></pre>
<p><strong>Variants:</strong></p>
<ul>
<li><code>Primary</code> - Prominent action button</li>
<li><code>Secondary</code> - Default button style</li>
<li><code>Outlined</code> - Border-only button</li>
<li><code>Text</code> - Text-only button</li>
<li><code>Danger</code> - Destructive action button</li>
</ul>
<p><strong>Signals:</strong></p>
<ul>
<li><code>clicked</code> - Emitted when button is clicked</li>
<li><code>pressed</code> - Emitted when button is pressed down</li>
<li><code>released</code> - Emitted when button is released</li>
</ul>
<h3 id="checkbox"><a class="header" href="#checkbox">CheckBox</a></h3>
<p>A toggleable checkbox with optional label.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::CheckBox;

let checkbox = CheckBox::new("Enable feature");
checkbox.set_tristate(true);  // Allow indeterminate state

checkbox.toggled().connect(|&amp;checked| {
    println!("Checked: {}", checked);
});</code></pre>
<p><strong>Properties:</strong></p>
<ul>
<li><code>text</code> - Checkbox label</li>
<li><code>checked</code> - Current checked state</li>
<li><code>tristate</code> - Enable three-state mode (checked, unchecked, indeterminate)</li>
<li><code>check_state</code> - Full state (Unchecked, PartiallyChecked, Checked)</li>
</ul>
<h3 id="radiobutton"><a class="header" href="#radiobutton">RadioButton</a></h3>
<p>Mutually exclusive option buttons within a group.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{RadioButton, ButtonGroup};

let mut group = ButtonGroup::new();
let opt_a = RadioButton::new("Option A");
let opt_b = RadioButton::new("Option B");
let opt_c = RadioButton::new("Option C");

group.add_button(opt_a.clone());
group.add_button(opt_b.clone());
group.add_button(opt_c.clone());

group.button_clicked.connect(|id| {
    println!("Selected option: {}", id);
});</code></pre>
<h3 id="toolbutton"><a class="header" href="#toolbutton">ToolButton</a></h3>
<p>Compact button typically used in toolbars.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{ToolButton, ToolButtonStyle};

let tool_btn = ToolButton::new()
    .with_icon(Icon::from_name("bold"))
    .with_text("Bold")
    .with_style(ToolButtonStyle::IconOnly)
    .with_checkable(true);</code></pre>
<p><strong>Styles:</strong></p>
<ul>
<li><code>IconOnly</code> - Show only icon</li>
<li><code>TextOnly</code> - Show only text</li>
<li><code>TextBesideIcon</code> - Text next to icon</li>
<li><code>TextUnderIcon</code> - Text below icon</li>
</ul>
<h2 id="input-widgets"><a class="header" href="#input-widgets">Input Widgets</a></h2>
<h3 id="lineedit"><a class="header" href="#lineedit">LineEdit</a></h3>
<p>Single-line text input field.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{LineEdit, EchoMode};

let edit = LineEdit::new();
edit.set_placeholder("Enter your name...");
edit.set_max_length(50);
edit.set_echo_mode(EchoMode::Password);

edit.text_changed.connect(|text| {
    println!("Text: {}", text);
});

edit.return_pressed.connect(|| {
    println!("Enter pressed!");
});</code></pre>
<p><strong>Echo Modes:</strong></p>
<ul>
<li><code>Normal</code> - Display text as entered</li>
<li><code>Password</code> - Display bullets/asterisks</li>
<li><code>NoEcho</code> - Display nothing</li>
<li><code>PasswordEchoOnEdit</code> - Show while typing</li>
</ul>
<h3 id="textedit"><a class="header" href="#textedit">TextEdit</a></h3>
<p>Multi-line text editing widget with rich text support.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::TextEdit;

let editor = TextEdit::new();
editor.set_text("Initial content");
editor.set_word_wrap(true);
editor.set_read_only(false);
editor.set_tab_stop_width(4);

// Editing operations
editor.undo();
editor.redo();
editor.cut();
editor.copy();
editor.paste();
editor.select_all();</code></pre>
<p><strong>Signals:</strong></p>
<ul>
<li><code>text_changed</code> - Content changed</li>
<li><code>cursor_position_changed</code> - Cursor moved</li>
<li><code>selection_changed</code> - Selection changed</li>
</ul>
<h3 id="spinbox"><a class="header" href="#spinbox">SpinBox</a></h3>
<p>Numeric input with increment/decrement buttons.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::SpinBox;

let spin = SpinBox::new();
spin.set_range(0, 100);
spin.set_value(50);
spin.set_step(5);
spin.set_prefix("$");
spin.set_suffix(" USD");
spin.set_wrapping(true);  // Wrap around at limits

spin.value_changed.connect(|&amp;value| {
    println!("Value: {}", value);
});</code></pre>
<h3 id="doublespinbox"><a class="header" href="#doublespinbox">DoubleSpinBox</a></h3>
<p>Floating-point numeric input.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::DoubleSpinBox;

let spin = DoubleSpinBox::new();
spin.set_range(0.0, 1.0);
spin.set_value(0.5);
spin.set_decimals(2);
spin.set_step(0.1);</code></pre>
<h3 id="slider"><a class="header" href="#slider">Slider</a></h3>
<p>Continuous value selection via draggable handle.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{Slider, Orientation};

let slider = Slider::new();
slider.set_orientation(Orientation::Horizontal);
slider.set_range(0, 100);
slider.set_value(50);
slider.set_tick_position(TickPosition::Below);
slider.set_tick_interval(10);

slider.value_changed.connect(|&amp;value| {
    println!("Slider: {}", value);
});</code></pre>
<h3 id="combobox"><a class="header" href="#combobox">ComboBox</a></h3>
<p>Dropdown selection widget.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::ComboBox;

let combo = ComboBox::new();
combo.add_items(&amp;["Option 1", "Option 2", "Option 3"]);
combo.set_current_index(0);
combo.set_editable(true);  // Allow custom input
combo.set_placeholder("Select...");

combo.current_index_changed.connect(|&amp;index| {
    println!("Selected index: {}", index);
});</code></pre>
<h3 id="dateedit--timeedit--datetimeedit"><a class="header" href="#dateedit--timeedit--datetimeedit">DateEdit / TimeEdit / DateTimeEdit</a></h3>
<p>Date and time input widgets.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{DateEdit, TimeEdit, DateTimeEdit};
use horizon_lattice::core::{Date, Time, DateTime};

let date = DateEdit::new();
date.set_date(Date::today());
date.set_display_format("yyyy-MM-dd");
date.set_calendar_popup(true);

let time = TimeEdit::new();
time.set_time(Time::current());
time.set_display_format("HH:mm:ss");

let datetime = DateTimeEdit::new();
datetime.set_datetime(DateTime::now());</code></pre>
<h3 id="colorbutton"><a class="header" href="#colorbutton">ColorButton</a></h3>
<p>Color selection button with color picker dialog.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::ColorButton;
use horizon_lattice::render::Color;

let color_btn = ColorButton::new();
color_btn.set_color(Color::from_rgb8(255, 128, 0));
color_btn.set_show_alpha(true);

color_btn.color_changed.connect(|color| {
    println!("Selected: {:?}", color);
});</code></pre>
<h3 id="fontcombobox"><a class="header" href="#fontcombobox">FontComboBox</a></h3>
<p>Font family selection.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::FontComboBox;

let font_combo = FontComboBox::new();
font_combo.set_current_font("Helvetica");

font_combo.font_changed.connect(|family| {
    println!("Font: {}", family);
});</code></pre>
<h2 id="container-widgets"><a class="header" href="#container-widgets">Container Widgets</a></h2>
<h3 id="container"><a class="header" href="#container">Container</a></h3>
<p>Generic container for arranging child widgets with a layout.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::Container;
use horizon_lattice::widget::layout::{VBoxLayout, LayoutKind};

let mut container = Container::new();
let mut layout = VBoxLayout::new();
layout.add_widget(widget1.object_id());
layout.add_widget(widget2.object_id());
container.set_layout(LayoutKind::from(layout));</code></pre>
<h3 id="scrollarea"><a class="header" href="#scrollarea">ScrollArea</a></h3>
<p>Scrollable container for content larger than visible area.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{ScrollArea, ScrollBarPolicy};

let mut scroll = ScrollArea::new();
scroll.set_widget(content.object_id());
scroll.set_horizontal_policy(ScrollBarPolicy::AsNeeded);
scroll.set_vertical_policy(ScrollBarPolicy::AlwaysOn);
scroll.set_widget_resizable(true);

// Programmatic scrolling
scroll.scroll_to(0, 500);
scroll.ensure_visible(widget.object_id());</code></pre>
<h3 id="tabwidget"><a class="header" href="#tabwidget">TabWidget</a></h3>
<p>Tabbed container showing one page at a time.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::TabWidget;

let mut tabs = TabWidget::new();
tabs.add_tab("General", general_page);
tabs.add_tab("Advanced", advanced_page);
tabs.set_tab_position(TabPosition::Top);
tabs.set_tabs_closable(true);
tabs.set_movable(true);

tabs.current_changed.connect(|&amp;index| {
    println!("Tab switched to: {}", index);
});

tabs.tab_close_requested.connect(|&amp;index| {
    tabs.remove_tab(index);
});</code></pre>
<h3 id="splitter"><a class="header" href="#splitter">Splitter</a></h3>
<p>Resizable split view between widgets.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::Splitter;

let mut splitter = Splitter::new();
splitter.add_widget(left_panel.object_id());
splitter.add_widget(right_panel.object_id());
splitter.set_sizes(&amp;[200, 400]);
splitter.set_collapsible(0, true);  // First panel can collapse

splitter.splitter_moved.connect(|&amp;(pos, index)| {
    println!("Splitter {} moved to {}", index, pos);
});</code></pre>
<h3 id="groupbox"><a class="header" href="#groupbox">GroupBox</a></h3>
<p>Titled container with optional checkbox.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::GroupBox;

let mut group = GroupBox::new("Options");
group.set_checkable(true);
group.set_checked(true);
group.set_layout(LayoutKind::from(layout));

group.toggled.connect(|&amp;enabled| {
    println!("Group enabled: {}", enabled);
});</code></pre>
<h3 id="stackwidget"><a class="header" href="#stackwidget">StackWidget</a></h3>
<p>Shows one widget at a time, like a deck of cards.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::StackWidget;

let mut stack = StackWidget::new();
stack.add_widget(page1.object_id());
stack.add_widget(page2.object_id());
stack.add_widget(page3.object_id());
stack.set_current_index(0);

// Switch pages
stack.set_current_widget(page2.object_id());</code></pre>
<h2 id="display-widgets"><a class="header" href="#display-widgets">Display Widgets</a></h2>
<h3 id="progressbar"><a class="header" href="#progressbar">ProgressBar</a></h3>
<p>Progress indication for long operations.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::ProgressBar;

let progress = ProgressBar::new();
progress.set_range(0, 100);
progress.set_value(50);
progress.set_text_visible(true);
progress.set_format("%v / %m (%p%)");

// Indeterminate mode
progress.set_range(0, 0);</code></pre>
<h3 id="imagewidget"><a class="header" href="#imagewidget">ImageWidget</a></h3>
<p>Image display with scaling modes.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{ImageWidget, ImageScaleMode};

let image = ImageWidget::new();
image.set_source_file("photo.jpg");
image.set_scale_mode(ImageScaleMode::Fit);
image.set_alignment(Alignment::Center);

// Or from data
image.set_source_data(&amp;image_bytes, "png");</code></pre>
<p><strong>Scale Modes:</strong></p>
<ul>
<li><code>None</code> - Display at actual size</li>
<li><code>Fit</code> - Scale to fit, preserve aspect ratio</li>
<li><code>Fill</code> - Scale to fill, may crop</li>
<li><code>Stretch</code> - Stretch to fill, ignore aspect ratio</li>
<li><code>Tile</code> - Tile the image</li>
</ul>
<h3 id="listview"><a class="header" href="#listview">ListView</a></h3>
<p>List data display with item selection.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::ListView;
use horizon_lattice::model::{ListModel, SelectionMode};

let model = ListModel::new(vec!["Item 1", "Item 2", "Item 3"]);
let list = ListView::new().with_model(model);
list.set_selection_mode(SelectionMode::Extended);

list.clicked.connect(|index| {
    println!("Clicked row: {}", index.row());
});

list.double_clicked.connect(|index| {
    println!("Double-clicked: {}", index.row());
});</code></pre>
<h3 id="treeview"><a class="header" href="#treeview">TreeView</a></h3>
<p>Hierarchical data display with expandable nodes.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::TreeView;
use horizon_lattice::model::TreeModel;

let model = TreeModel::new();
let root = model.add_root("Root");
model.add_child(root, "Child 1");
model.add_child(root, "Child 2");

let tree = TreeView::new().with_model(model);
tree.set_root_decorated(true);
tree.set_items_expandable(true);

tree.expanded.connect(|index| {
    println!("Expanded: {:?}", index);
});</code></pre>
<h3 id="tableview"><a class="header" href="#tableview">TableView</a></h3>
<p>Tabular data display with rows and columns.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::TableView;
use horizon_lattice::model::TableModel;

let model = TableModel::new(vec![
    vec!["A1", "B1", "C1"],
    vec!["A2", "B2", "C2"],
]);
model.set_headers(&amp;["Column A", "Column B", "Column C"]);

let table = TableView::new().with_model(model);
table.set_column_width(0, 100);
table.set_row_height(30);
table.set_grid_visible(true);
table.set_alternating_row_colors(true);</code></pre>
<h2 id="window-widgets"><a class="header" href="#window-widgets">Window Widgets</a></h2>
<h3 id="window"><a class="header" href="#window">Window</a></h3>
<p>Basic application window.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::Window;

let mut window = Window::new("My App")
    .with_size(800.0, 600.0)
    .with_position(100.0, 100.0);

window.set_content_widget(content.object_id());
window.show();</code></pre>
<h3 id="mainwindow"><a class="header" href="#mainwindow">MainWindow</a></h3>
<p>Application window with menu bar, toolbars, and status bar.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{MainWindow, MenuBar, ToolBar, StatusBar};

let mut main = MainWindow::new("My App")
    .with_size(1024.0, 768.0);

main.set_menu_bar(menu_bar);
main.add_tool_bar(tool_bar);
main.set_central_widget(content.object_id());
main.set_status_bar(status_bar);
main.show();</code></pre>
<h3 id="dialog"><a class="header" href="#dialog">Dialog</a></h3>
<p>Modal dialog window.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{Dialog, DialogButtonBox, StandardButton};

let mut dialog = Dialog::new("Confirm")
    .with_size(400.0, 200.0);

let buttons = DialogButtonBox::new()
    .with_standard_buttons(StandardButton::Ok | StandardButton::Cancel);

dialog.set_content_widget(content.object_id());
dialog.set_button_box(buttons);

// Show modally and get result
match dialog.exec() {
    DialogResult::Accepted =&gt; println!("OK clicked"),
    DialogResult::Rejected =&gt; println!("Cancelled"),
}

// Or show non-modally
dialog.open();
dialog.accepted.connect(|| { /* ... */ });
dialog.rejected.connect(|| { /* ... */ });</code></pre>
<h3 id="messagebox"><a class="header" href="#messagebox">MessageBox</a></h3>
<p>Standard message dialogs.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{MessageBox, MessageIcon, StandardButton};

// Information message
MessageBox::information("Info", "Operation completed successfully.");

// Question with buttons
let result = MessageBox::question(
    "Confirm",
    "Are you sure you want to delete this file?",
    StandardButton::Yes | StandardButton::No
);

// Warning
MessageBox::warning("Warning", "This action cannot be undone.");

// Error
MessageBox::critical("Error", "Failed to save file.");</code></pre>
<h3 id="filedialog"><a class="header" href="#filedialog">FileDialog</a></h3>
<p>Native file open/save dialogs.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{FileDialog, FileFilter};

// Open single file
let filters = vec![
    FileFilter::new("Images", &amp;["png", "jpg", "gif"]),
    FileFilter::all_files(),
];

if let Some(path) = FileDialog::get_open_file_name("Open Image", "", &amp;filters) {
    println!("Selected: {:?}", path);
}

// Open multiple files
if let Some(paths) = FileDialog::get_open_file_names("Open Files", "", &amp;filters) {
    for path in paths {
        println!("Selected: {:?}", path);
    }
}

// Save file
if let Some(path) = FileDialog::get_save_file_name("Save As", "", &amp;filters) {
    println!("Save to: {:?}", path);
}

// Select directory
if let Some(dir) = FileDialog::get_existing_directory("Choose Directory", "") {
    println!("Directory: {:?}", dir);
}</code></pre>
<h2 id="menu-widgets"><a class="header" href="#menu-widgets">Menu Widgets</a></h2>
<h3 id="menubar"><a class="header" href="#menubar">MenuBar</a></h3>
<p>Application menu bar.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{MenuBar, Menu};

let mut menu_bar = MenuBar::new();
menu_bar.add_menu(file_menu);
menu_bar.add_menu(edit_menu);
menu_bar.add_menu(help_menu);</code></pre>
<h3 id="menu"><a class="header" href="#menu">Menu</a></h3>
<p>Dropdown menu with actions and submenus.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::{Menu, Action};

let mut file_menu = Menu::new("File");
file_menu.add_action(Action::new("New").with_shortcut("Ctrl+N"));
file_menu.add_action(Action::new("Open...").with_shortcut("Ctrl+O"));
file_menu.add_separator();
file_menu.add_menu(recent_files_menu);  // Submenu
file_menu.add_separator();
file_menu.add_action(Action::new("Quit").with_shortcut("Ctrl+Q"));</code></pre>
<h3 id="action"><a class="header" href="#action">Action</a></h3>
<p>Reusable command with text, icon, and shortcut.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::Action;

let save_action = Action::new("Save")
    .with_shortcut("Ctrl+S")
    .with_icon(Icon::from_name("save"))
    .with_enabled(true);

save_action.triggered.connect(|| {
    println!("Save triggered!");
});

// Checkable action
let word_wrap = Action::new("Word Wrap")
    .with_checkable(true)
    .with_checked(true);

word_wrap.toggled.connect(|&amp;checked| {
    editor.set_word_wrap(checked);
});</code></pre>
<h2 id="toolbar-widgets"><a class="header" href="#toolbar-widgets">Toolbar Widgets</a></h2>
<h3 id="toolbar"><a class="header" href="#toolbar">ToolBar</a></h3>
<p>Application toolbar.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::ToolBar;

let mut toolbar = ToolBar::new("Main");
toolbar.add_action(new_action);
toolbar.add_action(open_action);
toolbar.add_separator();
toolbar.add_widget(search_box.object_id());
toolbar.set_movable(true);
toolbar.set_floatable(true);</code></pre>
<h2 id="status-bar"><a class="header" href="#status-bar">Status Bar</a></h2>
<h3 id="statusbar"><a class="header" href="#statusbar">StatusBar</a></h3>
<p>Window status bar.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::widgets::StatusBar;

let status = StatusBar::new();
status.show_message("Ready");
status.show_message_for("Saved!", Duration::from_secs(3));

// Permanent widgets
status.add_permanent_widget(progress.object_id());
status.add_permanent_widget(position_label.object_id());</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="layout-reference"><a class="header" href="#layout-reference">Layout Reference</a></h1>
<p>A comprehensive reference of all layout types available in Horizon Lattice.</p>
<h2 id="common-concepts"><a class="header" href="#common-concepts">Common Concepts</a></h2>
<h3 id="contentmargins"><a class="header" href="#contentmargins">ContentMargins</a></h3>
<p>All layouts support content margins - the space between the layout edge and its contents.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::ContentMargins;

// Uniform margins on all sides
let margins = ContentMargins::uniform(16.0);

// Symmetric margins (vertical, horizontal)
let margins = ContentMargins::symmetric(8.0, 16.0);

// Individual margins (left, top, right, bottom)
let margins = ContentMargins::new(10.0, 8.0, 10.0, 12.0);

// Apply to layout
layout.set_content_margins(margins);</code></pre>
<h3 id="layoutkind"><a class="header" href="#layoutkind">LayoutKind</a></h3>
<p>Layouts must be wrapped in <code>LayoutKind</code> when setting on a container.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{VBoxLayout, LayoutKind};
use horizon_lattice::widget::widgets::Container;

let mut layout = VBoxLayout::new();
// Configure layout...

let mut container = Container::new();
container.set_layout(LayoutKind::from(layout));</code></pre>
<h3 id="widget-ids"><a class="header" href="#widget-ids">Widget IDs</a></h3>
<p>Layouts reference widgets by their <code>ObjectId</code>, obtained via <code>widget.object_id()</code>.</p>
<pre><code class="language-rust ignore">let button = PushButton::new("Click");
layout.add_widget(button.object_id());</code></pre>
<h2 id="box-layouts"><a class="header" href="#box-layouts">Box Layouts</a></h2>
<h3 id="hboxlayout"><a class="header" href="#hboxlayout">HBoxLayout</a></h3>
<p>Arranges widgets horizontally from left to right.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::HBoxLayout;

let mut layout = HBoxLayout::new();
layout.set_spacing(8.0);
layout.set_content_margins(ContentMargins::uniform(10.0));

// Add widgets in order
layout.add_widget(icon.object_id());
layout.add_widget(label.object_id());
layout.add_stretch(1);  // Flexible space
layout.add_widget(button.object_id());</code></pre>
<p><strong>Methods:</strong></p>
<ul>
<li><code>set_spacing(f32)</code> - Space between widgets</li>
<li><code>add_widget(ObjectId)</code> - Add widget at end</li>
<li><code>add_stretch(i32)</code> - Add flexible space with stretch factor</li>
<li><code>insert_widget(usize, ObjectId)</code> - Insert at position</li>
<li><code>insert_stretch(usize, i32)</code> - Insert stretch at position</li>
</ul>
<h3 id="vboxlayout"><a class="header" href="#vboxlayout">VBoxLayout</a></h3>
<p>Arranges widgets vertically from top to bottom.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::VBoxLayout;

let mut layout = VBoxLayout::new();
layout.set_spacing(12.0);

layout.add_widget(title.object_id());
layout.add_widget(content.object_id());
layout.add_stretch(1);  // Push buttons to bottom
layout.add_widget(buttons.object_id());</code></pre>
<h3 id="boxlayout-generic"><a class="header" href="#boxlayout-generic">BoxLayout (Generic)</a></h3>
<p>Base box layout with configurable orientation.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{BoxLayout, Orientation};

let mut layout = BoxLayout::new(Orientation::Horizontal);
layout.set_spacing(8.0);</code></pre>
<h3 id="alignment"><a class="header" href="#alignment">Alignment</a></h3>
<p>Control item alignment within box layouts.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::Alignment;

// Add widget with specific alignment
layout.add_widget_with_alignment(
    widget.object_id(),
    Alignment::Center
);</code></pre>
<p><strong>Alignment Values:</strong></p>
<ul>
<li><code>Leading</code> - Left/Top aligned</li>
<li><code>Center</code> - Centered</li>
<li><code>Trailing</code> - Right/Bottom aligned</li>
<li><code>Fill</code> - Stretch to fill (default)</li>
</ul>
<h2 id="gridlayout-2"><a class="header" href="#gridlayout-2">GridLayout</a></h2>
<p>Arranges widgets in a two-dimensional grid.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::GridLayout;

let mut grid = GridLayout::new();
grid.set_horizontal_spacing(8.0);
grid.set_vertical_spacing(8.0);

// Add widgets at specific positions (row, column)
grid.add_widget_at(label1.object_id(), 0, 0);
grid.add_widget_at(input1.object_id(), 0, 1);
grid.add_widget_at(label2.object_id(), 1, 0);
grid.add_widget_at(input2.object_id(), 1, 1);

// Widget spanning multiple cells
grid.add_widget_spanning(
    wide_widget.object_id(),
    2,  // row
    0,  // column
    1,  // row span
    2   // column span
);</code></pre>
<h3 id="row-and-column-configuration"><a class="header" href="#row-and-column-configuration">Row and Column Configuration</a></h3>
<pre><code class="language-rust ignore">// Set minimum row/column sizes
grid.set_row_minimum_height(0, 30.0);
grid.set_column_minimum_width(1, 200.0);

// Set stretch factors (relative sizing)
grid.set_row_stretch(0, 1);
grid.set_row_stretch(1, 2);  // Second row gets 2x space
grid.set_column_stretch(0, 0);
grid.set_column_stretch(1, 1);</code></pre>
<h3 id="cell-alignment"><a class="header" href="#cell-alignment">Cell Alignment</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::CellAlignment;

grid.add_widget_at_aligned(
    widget.object_id(),
    0, 0,
    CellAlignment::new(Alignment::Center, Alignment::Center)
);</code></pre>
<h2 id="formlayout-1"><a class="header" href="#formlayout-1">FormLayout</a></h2>
<p>Two-column layout optimized for label-field pairs.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::FormLayout;

let mut form = FormLayout::new();

// Add label-field pairs
form.add_row(Label::new("Name:"), name_input);
form.add_row(Label::new("Email:"), email_input);
form.add_row(Label::new("Password:"), password_input);

// Field spanning full width
form.add_spanning_widget(remember_me_checkbox);

// Just a field (no label)
form.add_row_field_only(submit_button);</code></pre>
<h3 id="form-policies"><a class="header" href="#form-policies">Form Policies</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{RowWrapPolicy, FieldGrowthPolicy};

// Row wrap policy: when to wrap long labels
form.set_row_wrap_policy(RowWrapPolicy::WrapLongRows);

// Field growth: how fields expand
form.set_field_growth_policy(FieldGrowthPolicy::ExpandingFieldsGrow);</code></pre>
<p><strong>RowWrapPolicy:</strong></p>
<ul>
<li><code>DontWrapRows</code> - Never wrap, may clip</li>
<li><code>WrapLongRows</code> - Wrap labels that don’t fit</li>
<li><code>WrapAllRows</code> - Always put labels above fields</li>
</ul>
<p><strong>FieldGrowthPolicy:</strong></p>
<ul>
<li><code>FieldsStayAtSizeHint</code> - Fields stay at preferred size</li>
<li><code>ExpandingFieldsGrow</code> - Only expanding fields grow</li>
<li><code>AllNonFixedFieldsGrow</code> - All non-fixed fields grow</li>
</ul>
<h3 id="row-access"><a class="header" href="#row-access">Row Access</a></h3>
<pre><code class="language-rust ignore">// Get form row by index
let row = form.row_at(0);
row.set_visible(false);  // Hide entire row

// Remove a row
form.remove_row(1);</code></pre>
<h2 id="stacklayout-1"><a class="header" href="#stacklayout-1">StackLayout</a></h2>
<p>Shows one widget at a time (like pages in a wizard).</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{StackLayout, StackSizeMode};

let mut stack = StackLayout::new();

// Add pages
let page1_id = stack.add_widget(intro_page.object_id());
let page2_id = stack.add_widget(settings_page.object_id());
let page3_id = stack.add_widget(confirm_page.object_id());

// Switch pages
stack.set_current_index(0);
stack.set_current_widget(settings_page.object_id());

// Size mode
stack.set_size_mode(StackSizeMode::CurrentWidgetSize);</code></pre>
<p><strong>StackSizeMode:</strong></p>
<ul>
<li><code>StackFitLargestWidget</code> - Size to fit largest child</li>
<li><code>CurrentWidgetSize</code> - Size to fit current child only</li>
</ul>
<h2 id="flowlayout-1"><a class="header" href="#flowlayout-1">FlowLayout</a></h2>
<p>Arranges widgets in rows, wrapping to new lines as needed.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::FlowLayout;

let mut flow = FlowLayout::new();
flow.set_horizontal_spacing(8.0);
flow.set_vertical_spacing(8.0);

// Add items - they flow and wrap automatically
for tag in tags {
    flow.add_widget(TagWidget::new(tag).object_id());
}</code></pre>
<p><strong>Use Cases:</strong></p>
<ul>
<li>Tag clouds</li>
<li>Photo galleries</li>
<li>Toolbar buttons that wrap</li>
</ul>
<h2 id="anchorlayout-1"><a class="header" href="#anchorlayout-1">AnchorLayout</a></h2>
<p>Position widgets relative to parent or sibling edges.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{AnchorLayout, Anchor, AnchorLine, AnchorTarget};

let mut anchor = AnchorLayout::new();

// Add widgets
anchor.add_widget(sidebar.object_id());
anchor.add_widget(content.object_id());
anchor.add_widget(footer.object_id());

// Anchor sidebar to parent left edge
anchor.add_anchor(Anchor::new(
    AnchorTarget::Widget(sidebar.object_id()),
    AnchorLine::Left,
    AnchorTarget::Parent,
    AnchorLine::Left,
    10.0  // margin
));

// Anchor sidebar to parent top
anchor.add_anchor(Anchor::new(
    AnchorTarget::Widget(sidebar.object_id()),
    AnchorLine::Top,
    AnchorTarget::Parent,
    AnchorLine::Top,
    10.0
));

// Anchor content to sidebar's right edge
anchor.add_anchor(Anchor::new(
    AnchorTarget::Widget(content.object_id()),
    AnchorLine::Left,
    AnchorTarget::Widget(sidebar.object_id()),
    AnchorLine::Right,
    8.0
));</code></pre>
<p><strong>AnchorLine Values:</strong></p>
<ul>
<li><code>Left</code>, <code>Right</code>, <code>Top</code>, <code>Bottom</code> - Edges</li>
<li><code>HorizontalCenter</code>, <code>VerticalCenter</code> - Centers</li>
</ul>
<h3 id="fill-anchors"><a class="header" href="#fill-anchors">Fill Anchors</a></h3>
<pre><code class="language-rust ignore">// Make widget fill parent horizontally
anchor.fill_horizontal(widget.object_id(), 10.0);

// Make widget fill parent vertically
anchor.fill_vertical(widget.object_id(), 10.0);

// Make widget fill parent completely
anchor.fill(widget.object_id(), ContentMargins::uniform(10.0));</code></pre>
<h2 id="layout-items"><a class="header" href="#layout-items">Layout Items</a></h2>
<h3 id="spaceritem"><a class="header" href="#spaceritem">SpacerItem</a></h3>
<p>Flexible or fixed space in layouts.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{LayoutItem, SpacerItem, SpacerType};

// Fixed size spacer
let spacer = SpacerItem::fixed(20.0, 0.0);

// Expanding spacer (flexible)
let spacer = SpacerItem::expanding(SpacerType::Horizontal);

// Add to layout
layout.add_item(LayoutItem::Spacer(spacer));</code></pre>
<p><strong>SpacerType:</strong></p>
<ul>
<li><code>Horizontal</code> - Expands horizontally</li>
<li><code>Vertical</code> - Expands vertically</li>
<li><code>Both</code> - Expands in both directions</li>
</ul>
<h2 id="nested-layouts-1"><a class="header" href="#nested-layouts-1">Nested Layouts</a></h2>
<p>Layouts can be nested for complex arrangements.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{VBoxLayout, HBoxLayout, LayoutKind};

// Create button row
let mut buttons = HBoxLayout::new();
buttons.set_spacing(8.0);
buttons.add_stretch(1);
buttons.add_widget(cancel_btn.object_id());
buttons.add_widget(ok_btn.object_id());

let mut buttons_container = Container::new();
buttons_container.set_layout(LayoutKind::from(buttons));

// Main layout with nested button row
let mut main = VBoxLayout::new();
main.add_widget(content.object_id());
main.add_widget(buttons_container.object_id());</code></pre>
<h2 id="layout-invalidation-1"><a class="header" href="#layout-invalidation-1">Layout Invalidation</a></h2>
<p>Force layouts to recalculate.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{LayoutInvalidator, InvalidationScope};

// Invalidate specific widget's layout
LayoutInvalidator::invalidate(widget.object_id());

// Invalidate with specific scope
LayoutInvalidator::invalidate_with_scope(
    widget.object_id(),
    InvalidationScope::SizeHint
);</code></pre>
<p><strong>InvalidationScope:</strong></p>
<ul>
<li><code>Geometry</code> - Recalculate positions and sizes</li>
<li><code>SizeHint</code> - Recalculate size hints</li>
<li><code>All</code> - Full recalculation</li>
</ul>
<h2 id="default-values"><a class="header" href="#default-values">Default Values</a></h2>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{DEFAULT_SPACING, DEFAULT_MARGINS};

// DEFAULT_SPACING = 6.0
// DEFAULT_MARGINS = ContentMargins::uniform(9.0)</code></pre>
<h2 id="layout-trait"><a class="header" href="#layout-trait">Layout Trait</a></h2>
<p>For custom layouts, implement the <code>Layout</code> trait.</p>
<pre><code class="language-rust ignore">use horizon_lattice::widget::layout::{Layout, ContentMargins};
use horizon_lattice::widget::SizeHint;
use horizon_lattice::render::{Rect, Size};

pub struct MyCustomLayout {
    geometry: Rect,
    margins: ContentMargins,
    // ...
}

impl Layout for MyCustomLayout {
    fn size_hint(&amp;self) -&gt; SizeHint {
        // Calculate preferred size
        SizeHint::preferred(Size::new(200.0, 100.0))
    }

    fn set_geometry(&amp;mut self, rect: Rect) {
        self.geometry = rect;
        // Position child widgets
    }

    fn geometry(&amp;self) -&gt; Rect {
        self.geometry
    }

    fn content_margins(&amp;self) -&gt; ContentMargins {
        self.margins
    }

    fn set_content_margins(&amp;mut self, margins: ContentMargins) {
        self.margins = margins;
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="style-properties-reference"><a class="header" href="#style-properties-reference">Style Properties Reference</a></h1>
<p>All CSS properties supported by Horizon Lattice.</p>
<h2 id="box-model-1"><a class="header" href="#box-model-1">Box Model</a></h2>
<h3 id="margin"><a class="header" href="#margin">margin</a></h3>
<p>Outer spacing around the widget.</p>
<pre><code class="language-css">margin: 10px;           /* All sides */
margin: 10px 20px;      /* Vertical, horizontal */
margin: 10px 20px 15px 25px;  /* Top, right, bottom, left */
</code></pre>
<h3 id="padding"><a class="header" href="#padding">padding</a></h3>
<p>Inner spacing within the widget.</p>
<pre><code class="language-css">padding: 8px;
padding: 8px 16px;
</code></pre>
<h3 id="border-width"><a class="header" href="#border-width">border-width</a></h3>
<p>Border thickness.</p>
<pre><code class="language-css">border-width: 1px;
</code></pre>
<h3 id="border-color"><a class="header" href="#border-color">border-color</a></h3>
<p>Border color.</p>
<pre><code class="language-css">border-color: #333;
border-color: rgb(51, 51, 51);
</code></pre>
<h3 id="border-style"><a class="header" href="#border-style">border-style</a></h3>
<p>Border line style.</p>
<pre><code class="language-css">border-style: solid;
border-style: none;
</code></pre>
<h3 id="border-radius"><a class="header" href="#border-radius">border-radius</a></h3>
<p>Corner rounding.</p>
<pre><code class="language-css">border-radius: 4px;
border-radius: 4px 8px;  /* TL/BR, TR/BL */
</code></pre>
<h2 id="colors-2"><a class="header" href="#colors-2">Colors</a></h2>
<h3 id="color"><a class="header" href="#color">color</a></h3>
<p>Text color.</p>
<pre><code class="language-css">color: white;
color: #ffffff;
color: rgb(255, 255, 255);
color: rgba(255, 255, 255, 0.8);
</code></pre>
<h3 id="background-color"><a class="header" href="#background-color">background-color</a></h3>
<p>Background fill color.</p>
<pre><code class="language-css">background-color: #3498db;
background-color: transparent;
</code></pre>
<h2 id="typography-1"><a class="header" href="#typography-1">Typography</a></h2>
<h3 id="font-size"><a class="header" href="#font-size">font-size</a></h3>
<p>Text size.</p>
<pre><code class="language-css">font-size: 14px;
font-size: 1.2em;
</code></pre>
<h3 id="font-weight"><a class="header" href="#font-weight">font-weight</a></h3>
<p>Text weight.</p>
<pre><code class="language-css">font-weight: normal;
font-weight: bold;
font-weight: 500;
</code></pre>
<h3 id="font-style"><a class="header" href="#font-style">font-style</a></h3>
<p>Text style.</p>
<pre><code class="language-css">font-style: normal;
font-style: italic;
</code></pre>
<h3 id="font-family"><a class="header" href="#font-family">font-family</a></h3>
<p>Font selection.</p>
<pre><code class="language-css">font-family: "Helvetica Neue", sans-serif;
</code></pre>
<h3 id="text-align"><a class="header" href="#text-align">text-align</a></h3>
<p>Horizontal text alignment.</p>
<pre><code class="language-css">text-align: left;
text-align: center;
text-align: right;
</code></pre>
<h3 id="line-height"><a class="header" href="#line-height">line-height</a></h3>
<p>Line spacing multiplier.</p>
<pre><code class="language-css">line-height: 1.5;
</code></pre>
<h2 id="effects-1"><a class="header" href="#effects-1">Effects</a></h2>
<h3 id="opacity"><a class="header" href="#opacity">opacity</a></h3>
<p>Transparency (0.0 to 1.0).</p>
<pre><code class="language-css">opacity: 0.8;
</code></pre>
<h3 id="box-shadow"><a class="header" href="#box-shadow">box-shadow</a></h3>
<p>Drop shadow.</p>
<pre><code class="language-css">box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
box-shadow: 0 4px 8px #00000033;
</code></pre>
<h2 id="sizing"><a class="header" href="#sizing">Sizing</a></h2>
<h3 id="width-height"><a class="header" href="#width-height">width, height</a></h3>
<p>Explicit dimensions.</p>
<pre><code class="language-css">width: 200px;
height: 100px;
</code></pre>
<h3 id="min-width-min-height"><a class="header" href="#min-width-min-height">min-width, min-height</a></h3>
<p>Minimum dimensions.</p>
<pre><code class="language-css">min-width: 50px;
min-height: 24px;
</code></pre>
<h3 id="max-width-max-height"><a class="header" href="#max-width-max-height">max-width, max-height</a></h3>
<p>Maximum dimensions.</p>
<pre><code class="language-css">max-width: 400px;
max-height: 300px;
</code></pre>
<h2 id="interaction"><a class="header" href="#interaction">Interaction</a></h2>
<h3 id="cursor-1"><a class="header" href="#cursor-1">cursor</a></h3>
<p>Mouse cursor style.</p>
<pre><code class="language-css">cursor: pointer;
cursor: default;
cursor: text;
</code></pre>
<h3 id="pointer-events"><a class="header" href="#pointer-events">pointer-events</a></h3>
<p>Enable/disable mouse interaction.</p>
<pre><code class="language-css">pointer-events: auto;
pointer-events: none;
</code></pre>
<h2 id="special-values"><a class="header" href="#special-values">Special Values</a></h2>
<h3 id="inherit"><a class="header" href="#inherit">inherit</a></h3>
<p>Inherit value from parent.</p>
<pre><code class="language-css">color: inherit;
font-size: inherit;
</code></pre>
<h3 id="initial"><a class="header" href="#initial">initial</a></h3>
<p>Reset to default value.</p>
<pre><code class="language-css">margin: initial;
</code></pre>
<h2 id="flexbox-properties"><a class="header" href="#flexbox-properties">Flexbox Properties</a></h2>
<h3 id="display"><a class="header" href="#display">display</a></h3>
<p>Set layout mode.</p>
<pre><code class="language-css">display: flex;
display: block;
display: none;
</code></pre>
<h3 id="flex-direction"><a class="header" href="#flex-direction">flex-direction</a></h3>
<p>Direction of flex items.</p>
<pre><code class="language-css">flex-direction: row;
flex-direction: column;
flex-direction: row-reverse;
flex-direction: column-reverse;
</code></pre>
<h3 id="justify-content"><a class="header" href="#justify-content">justify-content</a></h3>
<p>Alignment along main axis.</p>
<pre><code class="language-css">justify-content: flex-start;
justify-content: flex-end;
justify-content: center;
justify-content: space-between;
justify-content: space-around;
</code></pre>
<h3 id="align-items"><a class="header" href="#align-items">align-items</a></h3>
<p>Alignment along cross axis.</p>
<pre><code class="language-css">align-items: flex-start;
align-items: flex-end;
align-items: center;
align-items: stretch;
</code></pre>
<h3 id="flex"><a class="header" href="#flex">flex</a></h3>
<p>Flex grow, shrink, and basis.</p>
<pre><code class="language-css">flex: 1;
flex: 0 0 auto;
flex: 1 1 200px;
</code></pre>
<h3 id="gap"><a class="header" href="#gap">gap</a></h3>
<p>Space between flex/grid items.</p>
<pre><code class="language-css">gap: 8px;
gap: 8px 16px;  /* row-gap column-gap */
</code></pre>
<h2 id="transitions"><a class="header" href="#transitions">Transitions</a></h2>
<h3 id="transition"><a class="header" href="#transition">transition</a></h3>
<p>Animate property changes.</p>
<pre><code class="language-css">transition: background-color 0.2s ease;
transition: all 0.3s ease-in-out;
transition: opacity 0.15s, transform 0.2s;
</code></pre>
<h3 id="transition-property"><a class="header" href="#transition-property">transition-property</a></h3>
<p>Properties to animate.</p>
<pre><code class="language-css">transition-property: background-color;
transition-property: all;
transition-property: none;
</code></pre>
<h3 id="transition-duration"><a class="header" href="#transition-duration">transition-duration</a></h3>
<p>Animation duration.</p>
<pre><code class="language-css">transition-duration: 0.2s;
transition-duration: 200ms;
</code></pre>
<h3 id="transition-timing-function"><a class="header" href="#transition-timing-function">transition-timing-function</a></h3>
<p>Easing function.</p>
<pre><code class="language-css">transition-timing-function: ease;
transition-timing-function: ease-in;
transition-timing-function: ease-out;
transition-timing-function: ease-in-out;
transition-timing-function: linear;
transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
</code></pre>
<h2 id="pseudo-classes-1"><a class="header" href="#pseudo-classes-1">Pseudo-Classes</a></h2>
<p>Horizon Lattice supports these pseudo-classes for state-based styling:</p>
<pre><code class="language-css">/* Mouse states */
Button:hover { background-color: #eee; }
Button:pressed { background-color: #ddd; }

/* Focus states */
LineEdit:focus { border-color: #3498db; }
LineEdit:focus-visible { outline: 2px solid #3498db; }

/* Enabled/disabled */
Button:disabled { opacity: 0.5; }
Button:enabled { opacity: 1.0; }

/* Checked state (for checkboxes, radio buttons) */
CheckBox:checked { color: #27ae60; }
CheckBox:unchecked { color: #999; }
CheckBox:indeterminate { color: #666; }

/* First/last child */
ListItem:first-child { border-top: none; }
ListItem:last-child { border-bottom: none; }

/* Nth child */
TableRow:nth-child(odd) { background-color: #f9f9f9; }
TableRow:nth-child(even) { background-color: #fff; }
TableRow:nth-child(3n) { font-weight: bold; }
</code></pre>
<h2 id="widget-specific-properties"><a class="header" href="#widget-specific-properties">Widget-Specific Properties</a></h2>
<h3 id="subcontrol-styling"><a class="header" href="#subcontrol-styling">Subcontrol styling</a></h3>
<p>Some widgets have subcontrols that can be styled:</p>
<pre><code class="language-css">/* Scrollbar */
ScrollBar::handle { background-color: #888; }
ScrollBar::handle:hover { background-color: #555; }
ScrollBar::add-line { background-color: #ddd; }
ScrollBar::sub-line { background-color: #ddd; }

/* Tab */
TabBar::tab { padding: 8px 16px; }
TabBar::tab:selected { background-color: white; }

/* Checkbox indicator */
CheckBox::indicator { width: 16px; height: 16px; }
CheckBox::indicator:checked { background-color: #3498db; }

/* ComboBox dropdown */
ComboBox::drop-down { width: 20px; }
ComboBox::down-arrow { image: url(down-arrow.png); }
</code></pre>
<h2 id="color-functions"><a class="header" href="#color-functions">Color Functions</a></h2>
<h3 id="rgb--rgba"><a class="header" href="#rgb--rgba">rgb / rgba</a></h3>
<pre><code class="language-css">color: rgb(255, 128, 0);
color: rgba(255, 128, 0, 0.5);
</code></pre>
<h3 id="hsl--hsla"><a class="header" href="#hsl--hsla">hsl / hsla</a></h3>
<pre><code class="language-css">color: hsl(200, 80%, 50%);
color: hsla(200, 80%, 50%, 0.8);
</code></pre>
<h3 id="color-mix"><a class="header" href="#color-mix">color-mix</a></h3>
<p>Blend two colors.</p>
<pre><code class="language-css">background-color: color-mix(in srgb, blue 30%, white);
</code></pre>
<h2 id="custom-properties-variables"><a class="header" href="#custom-properties-variables">Custom Properties (Variables)</a></h2>
<h3 id="definition"><a class="header" href="#definition">Definition</a></h3>
<pre><code class="language-css">:root {
    --primary-color: #3498db;
    --spacing-unit: 8px;
    --border-radius: 4px;
}
</code></pre>
<h3 id="usage"><a class="header" href="#usage">Usage</a></h3>
<pre><code class="language-css">Button {
    background-color: var(--primary-color);
    padding: var(--spacing-unit);
    border-radius: var(--border-radius);
}
</code></pre>
<h3 id="fallback-values"><a class="header" href="#fallback-values">Fallback values</a></h3>
<pre><code class="language-css">color: var(--undefined-color, #333);
</code></pre>
<h2 id="units"><a class="header" href="#units">Units</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Unit</th><th>Description</th><th>Example</th></tr>
</thead>
<tbody>
<tr><td><code>px</code></td><td>Pixels (device-independent)</td><td><code>16px</code></td></tr>
<tr><td><code>em</code></td><td>Relative to parent font size</td><td><code>1.5em</code></td></tr>
<tr><td><code>rem</code></td><td>Relative to root font size</td><td><code>1rem</code></td></tr>
<tr><td><code>%</code></td><td>Percentage of parent</td><td><code>50%</code></td></tr>
<tr><td><code>vw</code></td><td>Viewport width percentage</td><td><code>100vw</code></td></tr>
<tr><td><code>vh</code></td><td>Viewport height percentage</td><td><code>50vh</code></td></tr>
</tbody>
</table>
</div>
<h2 id="shorthand-properties"><a class="header" href="#shorthand-properties">Shorthand Properties</a></h2>
<h3 id="margin--padding"><a class="header" href="#margin--padding">margin / padding</a></h3>
<pre><code class="language-css">/* Single value: all sides */
margin: 10px;

/* Two values: vertical horizontal */
margin: 10px 20px;

/* Three values: top horizontal bottom */
margin: 10px 20px 15px;

/* Four values: top right bottom left */
margin: 10px 20px 15px 25px;
</code></pre>
<h3 id="border"><a class="header" href="#border">border</a></h3>
<pre><code class="language-css">/* width style color */
border: 1px solid #333;

/* Individual sides */
border-top: 2px dashed red;
border-left: none;
</code></pre>
<h3 id="background"><a class="header" href="#background">background</a></h3>
<pre><code class="language-css">/* color image position/size repeat */
background: #fff url(bg.png) center/cover no-repeat;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="platform-differences"><a class="header" href="#platform-differences">Platform Differences</a></h1>
<p>Behavior differences across Windows, macOS, and Linux.</p>
<h2 id="window-management"><a class="header" href="#window-management">Window Management</a></h2>
<h3 id="title-bar"><a class="header" href="#title-bar">Title Bar</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Windows</th><th>macOS</th><th>Linux</th></tr>
</thead>
<tbody>
<tr><td>Custom title bar</td><td>Supported</td><td>Limited</td><td>Varies by WM</td></tr>
<tr><td>Traffic lights position</td><td>N/A</td><td>Left</td><td>N/A</td></tr>
<tr><td>Menu in title bar</td><td>Supported</td><td>System menu bar</td><td>Supported</td></tr>
</tbody>
</table>
</div>
<h3 id="window-decorations"><a class="header" href="#window-decorations">Window Decorations</a></h3>
<ul>
<li><strong>Windows</strong>: Standard Win32 decorations</li>
<li><strong>macOS</strong>: Native NSWindow decorations</li>
<li><strong>Linux</strong>: Depends on window manager (X11/Wayland)</li>
</ul>
<h2 id="styling-2"><a class="header" href="#styling-2">Styling</a></h2>
<h3 id="system-colors"><a class="header" href="#system-colors">System Colors</a></h3>
<p>Use <code>SystemTheme::accent_color()</code> for the platform accent color.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Accent Color Source</th></tr>
</thead>
<tbody>
<tr><td>Windows</td><td>WinRT UISettings</td></tr>
<tr><td>macOS</td><td>NSColor.controlAccentColor</td></tr>
<tr><td>Linux</td><td>XDG Portal (if available)</td></tr>
</tbody>
</table>
</div>
<h3 id="dark-mode"><a class="header" href="#dark-mode">Dark Mode</a></h3>
<p>Use <code>SystemTheme::color_scheme()</code> to detect light/dark mode.</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Detection Method</th></tr>
</thead>
<tbody>
<tr><td>Windows</td><td>AppsUseLightTheme registry</td></tr>
<tr><td>macOS</td><td>NSApp.effectiveAppearance</td></tr>
<tr><td>Linux</td><td>XDG Portal color-scheme</td></tr>
</tbody>
</table>
</div>
<h2 id="text-rendering-1"><a class="header" href="#text-rendering-1">Text Rendering</a></h2>
<h3 id="font-selection"><a class="header" href="#font-selection">Font Selection</a></h3>
<p>System fonts vary by platform:</p>
<ul>
<li><strong>Windows</strong>: Segoe UI</li>
<li><strong>macOS</strong>: SF Pro / San Francisco</li>
<li><strong>Linux</strong>: System dependent (often DejaVu)</li>
</ul>
<h3 id="font-rendering"><a class="header" href="#font-rendering">Font Rendering</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Windows</th><th>macOS</th><th>Linux</th></tr>
</thead>
<tbody>
<tr><td>Subpixel AA</td><td>ClearType</td><td>Native</td><td>FreeType</td></tr>
<tr><td>Font hinting</td><td>Strong</td><td>None</td><td>Configurable</td></tr>
</tbody>
</table>
</div>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<h3 id="keyboard"><a class="header" href="#keyboard">Keyboard</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Windows</th><th>macOS</th><th>Linux</th></tr>
</thead>
<tbody>
<tr><td>Command key</td><td>Ctrl</td><td>Cmd</td><td>Ctrl</td></tr>
<tr><td>Context menu</td><td>Application key</td><td>Ctrl+Click</td><td>Application key</td></tr>
<tr><td>IME</td><td>TSF</td><td>Input Sources</td><td>IBus/Fcitx</td></tr>
</tbody>
</table>
</div>
<h3 id="touch"><a class="header" href="#touch">Touch</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Windows</th><th>macOS</th><th>Linux</th></tr>
</thead>
<tbody>
<tr><td>Touch events</td><td>Native</td><td>Native</td><td>Via libinput</td></tr>
<tr><td>Gestures</td><td>WM_GESTURE</td><td>NSEvent</td><td>Limited</td></tr>
</tbody>
</table>
</div>
<h2 id="file-system"><a class="header" href="#file-system">File System</a></h2>
<h3 id="path-conventions"><a class="header" href="#path-conventions">Path Conventions</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Config Dir</th><th>Data Dir</th></tr>
</thead>
<tbody>
<tr><td>Windows</td><td><code>%APPDATA%</code></td><td><code>%LOCALAPPDATA%</code></td></tr>
<tr><td>macOS</td><td><code>~/Library/Application Support</code></td><td>Same</td></tr>
<tr><td>Linux</td><td><code>~/.config</code></td><td><code>~/.local/share</code></td></tr>
</tbody>
</table>
</div>
<p>Use <code>platform::directories()</code> for cross-platform paths.</p>
<h2 id="known-limitations"><a class="header" href="#known-limitations">Known Limitations</a></h2>
<h3 id="linux-1"><a class="header" href="#linux-1">Linux</a></h3>
<ul>
<li>High contrast detection not fully implemented</li>
<li>Some advanced clipboard formats not supported on Wayland</li>
<li>Native file dialogs depend on portal availability</li>
</ul>
<h3 id="macos-1"><a class="header" href="#macos-1">macOS</a></h3>
<ul>
<li>Custom title bar colors limited</li>
<li>Some animations may differ from system style</li>
</ul>
<h3 id="windows-1"><a class="header" href="#windows-1">Windows</a></h3>
<ul>
<li>DPI scaling may require manifest for older apps</li>
<li>Per-monitor DPI awareness needs explicit opt-in</li>
</ul>
<h2 id="graphics-backend"><a class="header" href="#graphics-backend">Graphics Backend</a></h2>
<h3 id="renderer-selection"><a class="header" href="#renderer-selection">Renderer Selection</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Primary Backend</th><th>Fallback</th></tr>
</thead>
<tbody>
<tr><td>Windows</td><td>Direct3D 12</td><td>Vulkan, Direct3D 11</td></tr>
<tr><td>macOS</td><td>Metal</td><td>-</td></tr>
<tr><td>Linux</td><td>Vulkan</td><td>OpenGL</td></tr>
</tbody>
</table>
</div>
<h3 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::render::GraphicsConfig;

// Force specific backend
let config = GraphicsConfig::new()
    .with_preferred_backend(Backend::Vulkan);</code></pre>
<h2 id="clipboard"><a class="header" href="#clipboard">Clipboard</a></h2>
<h3 id="supported-formats"><a class="header" href="#supported-formats">Supported Formats</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Windows</th><th>macOS</th><th>Linux</th></tr>
</thead>
<tbody>
<tr><td>Text</td><td>Full</td><td>Full</td><td>Full</td></tr>
<tr><td>HTML</td><td>Full</td><td>Full</td><td>Partial</td></tr>
<tr><td>Images</td><td>Full</td><td>Full</td><td>X11 only</td></tr>
<tr><td>Files</td><td>Full</td><td>Full</td><td>Wayland limited</td></tr>
</tbody>
</table>
</div>
<h3 id="async-clipboard-wayland"><a class="header" href="#async-clipboard-wayland">Async Clipboard (Wayland)</a></h3>
<p>On Wayland, clipboard operations may be asynchronous:</p>
<pre><code class="language-rust ignore">use horizon_lattice::clipboard::Clipboard;

// Prefer async API on Wayland
Clipboard::get_text_async(|text| {
    if let Some(t) = text {
        println!("Got: {}", t);
    }
});</code></pre>
<h2 id="drag-and-drop"><a class="header" href="#drag-and-drop">Drag and Drop</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Windows</th><th>macOS</th><th>Linux</th></tr>
</thead>
<tbody>
<tr><td>File drops</td><td>Full</td><td>Full</td><td>Full</td></tr>
<tr><td>Custom data</td><td>Full</td><td>Full</td><td>Partial</td></tr>
<tr><td>Drag images</td><td>Full</td><td>Full</td><td>X11 only</td></tr>
</tbody>
</table>
</div>
<h2 id="window-behavior"><a class="header" href="#window-behavior">Window Behavior</a></h2>
<h3 id="fullscreen"><a class="header" href="#fullscreen">Fullscreen</a></h3>
<pre><code class="language-rust ignore">// Native fullscreen (best integration)
window.set_fullscreen(FullscreenMode::Native);

// Borderless fullscreen (consistent across platforms)
window.set_fullscreen(FullscreenMode::Borderless);</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Windows</th><th>macOS</th><th>Linux</th></tr>
</thead>
<tbody>
<tr><td>Native</td><td>Win32</td><td>NSWindow</td><td>WM dependent</td></tr>
<tr><td>Borderless</td><td>Consistent</td><td>Consistent</td><td>Consistent</td></tr>
</tbody>
</table>
</div>
<h3 id="always-on-top"><a class="header" href="#always-on-top">Always on Top</a></h3>
<pre><code class="language-rust ignore">window.set_always_on_top(true);</code></pre>
<p>Works consistently across all platforms.</p>
<h3 id="transparency"><a class="header" href="#transparency">Transparency</a></h3>
<pre><code class="language-rust ignore">window.set_transparent(true);
window.set_opacity(0.9);</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Windows</th><th>macOS</th><th>Linux</th></tr>
</thead>
<tbody>
<tr><td>Window opacity</td><td>Full</td><td>Full</td><td>Compositor dependent</td></tr>
<tr><td>Transparent regions</td><td>Full</td><td>Full</td><td>Compositor dependent</td></tr>
</tbody>
</table>
</div>
<h2 id="dialogs"><a class="header" href="#dialogs">Dialogs</a></h2>
<h3 id="native-dialogs"><a class="header" href="#native-dialogs">Native Dialogs</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Dialog</th><th>Windows</th><th>macOS</th><th>Linux</th></tr>
</thead>
<tbody>
<tr><td>File Open/Save</td><td>IFileDialog</td><td>NSOpenPanel</td><td>Portal/GTK</td></tr>
<tr><td>Color Picker</td><td>ChooseColor</td><td>NSColorPanel</td><td>Portal/GTK</td></tr>
<tr><td>Font Picker</td><td>ChooseFont</td><td>NSFontPanel</td><td>Portal/GTK</td></tr>
<tr><td>Message Box</td><td>MessageBox</td><td>NSAlert</td><td>Portal/GTK</td></tr>
</tbody>
</table>
</div>
<h3 id="linux-portal-integration"><a class="header" href="#linux-portal-integration">Linux Portal Integration</a></h3>
<p>On Linux, Horizon Lattice uses XDG Desktop Portal when available:</p>
<pre><code class="language-rust ignore">use horizon_lattice::platform::linux;

// Check if portals are available
if linux::portals_available() {
    // Native dialogs will use portals
} else {
    // Falls back to GTK dialogs
}</code></pre>
<h2 id="keyboard-shortcuts"><a class="header" href="#keyboard-shortcuts">Keyboard Shortcuts</a></h2>
<h3 id="modifier-key-mapping"><a class="header" href="#modifier-key-mapping">Modifier Key Mapping</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Action</th><th>Windows/Linux</th><th>macOS</th></tr>
</thead>
<tbody>
<tr><td>Copy</td><td>Ctrl+C</td><td>Cmd+C</td></tr>
<tr><td>Paste</td><td>Ctrl+V</td><td>Cmd+V</td></tr>
<tr><td>Cut</td><td>Ctrl+X</td><td>Cmd+X</td></tr>
<tr><td>Undo</td><td>Ctrl+Z</td><td>Cmd+Z</td></tr>
<tr><td>Redo</td><td>Ctrl+Y</td><td>Cmd+Shift+Z</td></tr>
<tr><td>Select All</td><td>Ctrl+A</td><td>Cmd+A</td></tr>
<tr><td>Save</td><td>Ctrl+S</td><td>Cmd+S</td></tr>
<tr><td>Find</td><td>Ctrl+F</td><td>Cmd+F</td></tr>
<tr><td>Close Window</td><td>Alt+F4</td><td>Cmd+W</td></tr>
<tr><td>Quit</td><td>Alt+F4</td><td>Cmd+Q</td></tr>
</tbody>
</table>
</div>
<p>Horizon Lattice automatically maps shortcuts appropriately per platform.</p>
<h2 id="accessibility"><a class="header" href="#accessibility">Accessibility</a></h2>
<h3 id="screen-readers"><a class="header" href="#screen-readers">Screen Readers</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Supported API</th></tr>
</thead>
<tbody>
<tr><td>Windows</td><td>UI Automation</td></tr>
<tr><td>macOS</td><td>NSAccessibility</td></tr>
<tr><td>Linux</td><td>AT-SPI2</td></tr>
</tbody>
</table>
</div>
<h3 id="high-contrast"><a class="header" href="#high-contrast">High Contrast</a></h3>
<pre><code class="language-rust ignore">use horizon_lattice::platform::SystemTheme;

if SystemTheme::is_high_contrast() {
    // Adjust colors for visibility
}</code></pre>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>Detection</th></tr>
</thead>
<tbody>
<tr><td>Windows</td><td>SystemParametersInfo</td></tr>
<tr><td>macOS</td><td>NSWorkspace</td></tr>
<tr><td>Linux</td><td>Portal (partial)</td></tr>
</tbody>
</table>
</div>
<h2 id="locale-and-text"><a class="header" href="#locale-and-text">Locale and Text</a></h2>
<h3 id="input-methods"><a class="header" href="#input-methods">Input Methods</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Platform</th><th>IME Framework</th></tr>
</thead>
<tbody>
<tr><td>Windows</td><td>TSF (Text Services Framework)</td></tr>
<tr><td>macOS</td><td>Input Sources</td></tr>
<tr><td>Linux</td><td>IBus, Fcitx, XIM</td></tr>
</tbody>
</table>
</div>
<h3 id="right-to-left-text"><a class="header" href="#right-to-left-text">Right-to-Left Text</a></h3>
<p>Full RTL support on all platforms. Use <code>TextDirection::Auto</code> for automatic detection:</p>
<pre><code class="language-rust ignore">use horizon_lattice::text::TextDirection;

label.set_text_direction(TextDirection::Auto);</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace-2a3cd908.js"></script>
        <script src="mode-rust-2c9d5c9a.js"></script>
        <script src="editor-16ca416c.js"></script>
        <script src="theme-dawn-4493f9c8.js"></script>
        <script src="theme-tomorrow_night-9dbe62a9.js"></script>

        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
